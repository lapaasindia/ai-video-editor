/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 9545
(__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) {


// EXTERNAL MODULE: ./node_modules/remotion/dist/esm/index.mjs
var esm = __webpack_require__(3947);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(4848);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(5072);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(7825);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(7659);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(5056);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(540);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(1113);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/index.css
var cjs_js_src = __webpack_require__(8972);
;// ./src/index.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());
options.insert = insertBySelector_default().bind(null, "head");
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(cjs_js_src/* default */.A, options);




       /* harmony default export */ const src = (cjs_js_src/* default */.A && cjs_js_src/* default */.A.locals ? cjs_js_src/* default */.A.locals : undefined);

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(6540);
// EXTERNAL MODULE: ./node_modules/zod/lib/index.mjs
var lib = __webpack_require__(4476);
;// ./src/lib/constants.ts

const ASPECT_RATIOS = {
  LANDSCAPE: { width: 3840, height: 2160, label: "16:9 4K" },
  PORTRAIT: { width: 2160, height: 3840, label: "9:16 4K" }
};
const BASE_LANDSCAPE_WIDTH = 1920;
const BASE_PORTRAIT_WIDTH = 1080;
const BASE_LANDSCAPE_HEIGHT = 1080;
const BASE_PORTRAIT_HEIGHT = 1920;
const DEFAULT_FPS = 30;
const DEFAULT_DURATION_SECONDS = 10;
const DEFAULT_DURATION_FRAMES = DEFAULT_FPS * DEFAULT_DURATION_SECONDS;

;// ./src/lib/background.ts
/* unused harmony import specifier */ var getInputProps;



const DEFAULT_BACKGROUND_CONTROLS = {
  showBackground: true,
  transparentBackground: false
};
const useResolvedBackgroundControls = (props) => {
  const contextControls = useBackgroundControls();
  let inputProps = {};
  try {
    inputProps = (0,esm.getInputProps)() ?? {};
  } catch {
  }
  return {
    showBackground: (props == null ? void 0 : props.showBackground) ?? contextControls.showBackground ?? inputProps.showBackground ?? DEFAULT_BACKGROUND_CONTROLS.showBackground,
    transparentBackground: (props == null ? void 0 : props.transparentBackground) ?? contextControls.transparentBackground ?? inputProps.transparentBackground ?? DEFAULT_BACKGROUND_CONTROLS.transparentBackground
  };
};
const BackgroundControlsContext = (0,react.createContext)(
  DEFAULT_BACKGROUND_CONTROLS
);
const BackgroundControlsProvider = BackgroundControlsContext.Provider;
const useBackgroundControls = () => {
  return (0,react.useContext)(BackgroundControlsContext);
};
const resolveBackgroundControls = (props) => {
  let inputProps = {};
  try {
    inputProps = getInputProps() ?? {};
  } catch {
  }
  return {
    showBackground: (props == null ? void 0 : props.showBackground) ?? inputProps.showBackground ?? DEFAULT_BACKGROUND_CONTROLS.showBackground,
    transparentBackground: (props == null ? void 0 : props.transparentBackground) ?? inputProps.transparentBackground ?? DEFAULT_BACKGROUND_CONTROLS.transparentBackground
  };
};
const resolveCanvasBackground = (fallbackColor, controls) => {
  if (controls.transparentBackground) return "transparent";
  return controls.showBackground ? fallbackColor : "transparent";
};
const shouldRenderBackgroundLayer = (controls) => {
  return controls.showBackground && !controls.transparentBackground;
};

;// ./src/templates/registry.ts

const TEMPLATE_CATEGORIES = [
  "case-study",
  "business-news",
  "tech-news",
  "data-visualization",
  "text-animation",
  "logo-reveal",
  "social-media-promo",
  "listicle-ranking",
  "lower-thirds",
  "startup-showcase",
  "social-hooks",
  "business-marketing",
  "platform-mockups"
];
const _registry = [];
function registerTemplate(meta) {
  _registry.push(meta);
}
function getTemplateRegistry() {
  return _registry;
}
function getTemplateById(id) {
  return _registry.find((t) => t.id === id);
}
function getTemplatesByCategory(category) {
  return _registry.filter((t) => t.category === category);
}
function getCategories() {
  return [...TEMPLATE_CATEGORIES];
}
function getCategoryLabel(cat) {
  const labels = {
    "case-study": "Business Case Study",
    "business-news": "Business News",
    "tech-news": "Tech News",
    "data-visualization": "Data Visualization",
    "text-animation": "Text Animation",
    "logo-reveal": "Logo Reveal / Intro",
    "social-media-promo": "Social Media Promo",
    "listicle-ranking": "Listicle / Ranking",
    "lower-thirds": "Lower Thirds & Tickers",
    "startup-showcase": "Startup Showcase",
    "social-hooks": "Social Hooks & Cuts",
    "business-marketing": "Business Marketing",
    "platform-mockups": "Platform Mockups"
  };
  return labels[cat];
}

;// ./src/lib/responsive.ts



function useIsPortrait() {
  const { width, height } = (0,esm.useVideoConfig)();
  return height > width;
}
function useResponsive(landscape, portrait) {
  return useIsPortrait() ? portrait : landscape;
}
function useScaleFactor() {
  const { width } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const base = isPortrait ? BASE_PORTRAIT_WIDTH : BASE_LANDSCAPE_WIDTH;
  return width / base;
}

// EXTERNAL MODULE: ./node_modules/remotion/dist/esm/no-react.mjs
var no_react = __webpack_require__(9382);
;// ./node_modules/@remotion/google-fonts/dist/esm/Inter.mjs
// src/base.ts


var loadedFonts = {};
var withResolvers = function() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
};
var loadFontFaceOrTimeoutAfter20Seconds = (fontFace) => {
  const timeout = withResolvers();
  const int = setTimeout(() => {
    timeout.reject(new Error("Timed out loading Google Font"));
  }, 18000);
  return Promise.race([
    fontFace.load().then(() => {
      clearTimeout(int);
    }),
    timeout.promise
  ]);
};
var loadFonts = (meta, style, options) => {
  const weightsAndSubsetsAreSpecified = Array.isArray(options?.weights) && Array.isArray(options?.subsets) && options.weights.length > 0 && options.subsets.length > 0;
  if (no_react.NoReactInternals.ENABLE_V5_BREAKING_CHANGES && !weightsAndSubsetsAreSpecified) {
    throw new Error("Loading Google Fonts without specifying weights and subsets is not supported in Remotion v5. Please specify the weights and subsets you need.");
  }
  const promises = [];
  const styles = style ? [style] : Object.keys(meta.fonts);
  let fontsLoaded = 0;
  for (const style2 of styles) {
    if (typeof FontFace === "undefined") {
      continue;
    }
    if (!meta.fonts[style2]) {
      throw new Error(`The font ${meta.fontFamily} does not have a style ${style2}`);
    }
    const weights = options?.weights ?? Object.keys(meta.fonts[style2]);
    for (const weight of weights) {
      if (!meta.fonts[style2][weight]) {
        throw new Error(`The font ${meta.fontFamily} does not  have a weight ${weight} in style ${style2}`);
      }
      const subsets = options?.subsets ?? Object.keys(meta.fonts[style2][weight]);
      for (const subset of subsets) {
        let font = meta.fonts[style2]?.[weight]?.[subset];
        if (!font) {
          throw new Error(`weight: ${weight} subset: ${subset} is not available for '${meta.fontFamily}'`);
        }
        let fontKey = `${meta.fontFamily}-${style2}-${weight}-${subset}`;
        const previousPromise = loadedFonts[fontKey];
        if (previousPromise) {
          promises.push(previousPromise);
          continue;
        }
        const baseLabel = `Fetching ${meta.fontFamily} font ${JSON.stringify({
          style: style2,
          weight,
          subset
        })}`;
        const label = weightsAndSubsetsAreSpecified ? baseLabel : `${baseLabel}. This might be caused by loading too many font variations. Read more: https://www.remotion.dev/docs/troubleshooting/font-loading-errors#render-timeout-when-loading-google-fonts`;
        const handle = (0,esm.delayRender)(label, { timeoutInMilliseconds: 60000 });
        fontsLoaded++;
        const fontFace = new FontFace(meta.fontFamily, `url(${font}) format('woff2')`, {
          weight,
          style: style2,
          unicodeRange: meta.unicodeRanges[subset]
        });
        let attempts = 2;
        const tryToLoad = () => {
          if (fontFace.status === "loaded") {
            (0,esm.continueRender)(handle);
            return;
          }
          const promise = loadFontFaceOrTimeoutAfter20Seconds(fontFace).then(() => {
            (options?.document ?? document).fonts.add(fontFace);
            (0,esm.continueRender)(handle);
          }).catch((err) => {
            loadedFonts[fontKey] = undefined;
            if (attempts === 0) {
              throw err;
            } else {
              attempts--;
              tryToLoad();
            }
          });
          loadedFonts[fontKey] = promise;
          promises.push(promise);
        };
        tryToLoad();
      }
    }
    if (fontsLoaded > 20) {
      console.warn(`Made ${fontsLoaded} network requests to load fonts for ${meta.fontFamily}. Consider loading fewer weights and subsets by passing options to loadFont(). Disable this warning by passing "ignoreTooManyRequestsWarning: true" to "options".`);
    }
  }
  return {
    fontFamily: meta.fontFamily,
    fonts: meta.fonts,
    unicodeRanges: meta.unicodeRanges,
    waitUntilDone: () => Promise.all(promises).then(() => {
      return;
    })
  };
};

// src/Inter.ts
var getInfo = () => ({
  fontFamily: "Inter",
  importName: "Inter",
  version: "v20",
  url: "https://fonts.googleapis.com/css2?family=Inter:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900",
  unicodeRanges: {
    "cyrillic-ext": "U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F",
    cyrillic: "U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116",
    "greek-ext": "U+1F00-1FFF",
    greek: "U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF",
    vietnamese: "U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+0300-0301, U+0303-0304, U+0308-0309, U+0323, U+0329, U+1EA0-1EF9, U+20AB",
    "latin-ext": "U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF",
    latin: "U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD"
  },
  fonts: {
    italic: {
      "100": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L0UUMJng.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L9UUMJng.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L1UUMJng.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L6UUMJng.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L2UUMJng.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L3UUMJng.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L5UUM.woff2"
      },
      "200": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L0UUMJng.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L9UUMJng.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L1UUMJng.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L6UUMJng.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L2UUMJng.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L3UUMJng.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L5UUM.woff2"
      },
      "300": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L0UUMJng.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L9UUMJng.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L1UUMJng.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L6UUMJng.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L2UUMJng.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L3UUMJng.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L5UUM.woff2"
      },
      "400": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L0UUMJng.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L9UUMJng.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L1UUMJng.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L6UUMJng.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L2UUMJng.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L3UUMJng.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L5UUM.woff2"
      },
      "500": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L0UUMJng.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L9UUMJng.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L1UUMJng.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L6UUMJng.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L2UUMJng.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L3UUMJng.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L5UUM.woff2"
      },
      "600": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L0UUMJng.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L9UUMJng.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L1UUMJng.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L6UUMJng.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L2UUMJng.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L3UUMJng.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L5UUM.woff2"
      },
      "700": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L0UUMJng.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L9UUMJng.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L1UUMJng.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L6UUMJng.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L2UUMJng.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L3UUMJng.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L5UUM.woff2"
      },
      "800": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L0UUMJng.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L9UUMJng.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L1UUMJng.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L6UUMJng.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L2UUMJng.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L3UUMJng.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L5UUM.woff2"
      },
      "900": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L0UUMJng.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L9UUMJng.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L1UUMJng.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L6UUMJng.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L2UUMJng.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L3UUMJng.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC53FwrK3iLTcvneQg7Ca725JhhKnNqk6L5UUM.woff2"
      }
    },
    normal: {
      "100": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2JL7SUc.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa0ZL7SUc.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2ZL7SUc.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1pL7SUc.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2pL7SUc.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa25L7SUc.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1ZL7.woff2"
      },
      "200": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2JL7SUc.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa0ZL7SUc.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2ZL7SUc.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1pL7SUc.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2pL7SUc.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa25L7SUc.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1ZL7.woff2"
      },
      "300": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2JL7SUc.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa0ZL7SUc.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2ZL7SUc.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1pL7SUc.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2pL7SUc.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa25L7SUc.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1ZL7.woff2"
      },
      "400": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2JL7SUc.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa0ZL7SUc.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2ZL7SUc.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1pL7SUc.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2pL7SUc.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa25L7SUc.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1ZL7.woff2"
      },
      "500": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2JL7SUc.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa0ZL7SUc.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2ZL7SUc.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1pL7SUc.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2pL7SUc.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa25L7SUc.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1ZL7.woff2"
      },
      "600": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2JL7SUc.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa0ZL7SUc.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2ZL7SUc.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1pL7SUc.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2pL7SUc.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa25L7SUc.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1ZL7.woff2"
      },
      "700": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2JL7SUc.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa0ZL7SUc.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2ZL7SUc.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1pL7SUc.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2pL7SUc.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa25L7SUc.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1ZL7.woff2"
      },
      "800": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2JL7SUc.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa0ZL7SUc.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2ZL7SUc.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1pL7SUc.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2pL7SUc.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa25L7SUc.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1ZL7.woff2"
      },
      "900": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2JL7SUc.woff2",
        cyrillic: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa0ZL7SUc.woff2",
        "greek-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2ZL7SUc.woff2",
        greek: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1pL7SUc.woff2",
        vietnamese: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa2pL7SUc.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa25L7SUc.woff2",
        latin: "https://fonts.gstatic.com/s/inter/v20/UcC73FwrK3iLTeHuS_nVMrMxCp50SjIa1ZL7.woff2"
      }
    }
  },
  subsets: [
    "cyrillic",
    "cyrillic-ext",
    "greek",
    "greek-ext",
    "latin",
    "latin-ext",
    "vietnamese"
  ]
});
var fontFamily = "Inter";
var loadFont = (style, options) => {
  return loadFonts(getInfo(), style, options);
};


;// ./node_modules/@remotion/google-fonts/dist/esm/Poppins.mjs
// src/base.ts


var Poppins_loadedFonts = {};
var Poppins_withResolvers = function() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
};
var Poppins_loadFontFaceOrTimeoutAfter20Seconds = (fontFace) => {
  const timeout = Poppins_withResolvers();
  const int = setTimeout(() => {
    timeout.reject(new Error("Timed out loading Google Font"));
  }, 18000);
  return Promise.race([
    fontFace.load().then(() => {
      clearTimeout(int);
    }),
    timeout.promise
  ]);
};
var Poppins_loadFonts = (meta, style, options) => {
  const weightsAndSubsetsAreSpecified = Array.isArray(options?.weights) && Array.isArray(options?.subsets) && options.weights.length > 0 && options.subsets.length > 0;
  if (no_react.NoReactInternals.ENABLE_V5_BREAKING_CHANGES && !weightsAndSubsetsAreSpecified) {
    throw new Error("Loading Google Fonts without specifying weights and subsets is not supported in Remotion v5. Please specify the weights and subsets you need.");
  }
  const promises = [];
  const styles = style ? [style] : Object.keys(meta.fonts);
  let fontsLoaded = 0;
  for (const style2 of styles) {
    if (typeof FontFace === "undefined") {
      continue;
    }
    if (!meta.fonts[style2]) {
      throw new Error(`The font ${meta.fontFamily} does not have a style ${style2}`);
    }
    const weights = options?.weights ?? Object.keys(meta.fonts[style2]);
    for (const weight of weights) {
      if (!meta.fonts[style2][weight]) {
        throw new Error(`The font ${meta.fontFamily} does not  have a weight ${weight} in style ${style2}`);
      }
      const subsets = options?.subsets ?? Object.keys(meta.fonts[style2][weight]);
      for (const subset of subsets) {
        let font = meta.fonts[style2]?.[weight]?.[subset];
        if (!font) {
          throw new Error(`weight: ${weight} subset: ${subset} is not available for '${meta.fontFamily}'`);
        }
        let fontKey = `${meta.fontFamily}-${style2}-${weight}-${subset}`;
        const previousPromise = Poppins_loadedFonts[fontKey];
        if (previousPromise) {
          promises.push(previousPromise);
          continue;
        }
        const baseLabel = `Fetching ${meta.fontFamily} font ${JSON.stringify({
          style: style2,
          weight,
          subset
        })}`;
        const label = weightsAndSubsetsAreSpecified ? baseLabel : `${baseLabel}. This might be caused by loading too many font variations. Read more: https://www.remotion.dev/docs/troubleshooting/font-loading-errors#render-timeout-when-loading-google-fonts`;
        const handle = (0,esm.delayRender)(label, { timeoutInMilliseconds: 60000 });
        fontsLoaded++;
        const fontFace = new FontFace(meta.fontFamily, `url(${font}) format('woff2')`, {
          weight,
          style: style2,
          unicodeRange: meta.unicodeRanges[subset]
        });
        let attempts = 2;
        const tryToLoad = () => {
          if (fontFace.status === "loaded") {
            (0,esm.continueRender)(handle);
            return;
          }
          const promise = Poppins_loadFontFaceOrTimeoutAfter20Seconds(fontFace).then(() => {
            (options?.document ?? document).fonts.add(fontFace);
            (0,esm.continueRender)(handle);
          }).catch((err) => {
            Poppins_loadedFonts[fontKey] = undefined;
            if (attempts === 0) {
              throw err;
            } else {
              attempts--;
              tryToLoad();
            }
          });
          Poppins_loadedFonts[fontKey] = promise;
          promises.push(promise);
        };
        tryToLoad();
      }
    }
    if (fontsLoaded > 20) {
      console.warn(`Made ${fontsLoaded} network requests to load fonts for ${meta.fontFamily}. Consider loading fewer weights and subsets by passing options to loadFont(). Disable this warning by passing "ignoreTooManyRequestsWarning: true" to "options".`);
    }
  }
  return {
    fontFamily: meta.fontFamily,
    fonts: meta.fonts,
    unicodeRanges: meta.unicodeRanges,
    waitUntilDone: () => Promise.all(promises).then(() => {
      return;
    })
  };
};

// src/Poppins.ts
var Poppins_getInfo = () => ({
  fontFamily: "Poppins",
  importName: "Poppins",
  version: "v24",
  url: "https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900",
  unicodeRanges: {
    devanagari: "U+0900-097F, U+1CD0-1CF9, U+200C-200D, U+20A8, U+20B9, U+20F0, U+25CC, U+A830-A839, U+A8E0-A8FF, U+11B00-11B09",
    "latin-ext": "U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF",
    latin: "U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD"
  },
  fonts: {
    italic: {
      "100": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiAyp8kv8JHgFVrJJLmE0tDMPKzSQ.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiAyp8kv8JHgFVrJJLmE0tMMPKzSQ.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiAyp8kv8JHgFVrJJLmE0tCMPI.woff2"
      },
      "200": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLmv1pVFteOcEg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLmv1pVGdeOcEg.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLmv1pVF9eO.woff2"
      },
      "300": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLm21lVFteOcEg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLm21lVGdeOcEg.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLm21lVF9eO.woff2"
      },
      "400": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiGyp8kv8JHgFVrJJLucXtAKPY.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiGyp8kv8JHgFVrJJLufntAKPY.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiGyp8kv8JHgFVrJJLucHtA.woff2"
      },
      "500": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLmg1hVFteOcEg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLmg1hVGdeOcEg.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLmg1hVF9eO.woff2"
      },
      "600": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLmr19VFteOcEg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLmr19VGdeOcEg.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLmr19VF9eO.woff2"
      },
      "700": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLmy15VFteOcEg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLmy15VGdeOcEg.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLmy15VF9eO.woff2"
      },
      "800": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLm111VFteOcEg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLm111VGdeOcEg.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLm111VF9eO.woff2"
      },
      "900": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLm81xVFteOcEg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLm81xVGdeOcEg.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiDyp8kv8JHgFVrJJLm81xVF9eO.woff2"
      }
    },
    normal: {
      "100": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiGyp8kv8JHgFVrLPTucXtAKPY.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiGyp8kv8JHgFVrLPTufntAKPY.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiGyp8kv8JHgFVrLPTucHtA.woff2"
      },
      "200": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLFj_Z11lFc-K.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLFj_Z1JlFc-K.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLFj_Z1xlFQ.woff2"
      },
      "300": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLDz8Z11lFc-K.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLDz8Z1JlFc-K.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLDz8Z1xlFQ.woff2"
      },
      "400": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiEyp8kv8JHgFVrJJbecmNE.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiEyp8kv8JHgFVrJJnecmNE.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiEyp8kv8JHgFVrJJfecg.woff2"
      },
      "500": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLGT9Z11lFc-K.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLGT9Z1JlFc-K.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLGT9Z1xlFQ.woff2"
      },
      "600": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLEj6Z11lFc-K.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLEj6Z1JlFc-K.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLEj6Z1xlFQ.woff2"
      },
      "700": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLCz7Z11lFc-K.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLCz7Z1JlFc-K.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLCz7Z1xlFQ.woff2"
      },
      "800": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLDD4Z11lFc-K.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLDD4Z1JlFc-K.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLDD4Z1xlFQ.woff2"
      },
      "900": {
        devanagari: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLBT5Z11lFc-K.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLBT5Z1JlFc-K.woff2",
        latin: "https://fonts.gstatic.com/s/poppins/v24/pxiByp8kv8JHgFVrLBT5Z1xlFQ.woff2"
      }
    }
  },
  subsets: ["devanagari", "latin", "latin-ext"]
});
var Poppins_fontFamily = "Poppins";
var Poppins_loadFont = (style, options) => {
  return Poppins_loadFonts(Poppins_getInfo(), style, options);
};


;// ./node_modules/@remotion/google-fonts/dist/esm/Montserrat.mjs
// src/base.ts


var Montserrat_loadedFonts = {};
var Montserrat_withResolvers = function() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
};
var Montserrat_loadFontFaceOrTimeoutAfter20Seconds = (fontFace) => {
  const timeout = Montserrat_withResolvers();
  const int = setTimeout(() => {
    timeout.reject(new Error("Timed out loading Google Font"));
  }, 18000);
  return Promise.race([
    fontFace.load().then(() => {
      clearTimeout(int);
    }),
    timeout.promise
  ]);
};
var Montserrat_loadFonts = (meta, style, options) => {
  const weightsAndSubsetsAreSpecified = Array.isArray(options?.weights) && Array.isArray(options?.subsets) && options.weights.length > 0 && options.subsets.length > 0;
  if (no_react.NoReactInternals.ENABLE_V5_BREAKING_CHANGES && !weightsAndSubsetsAreSpecified) {
    throw new Error("Loading Google Fonts without specifying weights and subsets is not supported in Remotion v5. Please specify the weights and subsets you need.");
  }
  const promises = [];
  const styles = style ? [style] : Object.keys(meta.fonts);
  let fontsLoaded = 0;
  for (const style2 of styles) {
    if (typeof FontFace === "undefined") {
      continue;
    }
    if (!meta.fonts[style2]) {
      throw new Error(`The font ${meta.fontFamily} does not have a style ${style2}`);
    }
    const weights = options?.weights ?? Object.keys(meta.fonts[style2]);
    for (const weight of weights) {
      if (!meta.fonts[style2][weight]) {
        throw new Error(`The font ${meta.fontFamily} does not  have a weight ${weight} in style ${style2}`);
      }
      const subsets = options?.subsets ?? Object.keys(meta.fonts[style2][weight]);
      for (const subset of subsets) {
        let font = meta.fonts[style2]?.[weight]?.[subset];
        if (!font) {
          throw new Error(`weight: ${weight} subset: ${subset} is not available for '${meta.fontFamily}'`);
        }
        let fontKey = `${meta.fontFamily}-${style2}-${weight}-${subset}`;
        const previousPromise = Montserrat_loadedFonts[fontKey];
        if (previousPromise) {
          promises.push(previousPromise);
          continue;
        }
        const baseLabel = `Fetching ${meta.fontFamily} font ${JSON.stringify({
          style: style2,
          weight,
          subset
        })}`;
        const label = weightsAndSubsetsAreSpecified ? baseLabel : `${baseLabel}. This might be caused by loading too many font variations. Read more: https://www.remotion.dev/docs/troubleshooting/font-loading-errors#render-timeout-when-loading-google-fonts`;
        const handle = (0,esm.delayRender)(label, { timeoutInMilliseconds: 60000 });
        fontsLoaded++;
        const fontFace = new FontFace(meta.fontFamily, `url(${font}) format('woff2')`, {
          weight,
          style: style2,
          unicodeRange: meta.unicodeRanges[subset]
        });
        let attempts = 2;
        const tryToLoad = () => {
          if (fontFace.status === "loaded") {
            (0,esm.continueRender)(handle);
            return;
          }
          const promise = Montserrat_loadFontFaceOrTimeoutAfter20Seconds(fontFace).then(() => {
            (options?.document ?? document).fonts.add(fontFace);
            (0,esm.continueRender)(handle);
          }).catch((err) => {
            Montserrat_loadedFonts[fontKey] = undefined;
            if (attempts === 0) {
              throw err;
            } else {
              attempts--;
              tryToLoad();
            }
          });
          Montserrat_loadedFonts[fontKey] = promise;
          promises.push(promise);
        };
        tryToLoad();
      }
    }
    if (fontsLoaded > 20) {
      console.warn(`Made ${fontsLoaded} network requests to load fonts for ${meta.fontFamily}. Consider loading fewer weights and subsets by passing options to loadFont(). Disable this warning by passing "ignoreTooManyRequestsWarning: true" to "options".`);
    }
  }
  return {
    fontFamily: meta.fontFamily,
    fonts: meta.fonts,
    unicodeRanges: meta.unicodeRanges,
    waitUntilDone: () => Promise.all(promises).then(() => {
      return;
    })
  };
};

// src/Montserrat.ts
var Montserrat_getInfo = () => ({
  fontFamily: "Montserrat",
  importName: "Montserrat",
  version: "v31",
  url: "https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900",
  unicodeRanges: {
    "cyrillic-ext": "U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F",
    cyrillic: "U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116",
    vietnamese: "U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+0300-0301, U+0303-0304, U+0308-0309, U+0323, U+0329, U+1EA0-1EF9, U+20AB",
    "latin-ext": "U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF",
    latin: "U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD"
  },
  fonts: {
    italic: {
      "100": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxC7mw9c.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRzS7mw9c.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxi7mw9c.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxy7mw9c.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRyS7m.woff2"
      },
      "200": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxC7mw9c.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRzS7mw9c.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxi7mw9c.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxy7mw9c.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRyS7m.woff2"
      },
      "300": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxC7mw9c.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRzS7mw9c.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxi7mw9c.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxy7mw9c.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRyS7m.woff2"
      },
      "400": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxC7mw9c.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRzS7mw9c.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxi7mw9c.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxy7mw9c.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRyS7m.woff2"
      },
      "500": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxC7mw9c.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRzS7mw9c.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxi7mw9c.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxy7mw9c.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRyS7m.woff2"
      },
      "600": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxC7mw9c.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRzS7mw9c.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxi7mw9c.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxy7mw9c.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRyS7m.woff2"
      },
      "700": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxC7mw9c.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRzS7mw9c.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxi7mw9c.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxy7mw9c.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRyS7m.woff2"
      },
      "800": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxC7mw9c.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRzS7mw9c.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxi7mw9c.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxy7mw9c.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRyS7m.woff2"
      },
      "900": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxC7mw9c.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRzS7mw9c.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxi7mw9c.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRxy7mw9c.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUQjIg1_i6t8kCHKm459WxRyS7m.woff2"
      }
    },
    normal: {
      "100": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WRhyzbi.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459W1hyzbi.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WZhyzbi.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wdhyzbi.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wlhyw.woff2"
      },
      "200": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WRhyzbi.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459W1hyzbi.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WZhyzbi.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wdhyzbi.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wlhyw.woff2"
      },
      "300": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WRhyzbi.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459W1hyzbi.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WZhyzbi.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wdhyzbi.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wlhyw.woff2"
      },
      "400": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WRhyzbi.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459W1hyzbi.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WZhyzbi.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wdhyzbi.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wlhyw.woff2"
      },
      "500": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WRhyzbi.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459W1hyzbi.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WZhyzbi.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wdhyzbi.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wlhyw.woff2"
      },
      "600": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WRhyzbi.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459W1hyzbi.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WZhyzbi.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wdhyzbi.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wlhyw.woff2"
      },
      "700": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WRhyzbi.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459W1hyzbi.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WZhyzbi.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wdhyzbi.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wlhyw.woff2"
      },
      "800": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WRhyzbi.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459W1hyzbi.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WZhyzbi.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wdhyzbi.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wlhyw.woff2"
      },
      "900": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WRhyzbi.woff2",
        cyrillic: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459W1hyzbi.woff2",
        vietnamese: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459WZhyzbi.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wdhyzbi.woff2",
        latin: "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg1_i6t8kCHKm459Wlhyw.woff2"
      }
    }
  },
  subsets: ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
});
var Montserrat_fontFamily = "Montserrat";
var Montserrat_loadFont = (style, options) => {
  return Montserrat_loadFonts(Montserrat_getInfo(), style, options);
};


;// ./node_modules/@remotion/google-fonts/dist/esm/PlayfairDisplay.mjs
// src/base.ts


var PlayfairDisplay_loadedFonts = {};
var PlayfairDisplay_withResolvers = function() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
};
var PlayfairDisplay_loadFontFaceOrTimeoutAfter20Seconds = (fontFace) => {
  const timeout = PlayfairDisplay_withResolvers();
  const int = setTimeout(() => {
    timeout.reject(new Error("Timed out loading Google Font"));
  }, 18000);
  return Promise.race([
    fontFace.load().then(() => {
      clearTimeout(int);
    }),
    timeout.promise
  ]);
};
var PlayfairDisplay_loadFonts = (meta, style, options) => {
  const weightsAndSubsetsAreSpecified = Array.isArray(options?.weights) && Array.isArray(options?.subsets) && options.weights.length > 0 && options.subsets.length > 0;
  if (no_react.NoReactInternals.ENABLE_V5_BREAKING_CHANGES && !weightsAndSubsetsAreSpecified) {
    throw new Error("Loading Google Fonts without specifying weights and subsets is not supported in Remotion v5. Please specify the weights and subsets you need.");
  }
  const promises = [];
  const styles = style ? [style] : Object.keys(meta.fonts);
  let fontsLoaded = 0;
  for (const style2 of styles) {
    if (typeof FontFace === "undefined") {
      continue;
    }
    if (!meta.fonts[style2]) {
      throw new Error(`The font ${meta.fontFamily} does not have a style ${style2}`);
    }
    const weights = options?.weights ?? Object.keys(meta.fonts[style2]);
    for (const weight of weights) {
      if (!meta.fonts[style2][weight]) {
        throw new Error(`The font ${meta.fontFamily} does not  have a weight ${weight} in style ${style2}`);
      }
      const subsets = options?.subsets ?? Object.keys(meta.fonts[style2][weight]);
      for (const subset of subsets) {
        let font = meta.fonts[style2]?.[weight]?.[subset];
        if (!font) {
          throw new Error(`weight: ${weight} subset: ${subset} is not available for '${meta.fontFamily}'`);
        }
        let fontKey = `${meta.fontFamily}-${style2}-${weight}-${subset}`;
        const previousPromise = PlayfairDisplay_loadedFonts[fontKey];
        if (previousPromise) {
          promises.push(previousPromise);
          continue;
        }
        const baseLabel = `Fetching ${meta.fontFamily} font ${JSON.stringify({
          style: style2,
          weight,
          subset
        })}`;
        const label = weightsAndSubsetsAreSpecified ? baseLabel : `${baseLabel}. This might be caused by loading too many font variations. Read more: https://www.remotion.dev/docs/troubleshooting/font-loading-errors#render-timeout-when-loading-google-fonts`;
        const handle = (0,esm.delayRender)(label, { timeoutInMilliseconds: 60000 });
        fontsLoaded++;
        const fontFace = new FontFace(meta.fontFamily, `url(${font}) format('woff2')`, {
          weight,
          style: style2,
          unicodeRange: meta.unicodeRanges[subset]
        });
        let attempts = 2;
        const tryToLoad = () => {
          if (fontFace.status === "loaded") {
            (0,esm.continueRender)(handle);
            return;
          }
          const promise = PlayfairDisplay_loadFontFaceOrTimeoutAfter20Seconds(fontFace).then(() => {
            (options?.document ?? document).fonts.add(fontFace);
            (0,esm.continueRender)(handle);
          }).catch((err) => {
            PlayfairDisplay_loadedFonts[fontKey] = undefined;
            if (attempts === 0) {
              throw err;
            } else {
              attempts--;
              tryToLoad();
            }
          });
          PlayfairDisplay_loadedFonts[fontKey] = promise;
          promises.push(promise);
        };
        tryToLoad();
      }
    }
    if (fontsLoaded > 20) {
      console.warn(`Made ${fontsLoaded} network requests to load fonts for ${meta.fontFamily}. Consider loading fewer weights and subsets by passing options to loadFont(). Disable this warning by passing "ignoreTooManyRequestsWarning: true" to "options".`);
    }
  }
  return {
    fontFamily: meta.fontFamily,
    fonts: meta.fonts,
    unicodeRanges: meta.unicodeRanges,
    waitUntilDone: () => Promise.all(promises).then(() => {
      return;
    })
  };
};

// src/PlayfairDisplay.ts
var PlayfairDisplay_getInfo = () => ({
  fontFamily: "Playfair Display",
  importName: "PlayfairDisplay",
  version: "v40",
  url: "https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,500;0,600;0,700;0,800;0,900;1,400;1,500;1,600;1,700;1,800;1,900",
  unicodeRanges: {
    cyrillic: "U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116",
    vietnamese: "U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+0300-0301, U+0303-0304, U+0308-0309, U+0323, U+0329, U+1EA0-1EF9, U+20AB",
    "latin-ext": "U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF",
    latin: "U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD"
  },
  fonts: {
    italic: {
      "400": {
        cyrillic: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnohkk72xU.woff2",
        vietnamese: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnojUk72xU.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnojEk72xU.woff2",
        latin: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnogkk7.woff2"
      },
      "500": {
        cyrillic: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnohkk72xU.woff2",
        vietnamese: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnojUk72xU.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnojEk72xU.woff2",
        latin: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnogkk7.woff2"
      },
      "600": {
        cyrillic: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnohkk72xU.woff2",
        vietnamese: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnojUk72xU.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnojEk72xU.woff2",
        latin: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnogkk7.woff2"
      },
      "700": {
        cyrillic: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnohkk72xU.woff2",
        vietnamese: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnojUk72xU.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnojEk72xU.woff2",
        latin: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnogkk7.woff2"
      },
      "800": {
        cyrillic: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnohkk72xU.woff2",
        vietnamese: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnojUk72xU.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnojEk72xU.woff2",
        latin: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnogkk7.woff2"
      },
      "900": {
        cyrillic: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnohkk72xU.woff2",
        vietnamese: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnojUk72xU.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnojEk72xU.woff2",
        latin: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFkD-vYSZviVYUb_rj3ij__anPXDTnogkk7.woff2"
      }
    },
    normal: {
      "400": {
        cyrillic: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTjYgFE_.woff2",
        vietnamese: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTPYgFE_.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTLYgFE_.woff2",
        latin: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTzYgA.woff2"
      },
      "500": {
        cyrillic: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTjYgFE_.woff2",
        vietnamese: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTPYgFE_.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTLYgFE_.woff2",
        latin: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTzYgA.woff2"
      },
      "600": {
        cyrillic: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTjYgFE_.woff2",
        vietnamese: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTPYgFE_.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTLYgFE_.woff2",
        latin: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTzYgA.woff2"
      },
      "700": {
        cyrillic: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTjYgFE_.woff2",
        vietnamese: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTPYgFE_.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTLYgFE_.woff2",
        latin: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTzYgA.woff2"
      },
      "800": {
        cyrillic: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTjYgFE_.woff2",
        vietnamese: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTPYgFE_.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTLYgFE_.woff2",
        latin: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTzYgA.woff2"
      },
      "900": {
        cyrillic: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTjYgFE_.woff2",
        vietnamese: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTPYgFE_.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTLYgFE_.woff2",
        latin: "https://fonts.gstatic.com/s/playfairdisplay/v40/nuFiD-vYSZviVYUb_rj3ij__anPXDTzYgA.woff2"
      }
    }
  },
  subsets: ["cyrillic", "latin", "latin-ext", "vietnamese"]
});
var PlayfairDisplay_fontFamily = "Playfair Display";
var PlayfairDisplay_loadFont = (style, options) => {
  return PlayfairDisplay_loadFonts(PlayfairDisplay_getInfo(), style, options);
};


;// ./node_modules/@remotion/google-fonts/dist/esm/RobotoMono.mjs
// src/base.ts


var RobotoMono_loadedFonts = {};
var RobotoMono_withResolvers = function() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
};
var RobotoMono_loadFontFaceOrTimeoutAfter20Seconds = (fontFace) => {
  const timeout = RobotoMono_withResolvers();
  const int = setTimeout(() => {
    timeout.reject(new Error("Timed out loading Google Font"));
  }, 18000);
  return Promise.race([
    fontFace.load().then(() => {
      clearTimeout(int);
    }),
    timeout.promise
  ]);
};
var RobotoMono_loadFonts = (meta, style, options) => {
  const weightsAndSubsetsAreSpecified = Array.isArray(options?.weights) && Array.isArray(options?.subsets) && options.weights.length > 0 && options.subsets.length > 0;
  if (no_react.NoReactInternals.ENABLE_V5_BREAKING_CHANGES && !weightsAndSubsetsAreSpecified) {
    throw new Error("Loading Google Fonts without specifying weights and subsets is not supported in Remotion v5. Please specify the weights and subsets you need.");
  }
  const promises = [];
  const styles = style ? [style] : Object.keys(meta.fonts);
  let fontsLoaded = 0;
  for (const style2 of styles) {
    if (typeof FontFace === "undefined") {
      continue;
    }
    if (!meta.fonts[style2]) {
      throw new Error(`The font ${meta.fontFamily} does not have a style ${style2}`);
    }
    const weights = options?.weights ?? Object.keys(meta.fonts[style2]);
    for (const weight of weights) {
      if (!meta.fonts[style2][weight]) {
        throw new Error(`The font ${meta.fontFamily} does not  have a weight ${weight} in style ${style2}`);
      }
      const subsets = options?.subsets ?? Object.keys(meta.fonts[style2][weight]);
      for (const subset of subsets) {
        let font = meta.fonts[style2]?.[weight]?.[subset];
        if (!font) {
          throw new Error(`weight: ${weight} subset: ${subset} is not available for '${meta.fontFamily}'`);
        }
        let fontKey = `${meta.fontFamily}-${style2}-${weight}-${subset}`;
        const previousPromise = RobotoMono_loadedFonts[fontKey];
        if (previousPromise) {
          promises.push(previousPromise);
          continue;
        }
        const baseLabel = `Fetching ${meta.fontFamily} font ${JSON.stringify({
          style: style2,
          weight,
          subset
        })}`;
        const label = weightsAndSubsetsAreSpecified ? baseLabel : `${baseLabel}. This might be caused by loading too many font variations. Read more: https://www.remotion.dev/docs/troubleshooting/font-loading-errors#render-timeout-when-loading-google-fonts`;
        const handle = (0,esm.delayRender)(label, { timeoutInMilliseconds: 60000 });
        fontsLoaded++;
        const fontFace = new FontFace(meta.fontFamily, `url(${font}) format('woff2')`, {
          weight,
          style: style2,
          unicodeRange: meta.unicodeRanges[subset]
        });
        let attempts = 2;
        const tryToLoad = () => {
          if (fontFace.status === "loaded") {
            (0,esm.continueRender)(handle);
            return;
          }
          const promise = RobotoMono_loadFontFaceOrTimeoutAfter20Seconds(fontFace).then(() => {
            (options?.document ?? document).fonts.add(fontFace);
            (0,esm.continueRender)(handle);
          }).catch((err) => {
            RobotoMono_loadedFonts[fontKey] = undefined;
            if (attempts === 0) {
              throw err;
            } else {
              attempts--;
              tryToLoad();
            }
          });
          RobotoMono_loadedFonts[fontKey] = promise;
          promises.push(promise);
        };
        tryToLoad();
      }
    }
    if (fontsLoaded > 20) {
      console.warn(`Made ${fontsLoaded} network requests to load fonts for ${meta.fontFamily}. Consider loading fewer weights and subsets by passing options to loadFont(). Disable this warning by passing "ignoreTooManyRequestsWarning: true" to "options".`);
    }
  }
  return {
    fontFamily: meta.fontFamily,
    fonts: meta.fonts,
    unicodeRanges: meta.unicodeRanges,
    waitUntilDone: () => Promise.all(promises).then(() => {
      return;
    })
  };
};

// src/RobotoMono.ts
var RobotoMono_getInfo = () => ({
  fontFamily: "Roboto Mono",
  importName: "RobotoMono",
  version: "v31",
  url: "https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700",
  unicodeRanges: {
    "cyrillic-ext": "U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F",
    cyrillic: "U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116",
    greek: "U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF",
    vietnamese: "U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+0300-0301, U+0303-0304, U+0308-0309, U+0323, U+0329, U+1EA0-1EF9, U+20AB",
    "latin-ext": "U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF",
    latin: "U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD"
  },
  fonts: {
    italic: {
      "100": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3CWWoKC.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3mWWoKC.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm36WWoKC.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3KWWoKC.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3OWWoKC.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm32WWg.woff2"
      },
      "200": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3CWWoKC.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3mWWoKC.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm36WWoKC.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3KWWoKC.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3OWWoKC.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm32WWg.woff2"
      },
      "300": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3CWWoKC.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3mWWoKC.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm36WWoKC.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3KWWoKC.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3OWWoKC.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm32WWg.woff2"
      },
      "400": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3CWWoKC.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3mWWoKC.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm36WWoKC.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3KWWoKC.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3OWWoKC.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm32WWg.woff2"
      },
      "500": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3CWWoKC.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3mWWoKC.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm36WWoKC.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3KWWoKC.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3OWWoKC.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm32WWg.woff2"
      },
      "600": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3CWWoKC.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3mWWoKC.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm36WWoKC.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3KWWoKC.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3OWWoKC.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm32WWg.woff2"
      },
      "700": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3CWWoKC.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3mWWoKC.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm36WWoKC.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3KWWoKC.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm3OWWoKC.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x7DF4xlVMF-BfR8bXMIjhOm32WWg.woff2"
      }
    },
    normal: {
      "100": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhGq3-OXg.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhPq3-OXg.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhIq3-OXg.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhEq3-OXg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhFq3-OXg.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhLq38.woff2"
      },
      "200": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhGq3-OXg.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhPq3-OXg.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhIq3-OXg.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhEq3-OXg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhFq3-OXg.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhLq38.woff2"
      },
      "300": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhGq3-OXg.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhPq3-OXg.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhIq3-OXg.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhEq3-OXg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhFq3-OXg.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhLq38.woff2"
      },
      "400": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhGq3-OXg.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhPq3-OXg.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhIq3-OXg.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhEq3-OXg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhFq3-OXg.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhLq38.woff2"
      },
      "500": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhGq3-OXg.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhPq3-OXg.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhIq3-OXg.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhEq3-OXg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhFq3-OXg.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhLq38.woff2"
      },
      "600": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhGq3-OXg.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhPq3-OXg.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhIq3-OXg.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhEq3-OXg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhFq3-OXg.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhLq38.woff2"
      },
      "700": {
        "cyrillic-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhGq3-OXg.woff2",
        cyrillic: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhPq3-OXg.woff2",
        greek: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhIq3-OXg.woff2",
        vietnamese: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhEq3-OXg.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhFq3-OXg.woff2",
        latin: "https://fonts.gstatic.com/s/robotomono/v31/L0x5DF4xlVMF-BfR8bXMIjhLq38.woff2"
      }
    }
  },
  subsets: [
    "cyrillic",
    "cyrillic-ext",
    "greek",
    "latin",
    "latin-ext",
    "vietnamese"
  ]
});
var RobotoMono_fontFamily = "Roboto Mono";
var RobotoMono_loadFont = (style, options) => {
  return RobotoMono_loadFonts(RobotoMono_getInfo(), style, options);
};


;// ./node_modules/@remotion/google-fonts/dist/esm/SpaceGrotesk.mjs
// src/base.ts


var SpaceGrotesk_loadedFonts = {};
var SpaceGrotesk_withResolvers = function() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
};
var SpaceGrotesk_loadFontFaceOrTimeoutAfter20Seconds = (fontFace) => {
  const timeout = SpaceGrotesk_withResolvers();
  const int = setTimeout(() => {
    timeout.reject(new Error("Timed out loading Google Font"));
  }, 18000);
  return Promise.race([
    fontFace.load().then(() => {
      clearTimeout(int);
    }),
    timeout.promise
  ]);
};
var SpaceGrotesk_loadFonts = (meta, style, options) => {
  const weightsAndSubsetsAreSpecified = Array.isArray(options?.weights) && Array.isArray(options?.subsets) && options.weights.length > 0 && options.subsets.length > 0;
  if (no_react.NoReactInternals.ENABLE_V5_BREAKING_CHANGES && !weightsAndSubsetsAreSpecified) {
    throw new Error("Loading Google Fonts without specifying weights and subsets is not supported in Remotion v5. Please specify the weights and subsets you need.");
  }
  const promises = [];
  const styles = style ? [style] : Object.keys(meta.fonts);
  let fontsLoaded = 0;
  for (const style2 of styles) {
    if (typeof FontFace === "undefined") {
      continue;
    }
    if (!meta.fonts[style2]) {
      throw new Error(`The font ${meta.fontFamily} does not have a style ${style2}`);
    }
    const weights = options?.weights ?? Object.keys(meta.fonts[style2]);
    for (const weight of weights) {
      if (!meta.fonts[style2][weight]) {
        throw new Error(`The font ${meta.fontFamily} does not  have a weight ${weight} in style ${style2}`);
      }
      const subsets = options?.subsets ?? Object.keys(meta.fonts[style2][weight]);
      for (const subset of subsets) {
        let font = meta.fonts[style2]?.[weight]?.[subset];
        if (!font) {
          throw new Error(`weight: ${weight} subset: ${subset} is not available for '${meta.fontFamily}'`);
        }
        let fontKey = `${meta.fontFamily}-${style2}-${weight}-${subset}`;
        const previousPromise = SpaceGrotesk_loadedFonts[fontKey];
        if (previousPromise) {
          promises.push(previousPromise);
          continue;
        }
        const baseLabel = `Fetching ${meta.fontFamily} font ${JSON.stringify({
          style: style2,
          weight,
          subset
        })}`;
        const label = weightsAndSubsetsAreSpecified ? baseLabel : `${baseLabel}. This might be caused by loading too many font variations. Read more: https://www.remotion.dev/docs/troubleshooting/font-loading-errors#render-timeout-when-loading-google-fonts`;
        const handle = (0,esm.delayRender)(label, { timeoutInMilliseconds: 60000 });
        fontsLoaded++;
        const fontFace = new FontFace(meta.fontFamily, `url(${font}) format('woff2')`, {
          weight,
          style: style2,
          unicodeRange: meta.unicodeRanges[subset]
        });
        let attempts = 2;
        const tryToLoad = () => {
          if (fontFace.status === "loaded") {
            (0,esm.continueRender)(handle);
            return;
          }
          const promise = SpaceGrotesk_loadFontFaceOrTimeoutAfter20Seconds(fontFace).then(() => {
            (options?.document ?? document).fonts.add(fontFace);
            (0,esm.continueRender)(handle);
          }).catch((err) => {
            SpaceGrotesk_loadedFonts[fontKey] = undefined;
            if (attempts === 0) {
              throw err;
            } else {
              attempts--;
              tryToLoad();
            }
          });
          SpaceGrotesk_loadedFonts[fontKey] = promise;
          promises.push(promise);
        };
        tryToLoad();
      }
    }
    if (fontsLoaded > 20) {
      console.warn(`Made ${fontsLoaded} network requests to load fonts for ${meta.fontFamily}. Consider loading fewer weights and subsets by passing options to loadFont(). Disable this warning by passing "ignoreTooManyRequestsWarning: true" to "options".`);
    }
  }
  return {
    fontFamily: meta.fontFamily,
    fonts: meta.fonts,
    unicodeRanges: meta.unicodeRanges,
    waitUntilDone: () => Promise.all(promises).then(() => {
      return;
    })
  };
};

// src/SpaceGrotesk.ts
var SpaceGrotesk_getInfo = () => ({
  fontFamily: "Space Grotesk",
  importName: "SpaceGrotesk",
  version: "v22",
  url: "https://fonts.googleapis.com/css2?family=Space+Grotesk:ital,wght@0,300;0,400;0,500;0,600;0,700",
  unicodeRanges: {
    vietnamese: "U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+0300-0301, U+0303-0304, U+0308-0309, U+0323, U+0329, U+1EA0-1EF9, U+20AB",
    "latin-ext": "U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF",
    latin: "U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD"
  },
  fonts: {
    normal: {
      "300": {
        vietnamese: "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPb54C-s0.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPb94C-s0.woff2",
        latin: "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPbF4Cw.woff2"
      },
      "400": {
        vietnamese: "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPb54C-s0.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPb94C-s0.woff2",
        latin: "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPbF4Cw.woff2"
      },
      "500": {
        vietnamese: "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPb54C-s0.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPb94C-s0.woff2",
        latin: "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPbF4Cw.woff2"
      },
      "600": {
        vietnamese: "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPb54C-s0.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPb94C-s0.woff2",
        latin: "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPbF4Cw.woff2"
      },
      "700": {
        vietnamese: "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPb54C-s0.woff2",
        "latin-ext": "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPb94C-s0.woff2",
        latin: "https://fonts.gstatic.com/s/spacegrotesk/v22/V8mDoQDjQSkFtoMM3T6r8E7mPbF4Cw.woff2"
      }
    }
  },
  subsets: ["latin", "latin-ext", "vietnamese"]
});
var SpaceGrotesk_fontFamily = "Space Grotesk";
var SpaceGrotesk_loadFont = (style, options) => {
  return SpaceGrotesk_loadFonts(SpaceGrotesk_getInfo(), style, options);
};


;// ./src/lib/fonts.ts







const { fontFamily: interFont } = loadFont();
const { fontFamily: poppinsFont } = Poppins_loadFont();
const { fontFamily: montserratFont } = Montserrat_loadFont();
const { fontFamily: playfairFont } = PlayfairDisplay_loadFont();
const { fontFamily: robotoMonoFont } = RobotoMono_loadFont();
const { fontFamily: spaceGroteskFont } = SpaceGrotesk_loadFont();
const FONT_OPTIONS = {
  Inter: interFont,
  Poppins: poppinsFont,
  Montserrat: montserratFont,
  "Playfair Display": playfairFont,
  "Roboto Mono": robotoMonoFont,
  "Space Grotesk": spaceGroteskFont
};
function getFontFamily(name) {
  return FONT_OPTIONS[name];
}

;// ./src/templates/business-marketing/AppStoreMockup.tsx








const appStoreMockupSchema = lib.z.object({
  appName: lib.z.string().default("Lapaas Video Editor"),
  developer: lib.z.string().default("Lapaas India"),
  iconUrl: lib.z.string().default("https://images.unsplash.com/photo-1611162617213-7d7a39e9b1d7?w=150"),
  rating: lib.z.number().default(4.9),
  ratingCount: lib.z.string().default("12.4K Ratings"),
  ranking: lib.z.string().default("#1 in Photo & Video"),
  age: lib.z.string().default("4+"),
  description: lib.z.string().default("The most powerful AI video editor in your pocket. Edit 10x faster with automated tools, smart captions, and premium B-roll. Download now and join 1M+ creators."),
  buttonText: lib.z.string().default("GET"),
  backgroundColor: lib.z.string().default("#000000"),
  textColor: lib.z.string().default("#ffffff"),
  accentColor: lib.z.string().default("#007aff")
  // Apple blue
});
const AppStoreMockup = ({
  appName,
  developer,
  iconUrl,
  rating,
  ratingCount,
  ranking,
  age,
  description,
  buttonText,
  accentColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const pop = (0,esm.spring)({ frame: frame - 10, fps, config: { damping: 14, mass: 1.2 } });
  const op = (0,esm.interpolate)(frame - 10, [0, 10], [0, 1], { extrapolateRight: "clamp" });
  const cardWidth = isPortrait ? width : 450 * scale;
  const cardHeight = isPortrait ? 1920 : 800 * scale;
  const bg = "#000";
  const textPrimary = "#fff";
  const textSecondary = "#8e8e93";
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground("#000000", backgroundControls), fontFamily: interFont, alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
    width: cardWidth,
    height: cardHeight,
    backgroundColor: bg,
    borderRadius: isPortrait ? 0 : 40 * scale,
    border: isPortrait ? "none" : `8px solid #1a1a1a`,
    padding: `${isPortrait ? 80 * scale : 40 * scale}px ${20 * scale}px ${20 * scale}px`,
    display: "flex",
    flexDirection: "column",
    boxShadow: isPortrait ? "none" : "0 30px 60px rgba(0,0,0,0.8)",
    transform: isPortrait ? "none" : `scale(${(0,esm.interpolate)(pop, [0, 1], [0.95, 1])}) translateY(${(1 - pop) * 40}px)`,
    opacity: isPortrait ? 1 : op,
    overflow: "hidden",
    position: "relative"
  }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", gap: 16 * scale, marginBottom: 24 * scale }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        width: 120 * scale,
        height: 120 * scale,
        borderRadius: 24 * scale,
        overflow: "hidden",
        boxShadow: "0 4px 10px rgba(0,0,0,0.3)",
        flexShrink: 0
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: iconUrl, style: { width: "100%", height: "100%", objectFit: "cover" } }) }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column", justifyContent: "center", flex: 1 }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 24 * scale, fontWeight: 700, color: textPrimary, lineHeight: 1.2, marginBottom: 4 * scale }, children: appName }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 16 * scale, color: textSecondary, marginBottom: "auto" }, children: developer }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginTop: 12 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            backgroundColor: accentColor,
            color: "#fff",
            padding: `${6 * scale}px ${24 * scale}px`,
            borderRadius: 16 * scale,
            fontSize: 15 * scale,
            fontWeight: 700,
            transform: `scale(${(0,esm.interpolate)((0,esm.spring)({ frame: frame - 30, fps, config: { damping: 10 } }), [0, 0.5, 1], [1, 1.1, 1])})`
          }, children: buttonText }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { viewBox: "0 0 24 24", width: 24 * scale, height: 24 * scale, fill: "none", stroke: accentColor, strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("circle", { cx: "18", cy: "5", r: "3" }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("circle", { cx: "6", cy: "12", r: "3" }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("circle", { cx: "18", cy: "19", r: "3" }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("line", { x1: "8.59", y1: "13.51", x2: "15.42", y2: "17.49" }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("line", { x1: "15.41", y1: "6.51", x2: "8.59", y2: "10.49" })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      display: "flex",
      alignItems: "center",
      padding: `${16 * scale}px 0`,
      borderTop: `1px solid #333`,
      borderBottom: `1px solid #333`,
      marginBottom: 24 * scale,
      overflowX: "hidden"
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column", alignItems: "center", flex: 1, borderRight: "1px solid #333" }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 12 * scale, color: textSecondary, fontWeight: 600, marginBottom: 4 * scale }, children: ratingCount }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontSize: 22 * scale, fontWeight: 700, color: textPrimary, display: "flex", alignItems: "baseline", gap: 4 * scale }, children: [
          rating,
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { display: "flex", gap: 1 * scale }, children: [1, 2, 3, 4, 5].map((star) => /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 10 * scale, height: 10 * scale, fill: textSecondary, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z" }) }, star)) })
        ] })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column", alignItems: "center", flex: 1, borderRight: "1px solid #333" }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 12 * scale, color: textSecondary, fontWeight: 600, marginBottom: 4 * scale }, children: "CHART" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 22 * scale, fontWeight: 700, color: textPrimary }, children: ranking.split(" ")[0] }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 10 * scale, color: textSecondary, marginTop: 4 * scale }, children: ranking.split(" ").slice(1).join(" ") })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column", alignItems: "center", flex: 1 }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 12 * scale, color: textSecondary, fontWeight: 600, marginBottom: 4 * scale }, children: "AGE" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 22 * scale, fontWeight: 700, color: textPrimary }, children: age }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 10 * scale, color: textSecondary, marginTop: 4 * scale }, children: "Years Old" })
      ] })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { marginBottom: 24 * scale }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "baseline", marginBottom: 12 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 22 * scale, fontWeight: 700, color: textPrimary }, children: "What's New" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 16 * scale, color: accentColor }, children: "Version History" })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "baseline", marginBottom: 12 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 15 * scale, color: textSecondary }, children: "Version 2.4.1" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 15 * scale, color: textSecondary }, children: "2d ago" })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontSize: 15 * scale, color: textPrimary, lineHeight: 1.4 }, children: [
        "- Added AI Auto-B-roll feature.",
        /* @__PURE__ */ (0,jsx_runtime.jsx)("br", {}),
        "- Performance improvements and bug fixes."
      ] })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 16 * scale, color: textPrimary, lineHeight: 1.5 }, children: description }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { color: accentColor, fontSize: 16 * scale, marginTop: 4 * scale, textAlign: "right" }, children: "more" })
    ] })
  ] }) });
};
registerTemplate({
  tags: [],
  id: "app-store-mockup-01",
  name: "App Store Profile Mockup",
  description: "A realistic iOS App Store page simulation, great for app marketing videos.",
  category: "platform-mockups",
  durationInFrames: 150,
  fps: 30,
  component: AppStoreMockup,
  schema: appStoreMockupSchema,
  defaultProps: appStoreMockupSchema.parse({})
});

;// ./src/components/EditableText.tsx


const EditableText = ({
  text,
  fontSize = 48,
  fontFamily = "Inter, sans-serif",
  color = "#ffffff",
  fontWeight = 700,
  fontStyle = "normal",
  textAlign = "left",
  lineHeight = 1.2,
  letterSpacing = -0.5,
  textTransform = "none",
  maxLines,
  style = {}
}) => {
  const clampStyle = maxLines ? {
    display: "-webkit-box",
    WebkitLineClamp: maxLines,
    WebkitBoxOrient: "vertical",
    overflow: "hidden"
  } : {};
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(
    "div",
    {
      style: {
        fontSize,
        fontFamily,
        color,
        fontWeight,
        fontStyle,
        textAlign,
        lineHeight,
        letterSpacing,
        textTransform,
        ...clampStyle,
        ...style
      },
      children: text
    }
  );
};

;// ./src/lib/theme.ts

const COLORS = {
  // Backgrounds
  bg: "var(--template-bg, #0F0F0F)",
  bgAlt: "var(--template-bg-alt, #121212)",
  surface: "#1A1A1A",
  surfaceLight: "#242424",
  card: "#1E1E1E",
  cardHover: "#2A2A2A",
  // Green accent (Material Green A400 family)
  accent: "#00E676",
  accentDark: "#00C853",
  accentLight: "#69F0AE",
  accentMuted: "rgba(0, 230, 118, 0.15)",
  accentBorder: "rgba(0, 230, 118, 0.3)",
  // Text
  textPrimary: "#FFFFFF",
  textSecondary: "rgba(255, 255, 255, 0.70)",
  textMuted: "rgba(255, 255, 255, 0.45)",
  textOnAccent: "#0F0F0F",
  // Utility
  border: "rgba(255, 255, 255, 0.08)",
  borderLight: "rgba(255, 255, 255, 0.12)",
  overlay: "rgba(0, 0, 0, 0.6)",
  overlayHeavy: "rgba(0, 0, 0, 0.85)",
  glow: "rgba(0, 230, 118, 0.25)",
  glowStrong: "rgba(0, 230, 118, 0.45)"
};
const FONT = {
  // Size scale
  hero: 160,
  // Main hero headline
  h1: 120,
  // Section headline
  h2: 96,
  // Large subheadline
  h3: 72,
  // Medium heading
  h4: 56,
  // Small heading
  body: 48,
  // Body / paragraph
  bodySmall: 40,
  // Smaller body
  label: 36,
  // Labels, badges
  caption: 28,
  // Captions, timestamps
  micro: 24,
  // Tiny text
  // Weights
  black: 900,
  bold: 700,
  semibold: 600,
  medium: 500,
  regular: 400,
  // Line heights
  tight: 1.1,
  normal: 1.3,
  relaxed: 1.5,
  // Letter spacing
  wide: 4,
  normal_ls: 0,
  tight_ls: -1,
  tighter: -2
};
const PORTRAIT_SCALE = 1.05;
function pSize(landscapeSize, isPortrait) {
  return isPortrait ? Math.round(landscapeSize * PORTRAIT_SCALE) : landscapeSize;
}
const SPACING = {
  xs: 16,
  sm: 24,
  md: 40,
  lg: 64,
  xl: 96,
  xxl: 160,
  page: 120,
  // Page padding landscape
  pagePt: 80
  // Page padding portrait (sides)
};
function pGap(landscapeGap, isPortrait) {
  return isPortrait ? Math.round(landscapeGap * 2.5) : landscapeGap;
}
function pPad(isPortrait) {
  return isPortrait ? `${SPACING.xxl}px ${SPACING.pagePt}px` : `${SPACING.xl}px ${SPACING.page}px`;
}
const RADIUS = {
  sm: 8,
  md: 16,
  lg: 24,
  xl: 40,
  pill: 100
};
const GRADIENTS = {
  bgMain: `linear-gradient(135deg, ${COLORS.bg} 0%, var(--template-bg-mid, #0a1a0f) 50%, ${COLORS.bg} 100%)`,
  bgSubtle: `linear-gradient(180deg, ${COLORS.bgAlt} 0%, ${COLORS.bg} 100%)`,
  accentLine: `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})`,
  accentFade: `linear-gradient(90deg, ${COLORS.accent}, transparent)`,
  overlayBottom: `linear-gradient(180deg, transparent 0%, ${COLORS.bg} 100%)`,
  overlayTop: `linear-gradient(0deg, transparent 0%, ${COLORS.bg} 100%)`,
  cardGlow: `linear-gradient(135deg, ${COLORS.surfaceLight}, ${COLORS.card})`
};

;// ./src/templates/business-marketing/BeforeAfterSplit.tsx










const beforeAfterSplitSchema = lib.z.object({
  title: lib.z.string().default("The Transformation"),
  beforeLabel: lib.z.string().default("Before"),
  afterLabel: lib.z.string().default("After"),
  beforeItems: lib.z.array(lib.z.string()).default([
    "Manual data entry",
    "Siloed communication",
    "Unpredictable revenue",
    "High churn rate"
  ]),
  afterItems: lib.z.array(lib.z.string()).default([
    "Automated workflows",
    "Unified team inbox",
    "Predictable MRR",
    "95% retention rate"
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  beforeColor: lib.z.string().default("#ef4444"),
  afterColor: lib.z.string().default("#10b981")
});
const BeforeAfterSplit = ({
  title,
  beforeLabel,
  afterLabel,
  beforeItems,
  afterItems,
  backgroundColor,
  textColor,
  beforeColor,
  afterColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const sliderProgress = (0,esm.spring)({ frame: frame - 40, fps, config: { damping: 16, mass: 1.5 } });
  const splitPercent = (0,esm.interpolate)(sliderProgress, [0, 1], [95, 50], { extrapolateRight: "clamp" });
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  const flexDirection = isPortrait ? "column" : "row";
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity,
      zIndex: 10
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em",
          color: textColor
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 250 * scale : 200 * scale,
      left: paddingX,
      width: availableWidth,
      height: isPortrait ? height * 0.6 : height * 0.65,
      borderRadius: 24 * scale,
      overflow: "hidden",
      display: "flex",
      flexDirection,
      boxShadow: "0 20px 50px rgba(0,0,0,0.3)",
      border: "2px solid rgba(255,255,255,0.1)"
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        [isPortrait ? "height" : "width"]: `${splitPercent}%`,
        [isPortrait ? "width" : "height"]: "100%",
        backgroundColor: "rgba(239, 68, 68, 0.1)",
        position: "relative",
        borderRight: isPortrait ? "none" : `4px solid ${textColor}`,
        borderBottom: isPortrait ? `4px solid ${textColor}` : "none",
        display: "flex",
        flexDirection: "column",
        padding: 40 * scale,
        overflow: "hidden"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: 32 * scale,
          fontWeight: 800,
          color: beforeColor,
          fontFamily: interFont,
          marginBottom: 30 * scale,
          textTransform: "uppercase",
          letterSpacing: "0.1em"
        }, children: beforeLabel }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: 20 * scale }, children: beforeItems.map((item, i) => /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 16 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { color: beforeColor, fontSize: 24 * scale }, children: "\u2716" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 24 * scale, color: "rgba(255,255,255,0.8)" }, children: item })
        ] }, i)) })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        [isPortrait ? "height" : "width"]: `${100 - splitPercent}%`,
        [isPortrait ? "width" : "height"]: "100%",
        backgroundColor: "rgba(16, 185, 129, 0.1)",
        position: "relative",
        display: "flex",
        flexDirection: "column",
        padding: 40 * scale,
        overflow: "hidden"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: 32 * scale,
          fontWeight: 800,
          color: afterColor,
          fontFamily: interFont,
          marginBottom: 30 * scale,
          textTransform: "uppercase",
          letterSpacing: "0.1em"
        }, children: afterLabel }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: 20 * scale }, children: afterItems.map((item, i) => /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          display: "flex",
          alignItems: "center",
          gap: 16 * scale,
          opacity: (0,esm.interpolate)(sliderProgress, [0.5, 1], [0, 1], { extrapolateRight: "clamp" }),
          transform: `translateX(${(1 - sliderProgress) * 50}px)`
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { color: afterColor, fontSize: 24 * scale }, children: "\u2714" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 24 * scale, color: "#fff", fontWeight: 600 }, children: item })
        ] }, i)) })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        [isPortrait ? "top" : "left"]: `${splitPercent}%`,
        [isPortrait ? "left" : "top"]: "50%",
        transform: "translate(-50%, -50%)",
        width: 60 * scale,
        height: 60 * scale,
        backgroundColor: textColor,
        borderRadius: "50%",
        boxShadow: "0 4px 10px rgba(0,0,0,0.5)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        color: "#000",
        zIndex: 20
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: 32 * scale, height: 32 * scale, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round", children: isPortrait ? /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "18 15 12 21 6 15" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "6 9 12 3 18 9" })
      ] }) : /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "15 18 21 12 15 6" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "9 6 3 12 9 18" })
      ] }) }) })
    ] })
  ] });
};
registerTemplate({
  tags: [],
  id: "before-after-split-01",
  name: "Before & After Slider",
  description: "A dynamic split-screen slider comparing pain points to solutions.",
  category: "business-marketing",
  durationInFrames: 180,
  fps: 30,
  component: BeforeAfterSplit,
  schema: beforeAfterSplitSchema,
  defaultProps: beforeAfterSplitSchema.parse({})
});

;// ./src/templates/business-marketing/BenefitCheckmarks.tsx










const benefitCheckmarksSchema = lib.z.object({
  title: lib.z.string().default("What You Get"),
  benefits: lib.z.array(lib.z.string()).default([
    "Full access to all AI tools",
    "Unlimited HD video exports",
    "Priority 24/7 customer support",
    "Custom brand kits & fonts",
    "Team collaboration workspace",
    "1TB cloud storage included"
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  primaryColor: lib.z.string().default("#22c55e")
});
const BenefitCheckmarks = ({
  title,
  benefits,
  backgroundColor,
  textColor,
  primaryColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalBenefits = benefits.length;
  const cols = isPortrait ? 1 : totalBenefits > 5 ? 2 : 1;
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 150 * scale : 120 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: cols > 1 ? "center" : "left",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 64 : 80) * scale,
            margin: 0,
            letterSpacing: "-0.02em",
            color: textColor
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        width: 100 * scale,
        height: 8 * scale,
        backgroundColor: primaryColor,
        marginTop: 20 * scale,
        borderRadius: 4 * scale,
        margin: cols > 1 ? "20px auto 0" : "20px 0 0"
      } })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 300 * scale : 280 * scale,
      left: paddingX,
      width: availableWidth,
      display: "grid",
      gridTemplateColumns: `repeat(${cols}, 1fr)`,
      columnGap: 80 * scale,
      rowGap: isPortrait ? 40 * scale : 30 * scale
    }, children: benefits.map((benefit, i) => {
      const delay = 15 + i * 8;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 12, mass: 0.8 } });
      const xOffset = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        display: "flex",
        alignItems: "center",
        gap: 24 * scale,
        opacity: op,
        transform: `translateX(${(1 - xOffset) * -40}px)`
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          width: 48 * scale,
          height: 48 * scale,
          borderRadius: "50%",
          backgroundColor: `${primaryColor}20`,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          transform: `scale(${pop})`,
          boxShadow: `0 0 20px ${primaryColor}40`,
          flexShrink: 0
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: 28 * scale, height: 28 * scale, viewBox: "0 0 24 24", fill: "none", stroke: primaryColor, strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "20 6 9 17 4 12" }) }) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: (isPortrait ? 28 : 32) * scale,
          fontWeight: 600,
          color: COLORS.textPrimary,
          lineHeight: 1.3
        }, children: benefit })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "benefit-checkmarks-01",
  name: "Rapid Fire Checkmarks",
  description: "A punchy, fast-animating list of checkmarks detailing benefits. Auto-splits into columns if list is long.",
  category: "business-marketing",
  durationInFrames: 150,
  fps: 30,
  component: BenefitCheckmarks,
  schema: benefitCheckmarksSchema,
  defaultProps: benefitCheckmarksSchema.parse({})
});

;// ./src/templates/business-marketing/CaseStudyCards.tsx










const caseStudyCardSchema = lib.z.object({
  title: lib.z.string().default("Case Studies"),
  studies: lib.z.array(lib.z.object({
    company: lib.z.string(),
    logoUrl: lib.z.string(),
    metric: lib.z.string(),
    detail: lib.z.string(),
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    {
      company: "Acme Corp",
      logoUrl: "https://upload.wikimedia.org/wikipedia/commons/a/a9/Amazon_logo.svg",
      metric: "+250%",
      detail: "Increase in organic traffic in 6 months",
      color: "#f59e0b"
    },
    {
      company: "Globex",
      logoUrl: "https://upload.wikimedia.org/wikipedia/commons/e/e8/Tesla_logo.png",
      metric: "10x",
      detail: "Faster deployment cycle times",
      color: "#ef4444"
    },
    {
      company: "Soylent",
      logoUrl: "https://upload.wikimedia.org/wikipedia/commons/0/08/Netflix_2015_logo.svg",
      metric: "-40%",
      detail: "Reduction in customer churn rate",
      color: "#eab308"
    }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  cardBgColor: lib.z.string().default(COLORS.surface)
});
const CaseStudyCards = ({
  title,
  studies,
  backgroundColor,
  textColor,
  cardBgColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalStudies = studies.length;
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  const gap = 30 * scale;
  const itemWidth = isPortrait ? availableWidth : (availableWidth - gap * (totalStudies - 1)) / totalStudies;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 120 * scale : 100 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em",
          color: textColor
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 250 * scale : 250 * scale,
      left: paddingX,
      width: availableWidth,
      display: "flex",
      flexDirection: isPortrait ? "column" : "row",
      justifyContent: "center",
      alignItems: isPortrait ? "center" : "stretch",
      gap
    }, children: studies.map((study, i) => {
      const delay = 20 + i * 15;
      const flip = (0,esm.interpolate)((0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14, mass: 1.5 } }), [0, 1], [90, 0]);
      const op = (0,esm.interpolate)(frame - delay, [0, 5], [0, 1], { extrapolateRight: "clamp" });
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        width: isPortrait ? "100%" : itemWidth,
        backgroundColor: cardBgColor,
        borderRadius: 24 * scale,
        padding: isPortrait ? 30 * scale : 40 * scale,
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        textAlign: "center",
        transform: `perspective(1000px) rotateY(${flip}deg)`,
        transformOrigin: "center center",
        opacity: op,
        boxShadow: "0 20px 50px rgba(0,0,0,0.3)",
        borderTop: `4px solid ${study.color}`,
        position: "relative"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          width: 120 * scale,
          height: 60 * scale,
          marginBottom: 30 * scale,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: 0.8
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: study.logoUrl, style: { maxWidth: "100%", maxHeight: "100%", objectFit: "contain" } }) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: (isPortrait ? 64 : 80) * scale,
          fontWeight: 900,
          fontFamily: interFont,
          color: study.color,
          marginBottom: 16 * scale,
          textShadow: `0 4px 10px ${study.color}40`,
          lineHeight: 1
        }, children: study.metric }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: 20 * scale,
          fontWeight: 500,
          color: COLORS.textPrimary,
          lineHeight: 1.4
        }, children: study.detail })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "case-study-cards-01",
  name: "Dynamic Case Study Cards",
  description: "Flipping 3D cards that display impressive case study metrics for clients.",
  category: "business-marketing",
  durationInFrames: 180,
  fps: 30,
  component: CaseStudyCards,
  schema: caseStudyCardSchema,
  defaultProps: caseStudyCardSchema.parse({})
});

;// ./src/templates/business-marketing/ClientLogoGrid.tsx









const clientLogoGridSchema = lib.z.object({
  title: lib.z.string().default("Trusted By Industry Leaders"),
  logos: lib.z.array(lib.z.string()).default([
    "https://upload.wikimedia.org/wikipedia/commons/a/a9/Amazon_logo.svg",
    "https://upload.wikimedia.org/wikipedia/commons/2/2f/Google_2015_logo.svg",
    "https://upload.wikimedia.org/wikipedia/commons/e/e8/Tesla_logo.png",
    "https://upload.wikimedia.org/wikipedia/commons/0/08/Netflix_2015_logo.svg",
    "https://upload.wikimedia.org/wikipedia/commons/f/fa/Apple_logo_black.svg",
    "https://upload.wikimedia.org/wikipedia/commons/4/44/Microsoft_logo.svg"
  ]),
  backgroundColor: lib.z.string().default("#ffffff"),
  textColor: lib.z.string().default("#0f172a"),
  logoBgColor: lib.z.string().default("#f8fafc")
});
const ClientLogoGrid = ({
  title,
  logos,
  backgroundColor,
  textColor,
  logoBgColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalLogos = logos.length;
  const cols = isPortrait ? 2 : Math.min(4, Math.ceil(Math.sqrt(totalLogos)));
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const gap = 30 * scale;
  const availableWidth = width - paddingX * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 150 * scale : 120 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: montserratFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      display: "grid",
      gridTemplateColumns: `repeat(${cols}, 1fr)`,
      gap,
      width: availableWidth,
      maxWidth: 1200 * scale
    }, children: logos.map((logoUrl, i) => {
      const delay = 15 + i * 5;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 12, mass: 1.2 } });
      return /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        backgroundColor: logoBgColor,
        borderRadius: 20 * scale,
        padding: 40 * scale,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        aspectRatio: "16/9",
        transform: `scale(${pop})`,
        opacity: (0,esm.interpolate)(frame - delay, [0, 5], [0, 1], { extrapolateRight: "clamp" }),
        boxShadow: "0 10px 30px rgba(0,0,0,0.05)",
        border: "1px solid rgba(0,0,0,0.05)"
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
        esm.Img,
        {
          src: logoUrl,
          style: {
            maxWidth: "100%",
            maxHeight: "100%",
            objectFit: "contain"
            // Convert to grayscale if it's a colorful logo for a cleaner B2B look
            // filter: 'grayscale(100%) opacity(0.7)',
          }
        }
      ) }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "client-logo-grid-01",
  name: "Dynamic Client Logo Grid",
  description: "A responsive grid of partner/client logos that stagger animate in. Auto-adjusts columns.",
  category: "business-marketing",
  durationInFrames: 120,
  fps: 30,
  component: ClientLogoGrid,
  schema: clientLogoGridSchema,
  defaultProps: clientLogoGridSchema.parse({})
});

;// ./src/templates/business-marketing/ContactInfoCard.tsx










const contactInfoCardSchema = lib.z.object({
  title: lib.z.string().default("Let's Talk"),
  subtitle: lib.z.string().default("Ready to scale your business?"),
  contacts: lib.z.array(lib.z.object({
    type: lib.z.string(),
    value: lib.z.string(),
    icon: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { type: "Email", value: "hello@lapaas.com", icon: "\u2709\uFE0F" },
    { type: "Phone", value: "+91 98765 43210", icon: "\u{1F4DE}" },
    { type: "Address", value: "New Delhi, India", icon: "\u{1F4CD}" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  cardBgColor: lib.z.string().default(COLORS.surface),
  accentColor: lib.z.string().default(COLORS.accent)
});
const ContactInfoCard = ({
  title,
  subtitle,
  contacts,
  backgroundColor,
  textColor,
  cardBgColor,
  accentColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const cardWidth = isPortrait ? width - paddingX * 2 : 800 * scale;
  const cardPop = (0,esm.spring)({ frame: frame - 15, fps, config: { damping: 14, mass: 1.2 } });
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor, justifyContent: "center", alignItems: "center" }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 150 * scale : 150 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 900,
            fontSize: (isPortrait ? 80 : 96) * scale,
            margin: 0,
            letterSpacing: "-0.03em"
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 32 : 40) * scale,
            opacity: 0.6,
            marginTop: 10 * scale
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      width: cardWidth,
      backgroundColor: cardBgColor,
      borderRadius: 32 * scale,
      padding: isPortrait ? 60 * scale : 80 * scale,
      transform: `scale(${(0,esm.interpolate)(cardPop, [0, 1], [0.9, 1])}) translateY(${(1 - cardPop) * 50}px)`,
      opacity: (0,esm.interpolate)(cardPop, [0, 1], [0, 1]),
      boxShadow: "0 30px 60px rgba(0,0,0,0.3)",
      borderTop: `6px solid ${accentColor}`,
      display: "flex",
      flexDirection: "column",
      gap: 40 * scale,
      position: "relative",
      overflow: "hidden",
      marginTop: isPortrait ? 100 * scale : 150 * scale
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: -50 * scale,
        right: -50 * scale,
        width: 200 * scale,
        height: 200 * scale,
        backgroundColor: accentColor,
        filter: `blur(${80 * scale}px)`,
        opacity: 0.2,
        zIndex: 0
      } }),
      contacts.map((contact, i) => {
        const delay = 30 + i * 10;
        const itemPop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 12 } });
        const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
        return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          display: "flex",
          alignItems: "center",
          gap: 30 * scale,
          transform: `translateX(${(1 - itemPop) * -30}px)`,
          opacity: op,
          zIndex: 1
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            width: 80 * scale,
            height: 80 * scale,
            borderRadius: "50%",
            backgroundColor: `${accentColor}20`,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            fontSize: 40 * scale,
            color: accentColor,
            flexShrink: 0,
            border: `2px solid ${accentColor}40`
          }, children: contact.icon }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column", gap: 8 * scale }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
              fontSize: 20 * scale,
              fontWeight: 600,
              color: COLORS.textMuted,
              textTransform: "uppercase",
              letterSpacing: "0.1em"
            }, children: contact.type }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
              fontSize: (isPortrait ? 32 : 40) * scale,
              fontWeight: 800,
              fontFamily: interFont,
              color: "#fff",
              letterSpacing: "0.02em"
            }, children: contact.value })
          ] })
        ] }, i);
      })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      bottom: 80 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      opacity: (0,esm.interpolate)(frame - 100, [0, 20], [0, 1], { extrapolateRight: "clamp" }),
      fontSize: 24 * scale,
      fontWeight: 700,
      color: accentColor,
      letterSpacing: "0.2em",
      textTransform: "uppercase"
    }, children: "www.lapaas.com" })
  ] });
};
registerTemplate({
  tags: [],
  id: "contact-info-card-01",
  name: "Contact Information Card",
  description: "A polished, modern contact card that sequentially reveals contact methods.",
  category: "social-hooks",
  durationInFrames: 180,
  fps: 30,
  component: ContactInfoCard,
  schema: contactInfoCardSchema,
  defaultProps: contactInfoCardSchema.parse({})
});

;// ./src/templates/business-marketing/CustomerJourneyPath.tsx










const customerJourneySchema = lib.z.object({
  title: lib.z.string().default("Customer Journey Map"),
  touchpoints: lib.z.array(lib.z.object({
    title: lib.z.string(),
    subtitle: lib.z.string(),
    icon: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { title: "Discovery", subtitle: "Sees an ad on Instagram", icon: "\u{1F4F1}" },
    { title: "Consideration", subtitle: "Reads a blog post", icon: "\u{1F4D6}" },
    { title: "Evaluation", subtitle: "Compares pricing", icon: "\u2696\uFE0F" },
    { title: "Purchase", subtitle: "Signs up for Pro plan", icon: "\u{1F4B3}" },
    { title: "Retention", subtitle: "Renews subscription", icon: "\u{1F504}" }
  ]),
  backgroundColor: lib.z.string().default("#f8fafc"),
  textColor: lib.z.string().default("#0f172a"),
  lineColor: lib.z.string().default("#cbd5e1"),
  accentColor: lib.z.string().default(COLORS.accent)
});
const CustomerJourneyPath = ({
  title,
  touchpoints,
  backgroundColor,
  textColor,
  lineColor,
  accentColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalPoints = touchpoints.length;
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const startY = isPortrait ? height * 0.25 : height * 0.3;
  const endY = height * 0.85;
  const pathHeight = endY - startY;
  const spacingY = pathHeight / Math.max(1, totalPoints - 1);
  const pathDrawProgress = (0,esm.spring)({ frame: frame - 20, fps, config: { damping: 20, mass: 2 } });
  const currentPathLength = pathDrawProgress * pathHeight;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), padding: 60 * scale, fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: startY,
      left: isPortrait ? paddingX : "50%",
      width: 8 * scale,
      height: pathHeight,
      backgroundColor: lineColor,
      borderRadius: 4 * scale,
      transform: "translateX(-50%)"
    } }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: startY,
      left: isPortrait ? paddingX : "50%",
      width: 8 * scale,
      height: currentPathLength,
      backgroundColor: accentColor,
      borderRadius: 4 * scale,
      transform: "translateX(-50%)",
      boxShadow: `0 0 20px ${accentColor}`
    } }),
    touchpoints.map((point, i) => {
      const pointY = startY + i * spacingY;
      const isLeft = i % 2 === 0;
      const reachTime = 20 + i / Math.max(1, totalPoints - 1) * 30;
      const pop = (0,esm.spring)({ frame: frame - reachTime, fps, config: { damping: 10 } });
      const opacity = (0,esm.interpolate)(frame - reachTime, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      const dotSize = 40 * scale;
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        position: "absolute",
        top: pointY,
        left: isPortrait ? paddingX : "50%",
        transform: "translate(-50%, -50%)"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          width: dotSize,
          height: dotSize,
          backgroundColor: frame >= reachTime ? accentColor : backgroundColor,
          border: `${4 * scale}px solid ${frame >= reachTime ? accentColor : lineColor}`,
          borderRadius: "50%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          fontSize: 20 * scale,
          transform: `scale(${pop})`,
          zIndex: 10,
          position: "relative",
          boxShadow: frame >= reachTime ? `0 0 20px ${accentColor}` : "none",
          transition: "all 0.2s"
        }, children: frame >= reachTime && /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { position: "absolute", transform: `scale(${(0,esm.interpolate)(pop, [0, 1], [0.5, 1])})` }, children: point.icon }) }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          position: "absolute",
          top: "50%",
          left: isPortrait ? dotSize : isLeft ? -(dotSize + 400 * scale) : dotSize,
          transform: `translateY(-50%) translateX(${(1 - pop) * (isLeft && !isPortrait ? 20 : -20)}px)`,
          opacity,
          width: isPortrait ? width - paddingX * 2.5 : 350 * scale,
          backgroundColor: "#ffffff",
          padding: 20 * scale,
          borderRadius: 16 * scale,
          boxShadow: "0 10px 30px rgba(0,0,0,0.05)",
          border: `1px solid ${lineColor}`,
          display: "flex",
          flexDirection: "column",
          gap: 8 * scale,
          textAlign: isLeft && !isPortrait ? "right" : "left"
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 24 * scale,
            fontWeight: 800,
            color: textColor,
            fontFamily: interFont
          }, children: point.title }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 18 * scale,
            color: "#64748b",
            lineHeight: 1.4
          }, children: point.subtitle })
        ] })
      ] }, i);
    })
  ] });
};
registerTemplate({
  tags: [],
  id: "customer-journey-path-01",
  name: "Customer Journey Path",
  description: "A step-by-step roadmap animation that dynamically draws a path through N touchpoints.",
  category: "business-marketing",
  durationInFrames: 180,
  fps: 30,
  component: CustomerJourneyPath,
  schema: customerJourneySchema,
  defaultProps: customerJourneySchema.parse({})
});

;// ./src/templates/business-marketing/DynamicBarChart.tsx










const dynamicBarChartSchema = lib.z.object({
  title: lib.z.string().default("Revenue Growth"),
  subtitle: lib.z.string().default("Year over Year ($M)"),
  dataPoints: lib.z.array(lib.z.object({
    label: lib.z.string(),
    value: lib.z.number(),
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { label: "2020", value: 2.4, color: "#3b82f6" },
    { label: "2021", value: 4.8, color: "#6366f1" },
    { label: "2022", value: 9.6, color: "#8b5cf6" },
    { label: "2023", value: 18.2, color: "#a855f7" },
    { label: "2024", value: 34.5, color: "#d946ef" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  axisColor: lib.z.string().default("rgba(255,255,255,0.2)")
});
const DynamicBarChart = ({
  title,
  subtitle,
  dataPoints,
  backgroundColor,
  textColor,
  axisColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalBars = dataPoints.length;
  const maxValue = Math.max(...dataPoints.map((d) => d.value));
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const paddingY = 150 * scale;
  const availableWidth = width - paddingX * 2;
  const chartHeight = height - paddingY * 2 - (isPortrait ? 200 * scale : 150 * scale);
  const barSpacing = isPortrait ? 20 * scale : 40 * scale;
  const barWidth = (availableWidth - barSpacing * (totalBars - 1)) / totalBars;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 60 : 72) * scale,
            margin: 0,
            letterSpacing: "-0.02em"
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 24 : 32) * scale,
            opacity: 0.6,
            marginTop: 10 * scale
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      bottom: paddingY,
      left: paddingX,
      width: availableWidth,
      height: chartHeight,
      borderBottom: `2px solid ${axisColor}`,
      borderLeft: `2px solid ${axisColor}`,
      display: "flex",
      alignItems: "flex-end",
      gap: barSpacing
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: -10 * scale,
        left: -40 * scale,
        fontSize: 16 * scale,
        color: COLORS.textMuted
      }, children: Math.ceil(maxValue) }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: chartHeight / 2 - 10 * scale,
        left: -40 * scale,
        fontSize: 16 * scale,
        color: COLORS.textMuted
      }, children: Math.ceil(maxValue / 2) }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        bottom: 10 * scale,
        left: -40 * scale,
        fontSize: 16 * scale,
        color: COLORS.textMuted
      }, children: "0" }),
      dataPoints.map((point, i) => {
        const targetHeight = point.value / maxValue * chartHeight;
        const delay = 30 + i * 10;
        const grow = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14, mass: 1.5 } });
        const currentHeight = grow * targetHeight;
        return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          width: barWidth,
          height: Math.max(0, currentHeight),
          // prevent negative height on bounce back
          backgroundColor: point.color,
          borderTopLeftRadius: 12 * scale,
          borderTopRightRadius: 12 * scale,
          position: "relative",
          boxShadow: `0 -10px 30px ${point.color}40`
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: `linear-gradient(180deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 100%)`,
            borderTopLeftRadius: 12 * scale,
            borderTopRightRadius: 12 * scale
          } }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            position: "absolute",
            top: -40 * scale,
            width: "100%",
            textAlign: "center",
            fontSize: 24 * scale,
            fontWeight: 800,
            fontFamily: interFont,
            opacity: grow,
            // fade in as it grows
            color: "#fff"
          }, children: point.value }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            position: "absolute",
            bottom: -40 * scale,
            width: "100%",
            textAlign: "center",
            fontSize: 18 * scale,
            fontWeight: 600,
            color: COLORS.textSecondary
          }, children: point.label })
        ] }, i);
      })
    ] })
  ] });
};
registerTemplate({
  tags: [],
  id: "dynamic-bar-chart-01",
  name: "Dynamic Bar Chart",
  description: "A data visualization chart that auto-scales the Y-axis and animates bars upwards sequentially.",
  category: "data-visualization",
  durationInFrames: 180,
  fps: 30,
  component: DynamicBarChart,
  schema: dynamicBarChartSchema,
  defaultProps: dynamicBarChartSchema.parse({})
});

;// ./src/templates/business-marketing/DynamicDonutChart.tsx










const dynamicDonutChartSchema = lib.z.object({
  title: lib.z.string().default("Revenue by Channel"),
  subtitle: lib.z.string().default("Q3 2024 Distribution"),
  segments: lib.z.array(lib.z.object({
    label: lib.z.string(),
    value: lib.z.number(),
    // will be converted to percentage
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { label: "Organic Search", value: 45, color: "#3b82f6" },
    { label: "Paid Ads", value: 25, color: "#f43f5e" },
    { label: "Direct", value: 20, color: "#10b981" },
    { label: "Referral", value: 10, color: "#eab308" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  centerText: lib.z.string().default("$12.4M")
});
const DynamicDonutChart = ({
  title,
  subtitle,
  segments,
  backgroundColor,
  textColor,
  centerText
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalValue = segments.reduce((sum, seg) => sum + seg.value, 0);
  const drawProgress = (0,esm.spring)({ frame: frame - 20, fps, config: { damping: 20, mass: 1.5 } });
  const currentTotalAngle = drawProgress * 360;
  const radius = isPortrait ? width * 0.35 : height * 0.35;
  const thickness = radius * 0.3;
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: isPortrait ? "center" : "left",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 60 : 72) * scale,
            margin: 0,
            letterSpacing: "-0.02em"
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 24 : 32) * scale,
            opacity: 0.6,
            marginTop: 10 * scale
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: "50%",
      left: isPortrait ? "50%" : paddingX + radius,
      transform: "translate(-50%, -50%)",
      width: radius * 2,
      height: radius * 2
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: "100%", height: "100%", viewBox: "-100 -100 200 200", style: { transform: "rotate(-90deg)" }, children: (() => {
        let accumulatedAngle = 0;
        return segments.map((seg, i) => {
          const segAngle = seg.value / totalValue * 360;
          const angleToDraw = Math.max(0, Math.min(segAngle, currentTotalAngle - accumulatedAngle));
          const r = 100 - thickness / scale / 2;
          const circumference = 2 * Math.PI * r;
          const strokeDasharray = `${angleToDraw / 360 * circumference} ${circumference}`;
          const strokeDashoffset = -(accumulatedAngle / 360) * circumference;
          accumulatedAngle += segAngle;
          return /* @__PURE__ */ (0,jsx_runtime.jsx)(
            "circle",
            {
              r,
              cx: "0",
              cy: "0",
              fill: "transparent",
              stroke: seg.color,
              strokeWidth: thickness / scale,
              strokeDasharray,
              strokeDashoffset,
              strokeLinecap: "butt"
            },
            i
          );
        });
      })() }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        textAlign: "center",
        opacity: (0,esm.interpolate)(drawProgress, [0.5, 1], [0, 1], { extrapolateRight: "clamp" })
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        fontSize: 48 * scale,
        fontWeight: 900,
        fontFamily: interFont,
        color: textColor
      }, children: centerText }) })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? height * 0.8 : "50%",
      left: isPortrait ? paddingX : paddingX + radius * 2 + 80 * scale,
      transform: isPortrait ? "none" : "translateY(-50%)",
      width: isPortrait ? availableWidth : availableWidth - radius * 2 - 80 * scale,
      display: "flex",
      flexDirection: "column",
      gap: 24 * scale
    }, children: segments.map((seg, i) => {
      const delay = 40 + i * 8;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
      const percentage = Math.round(seg.value / totalValue * 100);
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        transform: `translateX(${(1 - pop) * 40}px)`,
        opacity: pop,
        backgroundColor: COLORS.surfaceLight,
        padding: `${16 * scale}px ${24 * scale}px`,
        borderRadius: 16 * scale,
        borderLeft: `6px solid ${seg.color}`
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 16 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
            fontSize: 24 * scale,
            fontWeight: 700,
            fontFamily: interFont,
            width: 60 * scale
          }, children: [
            percentage,
            "%"
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 20 * scale, color: "rgba(255,255,255,0.8)" }, children: seg.label })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 24 * scale, fontWeight: 700 }, children: seg.value })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "dynamic-donut-chart-01",
  name: "Dynamic Donut Chart",
  description: "An animated donut chart that smoothly draws its segments and displays a clean legend.",
  category: "data-visualization",
  durationInFrames: 180,
  fps: 30,
  component: DynamicDonutChart,
  schema: dynamicDonutChartSchema,
  defaultProps: dynamicDonutChartSchema.parse({})
});

;// ./src/templates/business-marketing/DynamicSalesFunnel.tsx










const dynamicSalesFunnelSchema = lib.z.object({
  title: lib.z.string().default("Sales Funnel Breakdown"),
  subtitle: lib.z.string().default("How we convert cold traffic into loyal customers"),
  stages: lib.z.array(lib.z.object({
    label: lib.z.string(),
    value: lib.z.string(),
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { label: "Awareness", value: "100k", color: "#3b82f6" },
    { label: "Interest", value: "25k", color: "#8b5cf6" },
    { label: "Decision", value: "5k", color: "#a855f7" },
    { label: "Action", value: "1k", color: "#d946ef" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary)
});
const DynamicSalesFunnel = ({
  title,
  subtitle,
  stages,
  backgroundColor,
  textColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalStages = stages.length;
  const maxTopWidth = isPortrait ? width * 0.8 : width * 0.5;
  const minBottomWidth = isPortrait ? width * 0.3 : width * 0.15;
  const funnelHeight = isPortrait ? height * 0.5 : height * 0.6;
  const stageHeight = funnelHeight / totalStages;
  const gap = 10 * scale;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), padding: 60 * scale, fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -50}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 60 : 72) * scale,
            margin: 0,
            letterSpacing: "-0.02em"
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 30 : 36) * scale,
            opacity: 0.7,
            marginTop: 20 * scale
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? height * 0.3 : height * 0.25,
      left: "50%",
      transform: "translateX(-50%)",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      gap
    }, children: stages.map((stage, i) => {
      const delay = 15 + i * 10;
      const stageY = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 12 } });
      const stageOpacity = (0,esm.interpolate)(frame - delay, [0, 15], [0, 1], { extrapolateRight: "clamp" });
      const t = i / Math.max(1, totalStages - 1);
      const currentWidth = maxTopWidth - (maxTopWidth - minBottomWidth) * t;
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
        "div",
        {
          style: {
            width: currentWidth,
            height: stageHeight - gap,
            backgroundColor: stage.color,
            borderRadius: 12 * scale,
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            padding: `0 ${30 * scale}px`,
            transform: `translateY(${(1 - stageY) * -30}px) scale(${(0,esm.interpolate)(stageY, [0, 1], [0.95, 1])})`,
            opacity: stageOpacity,
            boxShadow: "0 20px 40px rgba(0,0,0,0.3)",
            // Create a slight 3D perspective / trapezoid illusion using clip-path or perspective
            // A simple rounded rect looks cleaner and more modern, but we can fake depth
            borderTop: "2px solid rgba(255,255,255,0.2)",
            overflow: "hidden",
            position: "relative"
          },
          children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: "linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 100%)",
              zIndex: 0
            } }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: {
              fontSize: Math.max(20, currentWidth * 0.05) * scale,
              fontWeight: 700,
              zIndex: 1,
              textShadow: "0 2px 4px rgba(0,0,0,0.5)"
            }, children: stage.label }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: {
              fontSize: Math.max(24, currentWidth * 0.06) * scale,
              fontWeight: 900,
              zIndex: 1,
              backgroundColor: "rgba(0,0,0,0.2)",
              padding: `${8 * scale}px ${16 * scale}px`,
              borderRadius: 20 * scale,
              textShadow: "0 2px 4px rgba(0,0,0,0.5)"
            }, children: stage.value })
          ]
        },
        i
      );
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "dynamic-sales-funnel-01",
  name: "Dynamic Sales Funnel",
  description: "A stacked, inverted pyramid funnel that dynamically adjusts to the number of stages provided.",
  category: "business-marketing",
  durationInFrames: 150,
  fps: 30,
  component: DynamicSalesFunnel,
  schema: dynamicSalesFunnelSchema,
  defaultProps: dynamicSalesFunnelSchema.parse({})
});

;// ./src/templates/business-marketing/FacebookAdMockup.tsx








const facebookAdMockupSchema = lib.z.object({
  pageName: lib.z.string().default("Lapaas"),
  avatarUrl: lib.z.string().default("https://images.unsplash.com/photo-1550525811-e5869dd03032?w=150"),
  time: lib.z.string().default("Sponsored"),
  content: lib.z.string().default("Struggling to edit videos consistently? \u{1F4F9}\n\nOur AI-powered editor cuts production time by 80%. Upload your raw footage and let the engine add B-roll, captions, and zoom effects automatically. \u{1F680}"),
  imageUrl: lib.z.string().default("https://images.unsplash.com/photo-1611162617474-5b21e879e113?w=800"),
  linkDomain: lib.z.string().default("LAPAAS.COM"),
  linkTitle: lib.z.string().default("The #1 AI Video Editor for Marketing Teams"),
  linkDesc: lib.z.string().default("Start your 14-day free trial today."),
  ctaText: lib.z.string().default("Learn more"),
  likesCount: lib.z.string().default("2.4K"),
  commentsCount: lib.z.string().default("184 Comments"),
  sharesCount: lib.z.string().default("89 Shares"),
  backgroundColor: lib.z.string().default("#f0f2f5"),
  textColor: lib.z.string().default("#050505")
});
const FacebookAdMockup = ({
  pageName,
  avatarUrl,
  time,
  content,
  imageUrl,
  linkDomain,
  linkTitle,
  linkDesc,
  ctaText,
  likesCount,
  commentsCount,
  sharesCount,
  textColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const pop = (0,esm.spring)({ frame: frame - 10, fps, config: { damping: 14, mass: 1.2 } });
  const op = (0,esm.interpolate)(frame - 10, [0, 10], [0, 1], { extrapolateRight: "clamp" });
  const cardWidth = isPortrait ? width * 0.95 : 650 * scale;
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground("#e9ebee", backgroundControls), fontFamily: interFont, alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
    width: cardWidth,
    backgroundColor: "#ffffff",
    borderRadius: 8 * scale,
    display: "flex",
    flexDirection: "column",
    boxShadow: "0 1px 2px rgba(0,0,0,0.2)",
    transform: `scale(${(0,esm.interpolate)(pop, [0, 1], [0.95, 1])}) translateY(${(1 - pop) * 30}px)`,
    opacity: op,
    overflow: "hidden"
  }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", padding: `${12 * scale}px ${16 * scale}px` }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", gap: 10 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: avatarUrl, style: { width: 40 * scale, height: 40 * scale, borderRadius: "50%", objectFit: "cover" } }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column" }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontSize: 15 * scale, fontWeight: 600, color: textColor, display: "flex", alignItems: "center", gap: 4 * scale }, children: [
            pageName,
            /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 14 * scale, height: 14 * scale, fill: "#0866FF", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm-1.9 14.7L6 12.6l1.5-1.5 2.6 2.6 6.4-6.4 1.5 1.5-7.9 7.9z" }) })
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontSize: 13 * scale, color: "#65676B", display: "flex", alignItems: "center", gap: 4 * scale }, children: [
            time,
            /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { children: "\xB7" }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 16 16", width: 12 * scale, height: 12 * scale, fill: "#65676B", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M8 1a7 7 0 100 14A7 7 0 008 1zm3.89 4.67a1.66 1.66 0 01-1.37.75h-5A1.66 1.66 0 014.11 5.67a6 6 0 017.78 0zM8 14A6 6 0 012.3 9h3.18a3.17 3.17 0 001.35 1.77A4.6 4.6 0 008 11.5a4.6 4.6 0 001.17-.73A3.17 3.17 0 0010.52 9h3.18A6 6 0 018 14z" }) })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", gap: 12 * scale, color: "#65676B" }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "currentColor", children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("circle", { cx: "12", cy: "12", r: "2" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("circle", { cx: "20", cy: "12", r: "2" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("circle", { cx: "4", cy: "12", r: "2" })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }) })
      ] })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      fontSize: 15 * scale,
      lineHeight: 1.4,
      color: textColor,
      whiteSpace: "pre-wrap",
      padding: `0 ${16 * scale}px ${12 * scale}px`
    }, children: content }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: "100%", aspectRatio: "1.91/1", backgroundColor: "#f0f2f5", position: "relative" }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: imageUrl, style: { width: "100%", height: "100%", objectFit: "cover" } }) }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      backgroundColor: "#F0F2F5",
      padding: `${10 * scale}px ${16 * scale}px`,
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between"
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column", flex: 1, overflow: "hidden", paddingRight: 16 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 12 * scale, color: "#65676B", textTransform: "uppercase", marginBottom: 2 * scale }, children: linkDomain }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 16 * scale, fontWeight: 600, color: textColor, whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" }, children: linkTitle }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 14 * scale, color: "#65676B", whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis", marginTop: 2 * scale }, children: linkDesc })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        backgroundColor: "#E4E6EB",
        padding: `${6 * scale}px ${12 * scale}px`,
        borderRadius: 6 * scale,
        fontSize: 15 * scale,
        fontWeight: 600,
        color: textColor
      }, children: ctaText })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { padding: `0 ${16 * scale}px` }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: `${10 * scale}px 0`,
        borderBottom: "1px solid #CED0D4",
        color: "#65676B",
        fontSize: 15 * scale
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 6 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex" }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 18 * scale, height: 18 * scale, borderRadius: "50%", backgroundColor: "#0866FF", display: "flex", alignItems: "center", justifyContent: "center", color: "#fff", fontSize: 10 * scale, zIndex: 2, border: "2px solid #fff" }, children: "\u{1F44D}" }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 18 * scale, height: 18 * scale, borderRadius: "50%", backgroundColor: "#F7B125", display: "flex", alignItems: "center", justifyContent: "center", color: "#fff", fontSize: 10 * scale, marginLeft: -4 * scale, zIndex: 1, border: "2px solid #fff" }, children: "\u2764\uFE0F" })
          ] }),
          likesCount
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", gap: 12 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { children: commentsCount }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { children: sharesCount })
        ] })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: `${4 * scale}px 0`
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { flex: 1, display: "flex", alignItems: "center", justifyContent: "center", gap: 8 * scale, padding: `${8 * scale}px 0`, borderRadius: 4 * scale, color: frame > 40 ? "#0866FF" : "#65676B", fontWeight: 600, fontSize: 15 * scale, transform: `scale(${(0,esm.interpolate)((0,esm.spring)({ frame: frame - 40, fps, config: { damping: 10 } }), [0, 0.5, 1], [1, 1.1, 1])})` }, children: [
          frame > 40 ? /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm4 14H6V4h7v5h5v9z" }) }) : /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3" }) }),
          "Like"
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { flex: 1, display: "flex", alignItems: "center", justifyContent: "center", gap: 8 * scale, padding: `${8 * scale}px 0`, borderRadius: 4 * scale, color: "#65676B", fontWeight: 600, fontSize: 15 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z" }) }),
          "Comment"
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { flex: 1, display: "flex", alignItems: "center", justifyContent: "center", gap: 8 * scale, padding: `${8 * scale}px 0`, borderRadius: 4 * scale, color: "#65676B", fontWeight: 600, fontSize: 15 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "none", stroke: "currentColor", strokeWidth: "2", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8M16 6l-4-4-4 4M12 2v13" }) }),
          "Share"
        ] })
      ] })
    ] })
  ] }) });
};
registerTemplate({
  tags: [],
  id: "facebook-ad-mockup-01",
  name: "Facebook Ad Mockup",
  description: "A realistic simulation of a Facebook Feed Ad, perfect for testing ad creative visually.",
  category: "platform-mockups",
  durationInFrames: 150,
  fps: 30,
  component: FacebookAdMockup,
  schema: facebookAdMockupSchema,
  defaultProps: facebookAdMockupSchema.parse({})
});

;// ./src/templates/business-marketing/FeatureListPopups.tsx










const featureListPopupsSchema = lib.z.object({
  title: lib.z.string().default("Core Features"),
  features: lib.z.array(lib.z.object({
    title: lib.z.string(),
    desc: lib.z.string(),
    icon: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { title: "Lightning Fast", desc: "Render times up to 10x faster than competitors.", icon: "\u26A1" },
    { title: "AI-Powered", desc: "Smart algorithms do the heavy lifting for you.", icon: "\u{1F9E0}" },
    { title: "Cloud Sync", desc: "Access your projects from any device, anywhere.", icon: "\u2601\uFE0F" },
    { title: "Team Collaboration", desc: "Work together in real-time without conflicts.", icon: "\u{1F91D}" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  cardBgColor: lib.z.string().default(COLORS.surface),
  accentColor: lib.z.string().default(COLORS.accent)
});
const FeatureListPopups = ({
  title,
  features,
  backgroundColor,
  textColor,
  cardBgColor,
  accentColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalFeatures = features.length;
  const cols = isPortrait ? 1 : Math.min(2, totalFeatures);
  const gap = 30 * scale;
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 120 * scale : 100 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: isPortrait ? "center" : "left",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 60 : 72) * scale,
            margin: 0,
            letterSpacing: "-0.02em",
            color: textColor
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        width: 100 * scale,
        height: 8 * scale,
        backgroundColor: accentColor,
        marginTop: 20 * scale,
        borderRadius: 4 * scale,
        margin: isPortrait ? "20px auto 0" : "20px 0 0"
      } })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 250 * scale : 220 * scale,
      left: paddingX,
      width: availableWidth,
      display: "grid",
      gridTemplateColumns: `repeat(${cols}, 1fr)`,
      gap
    }, children: features.map((feat, i) => {
      const delay = 20 + i * 10;
      const yOffset = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      const hoverScale = (0,esm.interpolate)(
        (0,esm.spring)({ frame: frame - delay - 30, fps, config: { damping: 12 } }),
        [0, 1],
        [1, 1.02]
      );
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        backgroundColor: cardBgColor,
        borderRadius: 20 * scale,
        padding: 30 * scale,
        transform: `translateY(${(1 - yOffset) * 50}px) scale(${hoverScale})`,
        opacity: op,
        boxShadow: "0 10px 30px rgba(0,0,0,0.1)",
        border: `1px solid ${COLORS.border}`,
        display: "flex",
        gap: 24 * scale,
        alignItems: "flex-start"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          width: 64 * scale,
          height: 64 * scale,
          backgroundColor: `${accentColor}20`,
          borderRadius: 16 * scale,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          fontSize: 32 * scale,
          color: accentColor,
          flexShrink: 0,
          border: `1px solid ${accentColor}40`
        }, children: feat.icon }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column", gap: 8 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 24 * scale,
            fontWeight: 700,
            fontFamily: interFont,
            color: "#fff",
            letterSpacing: "0.01em"
          }, children: feat.title }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 18 * scale,
            color: COLORS.textSecondary,
            lineHeight: 1.5
          }, children: feat.desc })
        ] })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "feature-list-popups-01",
  name: "Dynamic Feature Popups",
  description: "A clean grid of feature cards that sequentially slide up and fade in.",
  category: "business-marketing",
  durationInFrames: 150,
  fps: 30,
  component: FeatureListPopups,
  schema: featureListPopupsSchema,
  defaultProps: featureListPopupsSchema.parse({})
});

;// ./src/templates/business-marketing/FinancialBarChart.tsx










const financialBarChartSchema = lib.z.object({
  title: lib.z.string().default("OLA Financials FY22"),
  yAxisLabel: lib.z.string().default("Amount in \u20B9 Cr"),
  seriesLabels: lib.z.array(lib.z.string()).default(["FY20", "FY21", "FY22"]),
  seriesColors: lib.z.array(lib.z.string()).default(["#ff6b57", "#1b4d75", "#8898a1"]),
  categories: lib.z.array(lib.z.object({
    name: lib.z.string(),
    values: lib.z.array(lib.z.number()),
    highlightPercentage: lib.z.string().optional(),
    // e.g. "+100.4%"
    highlightColor: lib.z.string().optional(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    {
      name: "Operating Revenue",
      values: [2662, 983, 1970],
      highlightPercentage: "+100.4%",
      highlightColor: "#10b981"
    },
    {
      name: "Total Expenses",
      values: [5058, 2007, 3362],
      highlightPercentage: "+67.5%",
      highlightColor: "#ef4444"
    },
    {
      name: "Profit/Loss",
      values: [-2208, -1116, -1522],
      highlightPercentage: "+36.4%",
      highlightColor: "#ef4444"
    },
    {
      name: "Cash from Ops",
      values: [-981, -559, -934],
      highlightPercentage: "+67.1%",
      highlightColor: "#ef4444"
    }
  ]),
  backgroundColor: lib.z.string().default("#f4f4f4"),
  // Light gray background like the example
  textColor: lib.z.string().default("#111111"),
  gridColor: lib.z.string().default("#d1d5db"),
  logoUrl: lib.z.string().optional()
  // Optional logo next to title
});
const FinancialBarChart = ({
  title,
  yAxisLabel,
  seriesLabels,
  seriesColors,
  categories,
  backgroundColor,
  textColor,
  gridColor,
  logoUrl
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const paddingY = isPortrait ? 200 * scale : 150 * scale;
  const chartWidth = width - paddingX * 2;
  let maxVal = 0;
  let minVal = 0;
  categories.forEach((cat) => {
    cat.values.forEach((val) => {
      if (val > maxVal) maxVal = val;
      if (val < minVal) minVal = val;
    });
  });
  const yAxisMax = Math.ceil(maxVal / 1e3) * 1e3 || 1e3;
  const yAxisMin = Math.floor(minVal / 1e3) * 1e3 || 0;
  const range = yAxisMax - yAxisMin;
  const chartHeight = height - paddingY * 2 - 100 * scale;
  const zeroLinePct = minVal < 0 ? Math.abs(yAxisMin) / range : 0;
  const zeroLineY = chartHeight * zeroLinePct;
  const numCategories = categories.length;
  const numSeries = Math.max(1, seriesLabels.length);
  const categoryWidth = chartWidth / numCategories;
  const barGroupWidth = categoryWidth * 0.8;
  const barWidth = barGroupWidth / numSeries;
  const barGap = barWidth * 0.1;
  const actualBarWidth = barWidth - barGap;
  const sectionBgColors = [
    "linear-gradient(to bottom, #e2eff6, transparent)",
    "linear-gradient(to bottom, #fcece0, transparent)",
    "linear-gradient(to bottom, #e2eff6, transparent)",
    "linear-gradient(to bottom, #fcece0, transparent)"
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 80 * scale : 60 * scale,
      left: paddingX,
      display: "flex",
      alignItems: "center",
      gap: 20 * scale,
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      logoUrl && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: logoUrl, style: { height: 60 * scale, objectFit: "contain" } }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 900,
            fontSize: (isPortrait ? 48 : 64) * scale,
            margin: 0,
            letterSpacing: "-0.02em"
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 160 * scale : 80 * scale,
      right: paddingX,
      display: "flex",
      gap: 20 * scale,
      backgroundColor: "#ffffff",
      padding: `${12 * scale}px ${24 * scale}px`,
      borderRadius: 8 * scale,
      boxShadow: "0 4px 12px rgba(0,0,0,0.05)",
      opacity: titleOpacity
    }, children: seriesLabels.map((label, i) => /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 8 * scale }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 16 * scale, height: 16 * scale, backgroundColor: seriesColors[i % seriesColors.length], borderRadius: 4 * scale } }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 16 * scale, fontWeight: 600, color: "#4b5563" }, children: label })
    ] }, i)) }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: paddingY,
      left: paddingX,
      width: chartWidth,
      height: chartHeight
    }, children: [
      categories.map((_, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: 0,
        left: i * categoryWidth,
        width: categoryWidth,
        height: chartHeight,
        background: sectionBgColors[i % sectionBgColors.length],
        zIndex: 0
      } }, `bg-${i}`)),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: "50%",
        left: -80 * scale,
        transform: "translate(-50%, -50%) rotate(-90deg)",
        fontSize: 18 * scale,
        fontWeight: 600,
        color: "#4b5563",
        whiteSpace: "nowrap"
      }, children: yAxisLabel }),
      [...Array(5)].map((_, i) => {
        const pct = i / 4;
        const val = yAxisMin + range * pct;
        const isZero = val === 0;
        return /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          bottom: `${pct * 100}%`,
          left: 0,
          width: "100%",
          height: isZero ? 2 * scale : 1 * scale,
          backgroundColor: isZero ? "#9ca3af" : gridColor,
          zIndex: 1
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          left: -50 * scale,
          top: "50%",
          transform: "translateY(-50%)",
          fontSize: 14 * scale,
          fontWeight: 500,
          color: "#6b7280",
          textAlign: "right",
          width: 40 * scale
        }, children: Math.round(val) }) }, `grid-${i}`);
      }),
      categories.map((category, catIdx) => {
        return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          position: "absolute",
          left: catIdx * categoryWidth,
          bottom: 0,
          width: categoryWidth,
          height: "100%",
          zIndex: 2
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
            position: "absolute",
            left: "50%",
            bottom: zeroLineY,
            transform: "translateX(-50%)",
            display: "flex",
            alignItems: "flex-end",
            // for positive bars
            gap: barGap,
            height: 0,
            // start drawing from zero line
            width: barGroupWidth
          }, children: [
            category.values.map((val, seriesIdx) => {
              const absVal = Math.abs(val);
              const heightPct = absVal / range;
              const pixelHeight = heightPct * chartHeight;
              const isPositive = val >= 0;
              const delay = 20 + catIdx * 10 + seriesIdx * 5;
              const grow = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14, mass: 1.2 } });
              const currentHeight = Math.max(0, pixelHeight * grow);
              return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
                position: "relative",
                width: actualBarWidth,
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                // Handle drawing up (positive) or down (negative)
                ...isPositive ? {
                  height: currentHeight,
                  transformOrigin: "bottom",
                  justifyContent: "flex-start"
                } : {
                  position: "absolute",
                  top: 0,
                  // anchor to the zero line (which is bottom:0 of parent)
                  left: seriesIdx * barWidth,
                  height: currentHeight,
                  transformOrigin: "top",
                  justifyContent: "flex-end"
                }
              }, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
                  width: "100%",
                  height: "100%",
                  backgroundColor: seriesColors[seriesIdx % seriesColors.length],
                  // Only round the top/bottom edges based on polarity
                  borderTopLeftRadius: isPositive ? 4 * scale : 0,
                  borderTopRightRadius: isPositive ? 4 * scale : 0,
                  borderBottomLeftRadius: !isPositive ? 4 * scale : 0,
                  borderBottomRightRadius: !isPositive ? 4 * scale : 0
                } }),
                /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
                  position: "absolute",
                  [isPositive ? "top" : "bottom"]: -25 * scale,
                  fontSize: 16 * scale,
                  fontWeight: 800,
                  fontFamily: interFont,
                  color: "#111",
                  opacity: (0,esm.interpolate)(grow, [0.8, 1], [0, 1], { extrapolateRight: "clamp" })
                }, children: [
                  isPositive ? "" : "-",
                  Math.abs(val).toLocaleString()
                ] })
              ] }, `bar-${seriesIdx}`);
            }),
            category.highlightPercentage && category.values.length >= 2 && /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
              position: "absolute",
              left: barGroupWidth / numSeries * (numSeries - 1.5),
              // position between last two bars
              // Position above the tallest bar of the two
              top: -(Math.max(Math.abs(category.values[numSeries - 2]), Math.abs(category.values[numSeries - 1])) / range * chartHeight) - 40 * scale,
              opacity: (0,esm.interpolate)(frame - (40 + catIdx * 10), [0, 10], [0, 1], { extrapolateRight: "clamp" }),
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              zIndex: 10
            }, children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
                fontSize: 16 * scale,
                fontWeight: 800,
                color: category.highlightColor || "#ef4444"
              }, children: category.highlightPercentage }),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { width: 40 * scale, height: 40 * scale, viewBox: "0 0 50 50", style: { transform: "rotate(10deg)" }, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M10,40 Q10,10 40,10", fill: "none", stroke: category.highlightColor || "#ef4444", strokeWidth: 3 * scale, strokeLinecap: "round" }),
                /* @__PURE__ */ (0,jsx_runtime.jsx)("polygon", { points: "35,5 45,10 35,15", fill: category.highlightColor || "#ef4444" })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            position: "absolute",
            bottom: -40 * scale,
            width: "100%",
            textAlign: "center",
            fontSize: 18 * scale,
            fontWeight: 600,
            color: "#374151",
            opacity: titleOpacity
          }, children: category.name })
        ] }, `cat-${catIdx}`);
      })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      bottom: 0,
      left: 0,
      right: 0,
      height: 10 * scale,
      background: "linear-gradient(90deg, #ff6b57, #1b4d75, #8898a1)"
    } })
  ] });
};
registerTemplate({
  tags: [],
  id: "financial-bar-chart-01",
  name: "Multi-Series Financial Chart",
  description: "A robust multi-series bar chart that handles positive and negative values. Great for comparing yearly/quarterly financials.",
  category: "data-visualization",
  durationInFrames: 180,
  fps: 30,
  component: FinancialBarChart,
  schema: financialBarChartSchema,
  defaultProps: financialBarChartSchema.parse({})
});

;// ./src/templates/business-marketing/FlywheelModel.tsx










const marketingFlywheelSchema = lib.z.object({
  title: lib.z.string().default("The Marketing Flywheel"),
  segments: lib.z.array(lib.z.object({
    label: lib.z.string(),
    color: lib.z.string(),
    icon: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { label: "Attract", color: "#ef4444", icon: "\u{1F9F2}" },
    { label: "Engage", color: "#eab308", icon: "\u{1F91D}" },
    { label: "Delight", color: "#22c55e", icon: "\u2728" }
  ]),
  backgroundColor: lib.z.string().default("#ffffff"),
  textColor: lib.z.string().default("#0f172a"),
  centerText: lib.z.string().default("Growth")
});
const FlywheelModel = ({
  title,
  segments,
  backgroundColor,
  textColor,
  centerText
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalSegments = Math.max(1, segments.length);
  const anglePerSegment = 360 / totalSegments;
  const radius = isPortrait ? width * 0.35 : height * 0.3;
  const rotation = (0,esm.interpolate)(frame, [0, 300], [0, 360], { extrapolateRight: "extend" });
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -50}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      width: radius * 2,
      height: radius * 2,
      transform: `translate(-50%, -50%) rotate(${rotation}deg)`,
      borderRadius: "50%",
      boxShadow: "0 20px 50px rgba(0,0,0,0.1)",
      border: `${8 * scale}px solid #fff`,
      overflow: "hidden"
    }, children: [
      segments.map((seg, i) => {
        const startAngle = i * anglePerSegment;
        const endAngle = (i + 1) * anglePerSegment;
        const delay = 15 + i * 10;
        const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
        return /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: seg.color,
          // Use clip-path to make slices
          clipPath: totalSegments > 1 ? `polygon(50% 50%, ${50 + 50 * Math.cos((startAngle - 90) * Math.PI / 180)}% ${50 + 50 * Math.sin((startAngle - 90) * Math.PI / 180)}%, ${50 + 50 * Math.cos((endAngle - 90) * Math.PI / 180)}% ${50 + 50 * Math.sin((endAngle - 90) * Math.PI / 180)}%)` : "none",
          transform: `scale(${pop})`,
          transformOrigin: "50% 50%",
          opacity: pop
        } }, i);
      }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: `translate(-50%, -50%)`,
        width: radius * 0.9,
        height: radius * 0.9,
        backgroundColor: "#fff",
        borderRadius: "50%",
        boxShadow: "inset 0 10px 20px rgba(0,0,0,0.1)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 10
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        transform: `rotate(${-rotation}deg)`,
        fontSize: 48 * scale,
        fontWeight: 900,
        fontFamily: interFont,
        color: textColor
      }, children: centerText }) })
    ] }),
    segments.map((seg, i) => {
      const midAngle = (i + 0.5) * anglePerSegment;
      const actualAngle = midAngle + rotation;
      const rad = (actualAngle - 90) * Math.PI / 180;
      const labelRadius = radius + 80 * scale;
      const x = Math.cos(rad) * labelRadius;
      const y = Math.sin(rad) * labelRadius;
      const delay = 30 + i * 10;
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: `translate(-50%, -50%) translate(${x}px, ${y}px)`,
        display: "flex",
        alignItems: "center",
        gap: 12 * scale,
        opacity: op,
        backgroundColor: "#fff",
        padding: `${12 * scale}px ${24 * scale}px`,
        borderRadius: 30 * scale,
        boxShadow: "0 10px 30px rgba(0,0,0,0.1)",
        border: `2px solid ${seg.color}`
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 32 * scale }, children: seg.icon }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: {
          fontSize: 24 * scale,
          fontWeight: 800,
          color: seg.color,
          fontFamily: interFont,
          textTransform: "uppercase",
          letterSpacing: "0.05em"
        }, children: seg.label })
      ] }, i);
    })
  ] });
};
registerTemplate({
  tags: [],
  id: "flywheel-model-01",
  name: "Dynamic Marketing Flywheel",
  description: "An animated circular flywheel that divides itself into slices based on the segments array and rotates continuously.",
  category: "business-marketing",
  durationInFrames: 240,
  fps: 30,
  component: FlywheelModel,
  schema: marketingFlywheelSchema,
  defaultProps: marketingFlywheelSchema.parse({})
});

;// ./src/templates/business-marketing/GoogleSearchMockup.tsx








const googleSearchMockupSchema = lib.z.object({
  searchQuery: lib.z.string().default("best ai video editor for marketing"),
  results: lib.z.array(lib.z.object({
    title: lib.z.string(),
    url: lib.z.string(),
    description: lib.z.string(),
    isAd: lib.z.boolean().default(false)
  })).default([
    { title: "Lapaas AI Editor | The #1 Marketing Video Tool", url: "https://lapaas.com/ai-editor", description: "Create viral short-form content 10x faster. Automated B-roll, smart captions, and dynamic templates built for marketers.", isAd: true },
    { title: "Top 10 AI Video Editors in 2024 - Reviews", url: "https://techradar.com/reviews/best-ai-video-editors", description: "We tested the top AI video editing software. See why Lapaas ranked #1 for agencies and marketing teams.", isAd: false },
    { title: "How to automate your video marketing with AI", url: "https://blog.hubspot.com/marketing/ai-video", description: "Learn how modern marketing teams are using AI to scale their video production without increasing headcount.", isAd: false }
  ]),
  backgroundColor: lib.z.string().default("#ffffff"),
  textColor: lib.z.string().default("#202124")
});
const GoogleSearchMockup = ({
  searchQuery,
  results,
  backgroundColor,
  textColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const paddingX = isPortrait ? 40 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  const charsToShow = Math.floor((0,esm.interpolate)(frame, [15, 60], [0, searchQuery.length], { extrapolateRight: "clamp", extrapolateLeft: "clamp" }));
  const currentQuery = searchQuery.slice(0, charsToShow);
  const isSearchComplete = frame > 75;
  const resultsPop = (0,esm.spring)({ frame: frame - 80, fps, config: { damping: 14 } });
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { backgroundColor, fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      background: resolveCanvasBackground("#ffffff", backgroundControls),
      borderBottom: isSearchComplete ? "1px solid #dfe1e5" : "none",
      padding: isPortrait ? `${40 * scale}px ${paddingX}px ${20 * scale}px` : `${30 * scale}px ${paddingX}px`,
      display: "flex",
      flexDirection: isPortrait ? "column" : "row",
      alignItems: isPortrait ? "flex-start" : "center",
      gap: 30 * scale,
      boxShadow: isSearchComplete ? "0 1px 6px rgba(32,33,36,0.1)" : "none",
      transform: `translateY(${isSearchComplete ? 0 : height / 2 - 150 * scale}px)`,
      transition: "transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1)",
      zIndex: 10
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        fontSize: 40 * scale,
        fontWeight: 700,
        letterSpacing: "-2px",
        display: "flex",
        transform: isSearchComplete ? "scale(0.8)" : isPortrait ? "scale(1.5) translateX(30px)" : "scale(2) translateX(40px)",
        transition: "transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1)",
        marginBottom: isPortrait && !isSearchComplete ? 60 * scale : 0
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { color: "#4285f4" }, children: "G" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { color: "#ea4335" }, children: "o" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { color: "#fbbc05" }, children: "o" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { color: "#4285f4" }, children: "g" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { color: "#34a853" }, children: "l" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { color: "#ea4335" }, children: "e" })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        flex: 1,
        maxWidth: 800 * scale,
        height: 60 * scale,
        borderRadius: 30 * scale,
        border: "1px solid #dfe1e5",
        backgroundColor: "#fff",
        display: "flex",
        alignItems: "center",
        padding: `0 ${20 * scale}px`,
        boxShadow: "0 1px 6px rgba(32,33,36,0.2)",
        fontSize: 20 * scale
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { width: 24 * scale, height: 24 * scale, viewBox: "0 0 24 24", fill: "none", stroke: "#9aa0a6", strokeWidth: "2", children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("circle", { cx: "11", cy: "11", r: "8" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("line", { x1: "21", y1: "21", x2: "16.65", y2: "16.65" })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { marginLeft: 16 * scale, color: "#202124", flex: 1, display: "flex" }, children: [
          currentQuery,
          !isSearchComplete && frame % 20 < 10 && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 2 * scale, height: 24 * scale, backgroundColor: "#000", marginLeft: 2 * scale } })
        ] })
      ] })
    ] }),
    isSearchComplete && /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 220 * scale : 150 * scale,
      left: paddingX,
      width: availableWidth,
      maxWidth: 800 * scale,
      // Google results max width roughly
      display: "flex",
      flexDirection: "column",
      gap: 40 * scale,
      paddingBottom: 100 * scale
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { color: "#70757a", fontSize: 16 * scale, opacity: resultsPop }, children: [
        "About ",
        Math.floor(Math.random() * 900 + 100).toLocaleString(),
        ",000,000 results (0.42 seconds)"
      ] }),
      results.map((result, i) => {
        const delay = 85 + i * 10;
        const resPop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
        const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
        return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          display: "flex",
          flexDirection: "column",
          gap: 6 * scale,
          transform: `translateY(${(1 - resPop) * 20}px)`,
          opacity: op
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 12 * scale }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 28 * scale, height: 28 * scale, borderRadius: "50%", backgroundColor: "#f1f3f4", display: "flex", alignItems: "center", justifyContent: "center", fontSize: 14 * scale }, children: "\u{1F310}" }),
            /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column" }, children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 16 * scale, color: "#202124" }, children: result.url.split("/")[2] }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 14 * scale, color: "#4d5156" }, children: result.url })
            ] })
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 10 * scale, marginTop: 4 * scale }, children: [
            result.isAd && /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontWeight: 700, fontSize: 16 * scale, color: "#202124" }, children: "Sponsored" }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
              fontSize: 24 * scale,
              color: "#1a0dab",
              textDecoration: "none",
              cursor: "pointer"
            }, children: result.title })
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 18 * scale,
            color: "#4d5156",
            lineHeight: 1.5,
            marginTop: 4 * scale
          }, children: result.description })
        ] }, i);
      })
    ] })
  ] });
};
registerTemplate({
  tags: [],
  id: "google-search-mockup-01",
  name: "Google Search Mockup",
  description: "Simulates typing a query into Google and returning a list of search results or ads.",
  category: "platform-mockups",
  durationInFrames: 240,
  fps: 30,
  component: GoogleSearchMockup,
  schema: googleSearchMockupSchema,
  defaultProps: googleSearchMockupSchema.parse({})
});

;// ./src/templates/business-marketing/GrowthLineGraph.tsx










const growthLineGraphSchema = lib.z.object({
  title: lib.z.string().default("Active Users"),
  subtitle: lib.z.string().default("Monthly Growth (in thousands)"),
  points: lib.z.array(lib.z.object({
    label: lib.z.string(),
    value: lib.z.number(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { label: "Jan", value: 10 },
    { label: "Feb", value: 15 },
    { label: "Mar", value: 25 },
    { label: "Apr", value: 45 },
    { label: "May", value: 60 },
    { label: "Jun", value: 95 },
    { label: "Jul", value: 150 }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  lineColor: lib.z.string().default("#10b981"),
  gridColor: lib.z.string().default("rgba(255,255,255,0.1)")
});
const GrowthLineGraph = ({
  title,
  subtitle,
  points,
  backgroundColor,
  textColor,
  lineColor,
  gridColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const paddingX = isPortrait ? 80 * scale : 150 * scale;
  const paddingY = isPortrait ? 300 * scale : 200 * scale;
  const chartWidth = width - paddingX * 2;
  const chartHeight = height - paddingY * 2 - 100 * scale;
  const startX = paddingX;
  const startY = height - paddingY;
  const maxVal = Math.max(...points.map((p) => p.value));
  const minVal = 0;
  const totalPoints = Math.max(1, points.length - 1);
  const xStep = chartWidth / totalPoints;
  let pathD = "";
  const pointsCoords = [];
  points.forEach((p, i) => {
    const x = i * xStep;
    const y = -((p.value - minVal) / (maxVal - minVal)) * chartHeight;
    pointsCoords.push({ x, y, label: p.label, value: p.value });
    if (i === 0) pathD += `M ${x} ${y} `;
    else pathD += `L ${x} ${y} `;
  });
  const drawProgress = (0,esm.spring)({ frame: frame - 20, fps, config: { damping: 20, mass: 2 } });
  const fillPathD = `${pathD} L ${chartWidth} 0 L 0 0 Z`;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: paddingX,
      width: chartWidth,
      textAlign: "left",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 60 : 72) * scale,
            margin: 0,
            letterSpacing: "-0.02em",
            color: lineColor
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 24 : 32) * scale,
            opacity: 0.6,
            marginTop: 10 * scale
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      left: startX,
      top: startY - chartHeight,
      width: chartWidth,
      height: chartHeight
    }, children: [
      [0, 0.25, 0.5, 0.75, 1].map((pct, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        bottom: `${pct * 100}%`,
        left: 0,
        width: "100%",
        height: 1,
        backgroundColor: gridColor
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        left: -60 * scale,
        top: -10 * scale,
        fontSize: 16 * scale,
        color: COLORS.textMuted,
        textAlign: "right",
        width: 50 * scale
      }, children: Math.round(pct * maxVal) }) }, i)),
      pointsCoords.map((p, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        left: p.x,
        bottom: -30 * scale,
        height: chartHeight + 10 * scale,
        borderLeft: `1px dashed ${gridColor}`
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        bottom: -30 * scale,
        left: -40 * scale,
        width: 80 * scale,
        textAlign: "center",
        fontSize: 16 * scale,
        fontWeight: 600,
        color: COLORS.textSecondary
      }, children: p.label }) }, i)),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)(
        "svg",
        {
          width: "100%",
          height: "100%",
          viewBox: `0 ${-chartHeight} ${chartWidth} ${chartHeight}`,
          style: { overflow: "visible" },
          children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("defs", { children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("linearGradient", { id: "fillGradient", x1: "0", y1: "0", x2: "0", y2: "1", children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("stop", { offset: "0%", stopColor: lineColor, stopOpacity: 0.4 }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)("stop", { offset: "100%", stopColor: lineColor, stopOpacity: 0 })
            ] }) }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "path",
              {
                d: fillPathD,
                fill: "url(#fillGradient)",
                style: {
                  clipPath: `inset(0 ${100 - drawProgress * 100}% 0 0)`
                  // Animate reveal from left to right
                }
              }
            ),
            /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "path",
              {
                d: pathD,
                fill: "none",
                stroke: lineColor,
                strokeWidth: 6 * scale,
                strokeLinecap: "round",
                strokeLinejoin: "round",
                style: {
                  // We use clipPath instead of dasharray because dasharray is tricky with multiple segments
                  clipPath: `inset(0 ${100 - drawProgress * 100}% 0 0)`,
                  filter: `drop-shadow(0 10px 10px ${lineColor}80)`
                }
              }
            ),
            pointsCoords.map((p, i) => {
              const progressAtPoint = i / totalPoints;
              const isReached = drawProgress >= progressAtPoint;
              const dotPop = isReached ? (0,esm.spring)({ frame: frame - (20 + progressAtPoint * 60), fps, config: { damping: 10 } }) : 0;
              if (!isReached) return null;
              return /* @__PURE__ */ (0,jsx_runtime.jsxs)("g", { transform: `translate(${p.x}, ${p.y}) scale(${dotPop})`, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "circle",
                  {
                    r: 10 * scale,
                    fill: backgroundColor,
                    stroke: lineColor,
                    strokeWidth: 4 * scale
                  }
                ),
                /* @__PURE__ */ (0,jsx_runtime.jsxs)("g", { transform: `translate(0, ${-30 * scale})`, children: [
                  /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "rect",
                    {
                      x: -40 * scale,
                      y: -25 * scale,
                      width: 80 * scale,
                      height: 30 * scale,
                      rx: 6 * scale,
                      fill: lineColor
                    }
                  ),
                  /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "text",
                    {
                      x: "0",
                      y: -5 * scale,
                      textAnchor: "middle",
                      fill: backgroundColor,
                      fontSize: 16 * scale,
                      fontWeight: "bold",
                      fontFamily: interFont,
                      children: p.value
                    }
                  )
                ] })
              ] }, i);
            })
          ]
        }
      )
    ] })
  ] });
};
registerTemplate({
  tags: [],
  id: "growth-line-graph-01",
  name: "Animated Line Graph",
  description: "A data visualization graph that draws a line from left to right showing growth over time.",
  category: "data-visualization",
  durationInFrames: 180,
  fps: 30,
  component: GrowthLineGraph,
  schema: growthLineGraphSchema,
  defaultProps: growthLineGraphSchema.parse({})
});

;// ./src/templates/business-marketing/HistoryMilestones.tsx










const historyMilestonesSchema = lib.z.object({
  title: lib.z.string().default("Our Journey"),
  milestones: lib.z.array(lib.z.object({
    year: lib.z.string(),
    title: lib.z.string(),
    imageUrl: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { year: "2018", title: "The Idea Born", imageUrl: "https://images.unsplash.com/photo-1517048676732-d65bc937f952?w=800" },
    { year: "2020", title: "First Office", imageUrl: "https://images.unsplash.com/photo-1497366216548-37526070297c?w=800" },
    { year: "2022", title: "Series A Funding", imageUrl: "https://images.unsplash.com/photo-1556761175-5973dc0f32d7?w=800" },
    { year: "2024", title: "Global Expansion", imageUrl: "https://images.unsplash.com/photo-1522071820081-009f0129c71c?w=800" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  accentColor: lib.z.string().default(COLORS.accent)
});
const HistoryMilestones = ({
  title,
  milestones,
  textColor,
  accentColor,
  backgroundColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const framesPerMilestone = 60;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor, perspective: "1500px", overflow: "hidden" }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity,
      zIndex: 100
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em",
          textShadow: "0 4px 20px rgba(0,0,0,0.8)"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      transformStyle: "preserve-3d",
      // Move the entire scene forward over time
      // Each milestone is spaced 1000px apart on the Z axis
      transform: `translateZ(${frame * (1e3 / framesPerMilestone)}px)`
    }, children: milestones.map((m, i) => {
      const zPosition = -(i * 1e3);
      const isLeft = i % 2 === 0;
      const xOffset = isPortrait ? 0 : isLeft ? -300 * scale : 300 * scale;
      const yOffset = isPortrait ? isLeft ? -150 * scale : 150 * scale : 0;
      const isPassed = frame * (1e3 / framesPerMilestone) > i * 1e3;
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: `translate(-50%, -50%) translate3d(${xOffset}px, ${yOffset}px, ${zPosition}px)`,
        width: isPortrait ? 600 * scale : 800 * scale,
        height: isPortrait ? 400 * scale : 500 * scale,
        borderRadius: 24 * scale,
        overflow: "hidden",
        boxShadow: `0 30px 60px rgba(0,0,0,0.5)`,
        border: `2px solid ${accentColor}40`,
        // Fade out quickly as camera passes through it
        opacity: isPassed ? 0 : 1,
        transition: "opacity 0.1s"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: m.imageUrl, style: {
          width: "100%",
          height: "100%",
          objectFit: "cover",
          filter: "brightness(0.6)"
        } }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          position: "absolute",
          bottom: 0,
          left: 0,
          right: 0,
          background: "linear-gradient(to top, rgba(0,0,0,0.9), transparent)",
          padding: 40 * scale
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 80 * scale,
            fontWeight: 900,
            fontFamily: interFont,
            color: accentColor,
            lineHeight: 1,
            marginBottom: 10 * scale
          }, children: m.year }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 36 * scale,
            fontWeight: 700,
            color: "#fff"
          }, children: m.title })
        ] })
      ] }, i);
    }) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      boxShadow: "inset 0 0 150px rgba(0,0,0,0.8)",
      pointerEvents: "none",
      zIndex: 50
    } })
  ] });
};
registerTemplate({
  tags: [],
  id: "history-milestones-01",
  name: "3D History Timeline",
  description: "A cinematic 3D zoom-through of historical company milestones with background imagery.",
  category: "business-marketing",
  durationInFrames: 300,
  // Will vary based on number of items in real usage, we assume 5 items * 60 frames = 300
  fps: 30,
  component: HistoryMilestones,
  schema: historyMilestonesSchema,
  defaultProps: historyMilestonesSchema.parse({})
});

;// ./src/templates/business-marketing/HorizontalRoadmap.tsx










const horizontalRoadmapSchema = lib.z.object({
  title: lib.z.string().default("Product Roadmap"),
  subtitle: lib.z.string().default("What we are building next."),
  milestones: lib.z.array(lib.z.object({
    time: lib.z.string(),
    title: lib.z.string(),
    desc: lib.z.string(),
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { time: "Q1", title: "Beta Launch", desc: "Invite-only release for early adopters.", color: "#3b82f6" },
    { time: "Q2", title: "Mobile App", desc: "Native iOS and Android applications.", color: "#10b981" },
    { time: "Q3", title: "API Access", desc: "Public REST API for developers.", color: "#f59e0b" },
    { time: "Q4", title: "Enterprise", desc: "SSO, SLA, and dedicated support.", color: "#8b5cf6" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  lineColor: lib.z.string().default("rgba(255,255,255,0.2)")
});
const HorizontalRoadmap = ({
  title,
  subtitle,
  milestones,
  backgroundColor,
  textColor,
  lineColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalMilestones = milestones.length;
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  const flexDirection = isPortrait ? "column" : "row";
  const alignPoints = isPortrait ? "flex-start" : "center";
  const startY = isPortrait ? 300 * scale : height * 0.5;
  const drawProgress = (0,esm.spring)({ frame: frame - 20, fps, config: { damping: 20, mass: 1.5 } });
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 100 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: isPortrait ? "center" : "left",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 60 : 72) * scale,
            margin: 0,
            letterSpacing: "-0.02em",
            color: textColor
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 24 : 32) * scale,
            opacity: 0.6,
            marginTop: 10 * scale
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? startY : "50%",
      left: paddingX,
      width: availableWidth,
      height: isPortrait ? height - startY - 100 * scale : "auto",
      display: "flex",
      flexDirection,
      alignItems: alignPoints,
      justifyContent: "space-between",
      transform: isPortrait ? "none" : "translateY(-50%)"
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        [isPortrait ? "top" : "left"]: 0,
        [isPortrait ? "bottom" : "right"]: 0,
        [isPortrait ? "left" : "top"]: isPortrait ? 24 * scale : "50%",
        [isPortrait ? "width" : "height"]: 4 * scale,
        backgroundColor: lineColor,
        transform: isPortrait ? "none" : "translateY(-50%)",
        zIndex: 0
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: 0,
        left: 0,
        [isPortrait ? "height" : "width"]: `${drawProgress * 100}%`,
        [isPortrait ? "width" : "height"]: "100%",
        background: "linear-gradient(90deg, #3b82f6, #8b5cf6)",
        boxShadow: "0 0 10px rgba(59, 130, 246, 0.5)"
      } }) }),
      milestones.map((m, i) => {
        const delay = 30 + i * 15;
        const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 12, mass: 0.8 } });
        const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
        const isTop = !isPortrait && i % 2 === 0;
        return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          position: "relative",
          display: "flex",
          flexDirection: isPortrait ? "row" : "column",
          alignItems: isPortrait ? "center" : "center",
          gap: 20 * scale,
          opacity: op,
          zIndex: 1,
          width: isPortrait ? "100%" : availableWidth / totalMilestones * 0.9
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            width: 48 * scale,
            height: 48 * scale,
            borderRadius: "50%",
            backgroundColor: m.color,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            transform: `scale(${pop})`,
            boxShadow: `0 0 20px ${m.color}60`,
            flexShrink: 0,
            zIndex: 10,
            // If landscape and top, push node down. If bottom, push node up to center on line.
            // It's easier to just use flexbox order
            order: isPortrait ? 1 : isTop ? 2 : 1
          }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 16 * scale, height: 16 * scale, borderRadius: "50%", backgroundColor: "#fff" } }) }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
            display: "flex",
            flexDirection: "column",
            alignItems: isPortrait ? "flex-start" : "center",
            textAlign: isPortrait ? "left" : "center",
            order: isPortrait ? 2 : isTop ? 1 : 2,
            // Offset the box slightly from the center line in landscape
            paddingBottom: isTop ? 40 * scale : 0,
            paddingTop: !isTop && !isPortrait ? 40 * scale : 0,
            transform: `translateY(${(1 - pop) * (isTop ? -20 : 20)}px)`
          }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
              fontSize: 20 * scale,
              fontWeight: 800,
              color: m.color,
              textTransform: "uppercase",
              letterSpacing: "0.1em",
              marginBottom: 8 * scale
            }, children: m.time }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
              fontSize: 28 * scale,
              fontWeight: 700,
              fontFamily: interFont,
              color: "#fff",
              marginBottom: 12 * scale
            }, children: m.title }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
              fontSize: 18 * scale,
              color: COLORS.textSecondary,
              lineHeight: 1.4,
              maxWidth: 300 * scale
            }, children: m.desc })
          ] })
        ] }, i);
      })
    ] })
  ] });
};
registerTemplate({
  tags: [],
  id: "horizontal-roadmap-01",
  name: "Dynamic Roadmap",
  description: "A timeline roadmap that connects milestones. Adapts layout based on device orientation.",
  category: "business-marketing",
  durationInFrames: 210,
  fps: 30,
  component: HorizontalRoadmap,
  schema: horizontalRoadmapSchema,
  defaultProps: horizontalRoadmapSchema.parse({})
});

;// ./src/templates/business-marketing/IMessageMockup.tsx









const imessageMockupSchema = lib.z.object({
  contactName: lib.z.string().default("Sarah (Marketing)"),
  contactAvatarUrl: lib.z.string().default("https://images.unsplash.com/photo-1494790108377-be9c29b29330?w=150"),
  messages: lib.z.array(lib.z.object({
    text: lib.z.string(),
    isMe: lib.z.boolean(),
    hasTail: lib.z.boolean().default(true)
  })).default([
    { text: "Hey, did you see the new campaign metrics?", isMe: false },
    { text: "Yes! The new video ads are converting at 4x the usual rate. \u{1F680}", isMe: true },
    { text: "How did you edit them so fast? We used to take days for that.", isMe: false },
    { text: "Found this new AI tool called Lapaas. It literally does the B-roll and captions for you. \u{1F92B}", isMe: true }
  ]),
  backgroundColor: lib.z.string().default("#000000"),
  textColor: lib.z.string().default("#ffffff"),
  bubbleColorMe: lib.z.string().default("#0A84FF"),
  // iMessage Blue
  bubbleColorThem: lib.z.string().default("#3A3A3C"),
  // Dark mode gray
  textMe: lib.z.string().default("#ffffff"),
  textThem: lib.z.string().default("#ffffff")
});
const IMessageMockup = ({
  contactName,
  contactAvatarUrl,
  messages,
  backgroundColor,
  bubbleColorMe,
  bubbleColorThem,
  textMe,
  textThem
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const phoneWidth = isPortrait ? width : 450 * scale;
  const phoneHeight = isPortrait ? 1920 : 850 * scale;
  const phonePop = (0,esm.spring)({ frame: frame - 10, fps, config: { damping: 14 } });
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { backgroundColor, fontFamily: interFont, alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
    width: phoneWidth,
    height: phoneHeight,
    background: resolveCanvasBackground("#000000", backgroundControls),
    borderRadius: isPortrait ? 0 : 40 * scale,
    border: isPortrait ? "none" : `12px solid #1a1a1a`,
    display: "flex",
    flexDirection: "column",
    overflow: "hidden",
    position: "relative",
    transform: isPortrait ? "none" : `scale(${(0,esm.interpolate)(phonePop, [0, 1], [0.9, 1])}) translateY(${(1 - phonePop) * 50}px)`,
    opacity: isPortrait ? 1 : (0,esm.interpolate)(phonePop, [0, 1], [0, 1]),
    boxShadow: isPortrait ? "none" : "0 30px 60px rgba(0,0,0,0.8)"
  }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      backgroundColor: "rgba(30,30,30,0.85)",
      backdropFilter: "blur(20px)",
      padding: `${isPortrait ? 60 * scale : 40 * scale}px ${20 * scale}px ${16 * scale}px`,
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      borderBottom: "1px solid rgba(255,255,255,0.1)",
      zIndex: 10
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", color: "#0A84FF", fontSize: 18 * scale, gap: 4 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 24 * scale, height: 24 * scale, fill: "none", stroke: "currentColor", strokeWidth: "2.5", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "15 18 9 12 15 6" }) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { marginTop: 2 * scale }, children: "44" })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column", alignItems: "center", gap: 4 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: contactAvatarUrl, style: { width: 44 * scale, height: 44 * scale, borderRadius: "50%", objectFit: "cover" } }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontSize: 12 * scale, fontWeight: 500, color: "#fff" }, children: [
          contactName,
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { color: "#8e8e93", fontSize: 16 * scale, marginLeft: 2 * scale }, children: "\u203A" })
        ] })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 40 * scale } }),
      " "
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      flex: 1,
      display: "flex",
      flexDirection: "column",
      padding: `${20 * scale}px`,
      gap: 16 * scale,
      // Auto-scroll logic: move the container up as new messages arrive
      transform: `translateY(${(0,esm.interpolate)(frame, [100, 200], [0, messages.length > 3 ? -100 * scale : 0], { extrapolateLeft: "clamp", extrapolateRight: "clamp" })}px)`
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { textAlign: "center", fontSize: 12 * scale, color: "#8e8e93", fontWeight: 600, marginBottom: 8 * scale }, children: "Today 9:41 AM" }),
      messages.map((msg, i) => {
        const delay = 30 + i * 40;
        const msgPop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14, mass: 0.8 } });
        const op = (0,esm.interpolate)(frame - delay, [0, 5], [0, 1], { extrapolateRight: "clamp" });
        const isTyping = frame >= delay - 20 && frame < delay;
        return /* @__PURE__ */ (0,jsx_runtime.jsxs)(react.Fragment, { children: [
          !msg.isMe && isTyping && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            alignSelf: "flex-start",
            backgroundColor: bubbleColorThem,
            padding: `${12 * scale}px ${16 * scale}px`,
            borderRadius: 20 * scale,
            display: "flex",
            gap: 4 * scale,
            opacity: (0,esm.interpolate)(frame - (delay - 20), [0, 5], [0, 1], { extrapolateRight: "clamp" })
          }, children: [0, 1, 2].map((dot) => /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            width: 8 * scale,
            height: 8 * scale,
            borderRadius: "50%",
            backgroundColor: "#8e8e93",
            opacity: (0,esm.interpolate)(frame % 30, [dot * 10, dot * 10 + 5, dot * 10 + 10], [0.4, 1, 0.4], { extrapolateRight: "extend" })
          } }, dot)) }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
            alignSelf: msg.isMe ? "flex-end" : "flex-start",
            maxWidth: "75%",
            backgroundColor: msg.isMe ? bubbleColorMe : bubbleColorThem,
            color: msg.isMe ? textMe : textThem,
            padding: `${10 * scale}px ${16 * scale}px`,
            fontSize: 17 * scale,
            lineHeight: 1.35,
            borderRadius: 20 * scale,
            // iMessage Tail logic
            borderBottomRightRadius: msg.isMe && msg.hasTail ? 4 * scale : 20 * scale,
            borderBottomLeftRadius: !msg.isMe && msg.hasTail ? 4 * scale : 20 * scale,
            transform: `scale(${msgPop})`,
            transformOrigin: msg.isMe ? "bottom right" : "bottom left",
            opacity: op,
            position: "relative"
          }, children: [
            msg.text,
            msg.hasTail && /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "svg",
              {
                viewBox: "0 0 20 20",
                width: 16 * scale,
                height: 16 * scale,
                style: {
                  position: "absolute",
                  bottom: 0,
                  [msg.isMe ? "right" : "left"]: -8 * scale,
                  fill: msg.isMe ? bubbleColorMe : bubbleColorThem,
                  transform: msg.isMe ? "none" : "scaleX(-1)"
                },
                children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M19.5 20c-2.5 0-5.5-1.5-7.5-3.5L12 16h-2c-5.5 0-10-4.5-10-10S4.5 0 10 0s10 4.5 10 10c0 4.5-2.5 8-5.5 9.5l-2.5 1c3.5 0 6.5-1.5 7.5-3.5v3z" })
              }
            )
          ] })
        ] }, i);
      })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      backgroundColor: "#1a1a1a",
      padding: `${12 * scale}px ${16 * scale}px ${isPortrait ? 40 * scale : 24 * scale}px`,
      display: "flex",
      alignItems: "center",
      gap: 12 * scale,
      borderTop: "1px solid rgba(255,255,255,0.1)"
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 32 * scale, height: 32 * scale, borderRadius: "50%", backgroundColor: "rgba(255,255,255,0.1)", display: "flex", alignItems: "center", justifyContent: "center", color: "#8e8e93", fontSize: 20 * scale }, children: "+" }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        flex: 1,
        height: 36 * scale,
        borderRadius: 18 * scale,
        border: "1px solid rgba(255,255,255,0.2)",
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: `0 ${12 * scale}px`
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { color: "#8e8e93", fontSize: 16 * scale }, children: "iMessage" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 24 * scale, height: 24 * scale, borderRadius: "50%", backgroundColor: "#0A84FF", display: "flex", alignItems: "center", justifyContent: "center", color: "#fff" }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { viewBox: "0 0 24 24", width: 14 * scale, height: 14 * scale, fill: "none", stroke: "currentColor", strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round", children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("line", { x1: "12", y1: "19", x2: "12", y2: "5" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "5 12 12 5 19 12" })
        ] }) })
      ] })
    ] })
  ] }) });
};
registerTemplate({
  tags: [],
  id: "imessage-chat-mockup-01",
  name: "iMessage Chat Mockup",
  description: "A realistic iOS text message conversation with typing indicators and animated bubbles.",
  category: "platform-mockups",
  durationInFrames: 240,
  fps: 30,
  component: IMessageMockup,
  schema: imessageMockupSchema,
  defaultProps: imessageMockupSchema.parse({})
});

;// ./src/templates/business-marketing/InstagramAdMockup.tsx








const instagramAdMockupSchema = lib.z.object({
  username: lib.z.string().default("lapaasindia"),
  avatarUrl: lib.z.string().default("https://images.unsplash.com/photo-1550525811-e5869dd03032?w=150"),
  location: lib.z.string().default("Sponsored"),
  imageUrl: lib.z.string().default("https://images.unsplash.com/photo-1611162617474-5b21e879e113?w=800"),
  likes: lib.z.string().default("14,293"),
  caption: lib.z.string().default("The fastest way to edit videos is finally here. Drop your footage and let AI do the rest. Link in bio to try it for free! \u2728"),
  commentsCount: lib.z.string().default("428"),
  ctaText: lib.z.string().default("Learn More")
});
const InstagramAdMockup = ({
  username,
  avatarUrl,
  location,
  imageUrl,
  likes,
  caption,
  commentsCount,
  ctaText
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const pop = (0,esm.spring)({ frame: frame - 10, fps, config: { damping: 14 } });
  const op = (0,esm.interpolate)(frame - 10, [0, 10], [0, 1], { extrapolateRight: "clamp" });
  const cardWidth = isPortrait ? width * 0.9 : 500 * scale;
  const cardHeight = isPortrait ? height * 0.8 : 800 * scale;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground("#0f172a", backgroundControls), fontFamily: interFont, alignItems: "center", justifyContent: "center" }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      width: cardWidth,
      height: cardHeight,
      backgroundColor: "#fff",
      filter: `blur(${100 * scale}px)`,
      opacity: 0.1
    } }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      width: cardWidth,
      height: cardHeight,
      backgroundColor: "#fff",
      borderRadius: 24 * scale,
      boxShadow: "0 30px 60px rgba(0,0,0,0.5)",
      display: "flex",
      flexDirection: "column",
      overflow: "hidden",
      transform: `scale(${(0,esm.interpolate)(pop, [0, 1], [0.95, 1])}) translateY(${(1 - pop) * 50}px)`,
      opacity: op,
      position: "relative"
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: `${16 * scale}px ${20 * scale}px`
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 12 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            width: 44 * scale,
            height: 44 * scale,
            borderRadius: "50%",
            background: "linear-gradient(45deg, #f09433 0%, #e6683c 25%, #dc2743 50%, #cc2366 75%, #bc1888 100%)",
            padding: 2 * scale,
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: avatarUrl, style: { width: "100%", height: "100%", borderRadius: "50%", border: `2px solid #fff`, objectFit: "cover" } }) }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column" }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontSize: 16 * scale, fontWeight: 700, color: "#262626", display: "flex", alignItems: "center", gap: 4 * scale }, children: [
              username,
              /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: 14 * scale, height: 14 * scale, viewBox: "0 0 24 24", fill: "#3897f0", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm-1.9 14.7L6 12.6l1.5-1.5 2.6 2.6 6.4-6.4 1.5 1.5-7.9 7.9z" }) })
            ] }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 13 * scale, color: "#262626" }, children: location })
          ] })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { width: 24 * scale, height: 24 * scale, viewBox: "0 0 24 24", fill: "none", stroke: "#262626", strokeWidth: "2", children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("circle", { cx: "12", cy: "12", r: "1" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("circle", { cx: "19", cy: "12", r: "1" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("circle", { cx: "5", cy: "12", r: "1" })
        ] })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        width: "100%",
        flex: 1,
        backgroundColor: "#fafafa",
        position: "relative",
        overflow: "hidden"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: imageUrl, style: { width: "100%", height: "100%", objectFit: "cover" } }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          position: "absolute",
          bottom: 0,
          left: 0,
          right: 0,
          backgroundColor: "rgba(255,255,255,0.95)",
          padding: `${16 * scale}px ${20 * scale}px`,
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between",
          borderTop: "1px solid rgba(0,0,0,0.05)"
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 16 * scale, color: "#262626", fontWeight: 600 }, children: ctaText }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: 20 * scale, height: 20 * scale, viewBox: "0 0 24 24", fill: "none", stroke: "#262626", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "9 18 15 12 9 6" }) })
        ] })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { padding: `${16 * scale}px ${20 * scale}px ${8 * scale}px` }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 12 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", gap: 16 * scale }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "svg",
              {
                width: 28 * scale,
                height: 28 * scale,
                viewBox: "0 0 24 24",
                fill: frame > 40 ? "#ed4956" : "none",
                stroke: frame > 40 ? "#ed4956" : "#262626",
                strokeWidth: "2",
                style: {
                  transform: `scale(${(0,esm.interpolate)((0,esm.spring)({ frame: frame - 40, fps, config: { damping: 10 } }), [0, 0.5, 1], [1, 1.2, 1])})`
                },
                children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" })
              }
            ),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: 28 * scale, height: 28 * scale, viewBox: "0 0 24 24", fill: "none", stroke: "#262626", strokeWidth: "2", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z" }) }),
            /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { width: 28 * scale, height: 28 * scale, viewBox: "0 0 24 24", fill: "none", stroke: "#262626", strokeWidth: "2", children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("line", { x1: "22", y1: "2", x2: "11", y2: "13" }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)("polygon", { points: "22 2 15 22 11 13 2 9 22 2" })
            ] })
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: 28 * scale, height: 28 * scale, viewBox: "0 0 24 24", fill: "none", stroke: "#262626", strokeWidth: "2", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z" }) })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontSize: 15 * scale, fontWeight: 700, color: "#262626", marginBottom: 8 * scale }, children: [
          frame > 40 ? parseInt(likes.replace(/,/g, "")) + 1 : likes,
          " likes"
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontSize: 15 * scale, color: "#262626", lineHeight: 1.4, marginBottom: 8 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontWeight: 700, marginRight: 8 * scale }, children: username }),
          caption
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontSize: 14 * scale, color: "#8e8e8e", marginBottom: 12 * scale }, children: [
          "View all ",
          commentsCount,
          " comments"
        ] })
      ] })
    ] })
  ] });
};
registerTemplate({
  tags: [],
  id: "instagram-ad-mockup-01",
  name: "Instagram Ad Mockup",
  description: "A realistic simulation of an Instagram Feed Ad or post, complete with animated likes.",
  category: "platform-mockups",
  durationInFrames: 150,
  fps: 30,
  component: InstagramAdMockup,
  schema: instagramAdMockupSchema,
  defaultProps: instagramAdMockupSchema.parse({})
});

;// ./src/templates/business-marketing/InteractivePoll.tsx










const interactivePollSchema = lib.z.object({
  title: lib.z.string().default("What is your biggest marketing challenge?"),
  options: lib.z.array(lib.z.object({
    label: lib.z.string(),
    percentage: lib.z.number().min(0).max(100),
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { label: "Generating Leads", percentage: 45, color: "#3b82f6" },
    { label: "Content Creation", percentage: 30, color: "#10b981" },
    { label: "Budget Constraints", percentage: 15, color: "#f59e0b" },
    { label: "Attribution", percentage: 10, color: "#ef4444" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  barBgColor: lib.z.string().default("rgba(255,255,255,0.1)")
});
const InteractivePoll = ({
  title,
  options,
  backgroundColor,
  textColor,
  barBgColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  const sortedOptions = [...options].sort((a, b) => b.percentage - a.percentage);
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 150 * scale : 120 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 64 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em",
          lineHeight: 1.2
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 350 * scale : 300 * scale,
      left: paddingX,
      width: availableWidth,
      display: "flex",
      flexDirection: "column",
      gap: 30 * scale
    }, children: sortedOptions.map((opt, i) => {
      const delay = 30 + i * 15;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      const fillProgress = (0,esm.spring)({ frame: frame - (delay + 10), fps, config: { damping: 20, mass: 1.5 } });
      const currentPercent = fillProgress * opt.percentage;
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        transform: `translateY(${(1 - pop) * 30}px)`,
        opacity: op,
        display: "flex",
        flexDirection: "column",
        gap: 12 * scale
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "flex-end" }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 24 * scale,
            fontWeight: 600,
            color: COLORS.textPrimary
          }, children: opt.label }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
            fontSize: 28 * scale,
            fontWeight: 800,
            fontFamily: interFont,
            color: opt.color
          }, children: [
            Math.round(currentPercent),
            "%"
          ] })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          width: "100%",
          height: 24 * scale,
          backgroundColor: barBgColor,
          borderRadius: 12 * scale,
          overflow: "hidden",
          position: "relative"
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          top: 0,
          left: 0,
          bottom: 0,
          width: `${currentPercent}%`,
          backgroundColor: opt.color,
          borderRadius: 12 * scale,
          boxShadow: `0 0 20px ${opt.color}80`
        } }) })
      ] }, i);
    }) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      bottom: 80 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      opacity: (0,esm.interpolate)(frame - 100, [0, 20], [0, 1], { extrapolateRight: "clamp" }),
      fontSize: 24 * scale,
      fontWeight: 600,
      color: COLORS.textMuted,
      textTransform: "uppercase",
      letterSpacing: "0.1em"
    }, children: "Vote in the comments below \u{1F447}" })
  ] });
};
registerTemplate({
  tags: [],
  id: "interactive-poll-01",
  name: "Dynamic Poll Results",
  description: "An animated bar chart showing poll results, great for engagement.",
  category: "business-marketing",
  durationInFrames: 180,
  fps: 30,
  component: InteractivePoll,
  schema: interactivePollSchema,
  defaultProps: interactivePollSchema.parse({})
});

;// ./src/templates/business-marketing/LinkedInPostMockup.tsx








const linkedinPostMockupSchema = lib.z.object({
  name: lib.z.string().default("Sarah Jenkins"),
  headline: lib.z.string().default("CMO at TechFlow | B2B Growth Strategy"),
  time: lib.z.string().default("2h \u2022 Edited \u2022 \u{1F310}"),
  avatarUrl: lib.z.string().default("https://images.unsplash.com/photo-1494790108377-be9c29b29330?w=150"),
  content: lib.z.string().default("I\u2019m thrilled to announce that our marketing team has fully transitioned to AI-driven workflows.\n\nHere are 3 things we learned:\n1. Video production time dropped by 80%\n2. Team morale is at an all-time high\n3. Our ROI has doubled\n\nWhat tools are you using to scale your content? \u{1F447}"),
  likesCount: lib.z.string().default("1,482"),
  commentsCount: lib.z.string().default("342 comments"),
  repostsCount: lib.z.string().default("184 reposts"),
  backgroundColor: lib.z.string().default("#f3f2ef"),
  textColor: lib.z.string().default("#000000")
});
const LinkedInPostMockup = ({
  name,
  headline,
  time,
  avatarUrl,
  content,
  likesCount,
  commentsCount,
  repostsCount
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const pop = (0,esm.spring)({ frame: frame - 10, fps, config: { damping: 14, mass: 1.2 } });
  const op = (0,esm.interpolate)(frame - 10, [0, 10], [0, 1], { extrapolateRight: "clamp" });
  const cardWidth = isPortrait ? width * 0.9 : 700 * scale;
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground("#f3f2ef", backgroundControls), fontFamily: interFont, alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
    width: cardWidth,
    backgroundColor: "#ffffff",
    borderRadius: 12 * scale,
    border: "1px solid #e0dfdc",
    padding: `${16 * scale}px`,
    display: "flex",
    flexDirection: "column",
    boxShadow: "0 4px 12px rgba(0,0,0,0.05)",
    transform: `scale(${(0,esm.interpolate)(pop, [0, 1], [0.95, 1])}) translateY(${(1 - pop) * 30}px)`,
    opacity: op
  }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "flex-start", justifyContent: "space-between", marginBottom: 12 * scale }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", gap: 12 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: avatarUrl, style: { width: 48 * scale, height: 48 * scale, borderRadius: "50%", objectFit: "cover" } }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column" }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontSize: 16 * scale, fontWeight: 700, color: "#000000", display: "flex", alignItems: "center", gap: 6 * scale }, children: [
            name,
            /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { color: "#666666", fontSize: 14 * scale, fontWeight: 400 }, children: "\u2022 1st" })
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 14 * scale, color: "#666666", marginTop: 2 * scale, maxWidth: 450 * scale, whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" }, children: headline }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 12 * scale, color: "#666666", marginTop: 2 * scale }, children: time })
        ] })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 8 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { color: "#0a66c2", fontSize: 16 * scale, fontWeight: 700, display: "flex", alignItems: "center", gap: 4 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 16 * scale, height: 16 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M14 12V8h-4v4H6v4h4v4h4v-4h4v-4h-4z" }) }),
          "Follow"
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 24 * scale, height: 24 * scale, fill: "#666666", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M14 12a2 2 0 11-4 0 2 2 0 014 0zM7 12a2 2 0 11-4 0 2 2 0 014 0zm14 0a2 2 0 11-4 0 2 2 0 014 0z" }) })
      ] })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      fontSize: 16 * scale,
      lineHeight: 1.5,
      color: "#000000",
      whiteSpace: "pre-wrap",
      marginBottom: 16 * scale
    }, children: content }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      fontSize: 12 * scale,
      color: "#666666",
      paddingBottom: 8 * scale,
      borderBottom: "1px solid #e0dfdc",
      marginBottom: 8 * scale
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 4 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex" }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 16 * scale, height: 16 * scale, borderRadius: "50%", backgroundColor: "#0a66c2", display: "flex", alignItems: "center", justifyContent: "center", color: "#fff", fontSize: 10 * scale, zIndex: 3 }, children: "\u{1F44D}" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 16 * scale, height: 16 * scale, borderRadius: "50%", backgroundColor: "#df704d", display: "flex", alignItems: "center", justifyContent: "center", color: "#fff", fontSize: 10 * scale, marginLeft: -6 * scale, zIndex: 2, border: "1px solid #fff" }, children: "\u{1F4A1}" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 16 * scale, height: 16 * scale, borderRadius: "50%", backgroundColor: "#5fa453", display: "flex", alignItems: "center", justifyContent: "center", color: "#fff", fontSize: 10 * scale, marginLeft: -6 * scale, zIndex: 1, border: "1px solid #fff" }, children: "\u{1F44F}" })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { marginLeft: 4 * scale }, children: likesCount })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", gap: 8 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { children: commentsCount }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { children: "\u2022" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { children: repostsCount })
      ] })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      paddingTop: 4 * scale
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 8 * scale, color: frame > 40 ? "#0a66c2" : "#666666", fontWeight: 600, fontSize: 14 * scale, transform: `scale(${(0,esm.interpolate)((0,esm.spring)({ frame: frame - 40, fps, config: { damping: 10 } }), [0, 0.5, 1], [1, 1.1, 1])})` }, children: [
        frame > 40 ? /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 24 * scale, height: 24 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm3.1 14.1l-4.1-4.1V7h2v4.2l3.5 3.5-1.4 1.4z" }) }) : /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 24 * scale, height: 24 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M21 12v-1.12l-1.85-.26c-.16-.48-.38-.93-.66-1.34l1.1-1.48-2.12-2.12-1.48 1.1c-.41-.28-.86-.5-1.34-.66L14.39 4h-4.78l-.26 1.85c-.48.16-.93.38-1.34.66l-1.48-1.1-2.12 2.12 1.1 1.48c-.28.41-.5.86-.66 1.34L3 10.88V12h2v4l3.5 3.5 1.4-1.4L7.5 16h9l-2.4 2.1 1.4 1.4L19 16v-4h2zM7 11c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z" }) }),
        "Like"
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 8 * scale, color: "#666666", fontWeight: 600, fontSize: 14 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 24 * scale, height: 24 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M7 9h10v1H7zm0 4h7v-1H7zm11-9H6a3 3 0 00-3 3v13.62l4.81-2.62H18a3 3 0 003-3V7a3 3 0 00-3-3zm1 10a1 1 0 01-1 1H7.39l-2.39 1.3V7a1 1 0 011-1h12a1 1 0 011 1z" }) }),
        "Comment"
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 8 * scale, color: "#666666", fontWeight: 600, fontSize: 14 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 24 * scale, height: 24 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M23 12l-4.6 5.3v-3.8H12v-3h6.4V6.7zM6.4 13.5v3.8L1.8 12l4.6-5.3v3.8H13v3z" }) }),
        "Repost"
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 8 * scale, color: "#666666", fontWeight: 600, fontSize: 14 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 24 * scale, height: 24 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M21 3L0 10l7.66 4.26L16 8l-6.26 8.34L14 24l7-21z" }) }),
        "Send"
      ] })
    ] })
  ] }) });
};
registerTemplate({
  tags: [],
  id: "linkedin-post-mockup-01",
  name: "LinkedIn Post Mockup",
  description: "A professional B2B LinkedIn post mockup, perfect for business marketing.",
  category: "platform-mockups",
  durationInFrames: 150,
  fps: 30,
  component: LinkedInPostMockup,
  schema: linkedinPostMockupSchema,
  defaultProps: linkedinPostMockupSchema.parse({})
});

;// ./src/templates/business-marketing/MarketShareBlocks.tsx










const marketShareBlocksSchema = lib.z.object({
  title: lib.z.string().default("Market Dominance"),
  subtitle: lib.z.string().default("US Search Engine Market Share"),
  shares: lib.z.array(lib.z.object({
    company: lib.z.string(),
    percentage: lib.z.number(),
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { company: "Google", percentage: 88, color: "#3b82f6" },
    { company: "Bing", percentage: 7, color: "#10b981" },
    { company: "Yahoo", percentage: 3, color: "#8b5cf6" },
    { company: "Other", percentage: 2, color: "#64748b" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary)
});
const MarketShareBlocks = ({
  title,
  subtitle,
  shares,
  backgroundColor,
  textColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalPercentage = shares.reduce((sum, s) => sum + s.percentage, 0);
  const sortedShares = [...shares].sort((a, b) => b.percentage - a.percentage);
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const paddingY = isPortrait ? 250 * scale : 200 * scale;
  const blockAreaWidth = width - paddingX * 2;
  const blockAreaHeight = height - paddingY - 100 * scale;
  const flexDirection = isPortrait ? "column" : "row";
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: paddingX,
      width: blockAreaWidth,
      textAlign: isPortrait ? "center" : "left",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 60 : 72) * scale,
            margin: 0,
            letterSpacing: "-0.02em"
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 24 : 32) * scale,
            opacity: 0.6,
            marginTop: 10 * scale
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: paddingY,
      left: paddingX,
      width: blockAreaWidth,
      height: blockAreaHeight,
      display: "flex",
      flexDirection,
      gap: 8 * scale
    }, children: sortedShares.map((share, i) => {
      const normalizedPercent = share.percentage / totalPercentage * 100;
      const delay = 20 + i * 15;
      const grow = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
      const isTooSmall = normalizedPercent < 10;
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        // Animate flex-basis to make them grow into their final size
        flexBasis: `${grow * normalizedPercent}%`,
        height: "100%",
        backgroundColor: share.color,
        borderRadius: 16 * scale,
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        position: "relative",
        overflow: "hidden",
        boxShadow: "inset 0 0 20px rgba(0,0,0,0.2)",
        transition: "opacity 0.2s",
        opacity: grow > 0.1 ? 1 : 0
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: "linear-gradient(135deg, rgba(255,255,255,0.2) 0%, transparent 100%)",
          zIndex: 0
        } }),
        !isTooSmall && grow > 0.5 && /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          zIndex: 1,
          textAlign: "center",
          padding: 10 * scale
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
            fontSize: (isPortrait ? 48 : 64) * scale,
            fontWeight: 900,
            fontFamily: interFont,
            color: "#fff",
            textShadow: "0 4px 10px rgba(0,0,0,0.3)"
          }, children: [
            share.percentage,
            "%"
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: (isPortrait ? 20 : 28) * scale,
            fontWeight: 700,
            color: COLORS.textPrimary,
            textTransform: "uppercase",
            letterSpacing: "0.05em"
          }, children: share.company })
        ] })
      ] }, i);
    }) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      bottom: 40 * scale,
      left: paddingX,
      width: blockAreaWidth,
      display: "flex",
      justifyContent: "center",
      flexWrap: "wrap",
      gap: 20 * scale,
      opacity: (0,esm.interpolate)(frame - 100, [0, 10], [0, 1], { extrapolateRight: "clamp" })
    }, children: sortedShares.filter((s) => s.percentage / totalPercentage * 100 < 10).map((share, i) => /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 10 * scale }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 16 * scale, height: 16 * scale, borderRadius: "50%", backgroundColor: share.color } }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontSize: 16 * scale, color: COLORS.textSecondary }, children: [
        share.company,
        " (",
        share.percentage,
        "%)"
      ] })
    ] }, i)) })
  ] });
};
registerTemplate({
  tags: [],
  id: "market-share-blocks-01",
  name: "Market Share Blocks",
  description: "A stacked block diagram showing proportional data, great for market share or demographics.",
  category: "data-visualization",
  durationInFrames: 180,
  fps: 30,
  component: MarketShareBlocks,
  schema: marketShareBlocksSchema,
  defaultProps: marketShareBlocksSchema.parse({})
});

;// ./src/templates/business-marketing/MarketingROICard.tsx










const marketingRoiSchema = lib.z.object({
  title: lib.z.string().default("Q3 Marketing ROI"),
  subtitle: lib.z.string().default("Campaign Performance Dashboard"),
  metrics: lib.z.array(lib.z.object({
    label: lib.z.string(),
    value: lib.z.string(),
    trend: lib.z.number(),
    // positive is good, negative is bad
    icon: lib.z.string(),
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { label: "Total Spend", value: "$45,000", trend: 5.2, icon: "\u{1F4B8}", color: "#64748b" },
    { label: "New Leads", value: "2,845", trend: 14.8, icon: "\u{1F3AF}", color: "#3b82f6" },
    { label: "Conversions", value: "412", trend: 22.4, icon: "\u{1F3C6}", color: "#10b981" },
    { label: "Cost Per Acq", value: "$109", trend: -8.5, icon: "\u{1F4C9}", color: "#8b5cf6" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  cardBgColor: lib.z.string().default(COLORS.surface)
});
const MarketingROICard = ({
  title,
  subtitle,
  metrics,
  backgroundColor,
  textColor,
  cardBgColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalMetrics = metrics.length;
  const cols = isPortrait ? 1 : totalMetrics > 4 ? 3 : 2;
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const gap = 30 * scale;
  const startY = isPortrait ? height * 0.25 : height * 0.3;
  const availableWidth = width - paddingX * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 100 * scale,
      left: paddingX,
      width: availableWidth,
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 60 : 72) * scale,
            margin: 0,
            letterSpacing: "-0.02em"
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 24 : 32) * scale,
            opacity: 0.6,
            marginTop: 10 * scale
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: startY,
      left: paddingX,
      width: availableWidth,
      display: "grid",
      gridTemplateColumns: `repeat(${cols}, 1fr)`,
      gap
    }, children: metrics.map((metric, i) => {
      const delay = 15 + i * 8;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      const isPositive = metric.trend > 0;
      const isCostMetric = metric.label.toLowerCase().includes("cost");
      const isGood = isCostMetric ? !isPositive : isPositive;
      const trendColor = isGood ? "#10b981" : "#ef4444";
      const trendIcon = isPositive ? "\u2191" : "\u2193";
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        backgroundColor: cardBgColor,
        borderRadius: 24 * scale,
        padding: 30 * scale,
        transform: `scale(${(0,esm.interpolate)(pop, [0, 1], [0.9, 1])}) translateY(${(1 - pop) * 30}px)`,
        opacity: op,
        boxShadow: "0 10px 30px rgba(0,0,0,0.1)",
        border: `1px solid rgba(255,255,255,0.05)`,
        borderTop: `4px solid ${metric.color}`,
        display: "flex",
        flexDirection: "column",
        gap: 16 * scale,
        position: "relative",
        overflow: "hidden"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          height: 100 * scale,
          background: `linear-gradient(180deg, ${metric.color}20 0%, transparent 100%)`,
          zIndex: 0
        } }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "flex-start", zIndex: 1 }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: {
            fontSize: 18 * scale,
            fontWeight: 600,
            color: COLORS.textSecondary,
            textTransform: "uppercase",
            letterSpacing: "0.05em"
          }, children: metric.label }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            width: 48 * scale,
            height: 48 * scale,
            backgroundColor: `${metric.color}20`,
            borderRadius: 12 * scale,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            fontSize: 24 * scale
          }, children: metric.icon })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "baseline", gap: 16 * scale, zIndex: 1 }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: {
            fontSize: (isPortrait ? 48 : 56) * scale,
            fontWeight: 800,
            fontFamily: interFont,
            letterSpacing: "-0.02em",
            color: "#fff"
          }, children: metric.value }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("span", { style: {
            fontSize: 16 * scale,
            fontWeight: 700,
            color: trendColor,
            backgroundColor: `${trendColor}20`,
            padding: `${4 * scale}px ${10 * scale}px`,
            borderRadius: 20 * scale,
            display: "flex",
            alignItems: "center",
            gap: 4 * scale
          }, children: [
            trendIcon,
            " ",
            Math.abs(metric.trend),
            "%"
          ] })
        ] })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "marketing-roi-card-01",
  name: "Marketing ROI Dashboard",
  description: "A clean analytics dashboard showing key performance indicators (KPIs) and trends.",
  category: "business-marketing",
  durationInFrames: 150,
  fps: 30,
  component: MarketingROICard,
  schema: marketingRoiSchema,
  defaultProps: marketingRoiSchema.parse({})
});

;// ./src/templates/business-marketing/MultiLinkOutro.tsx










const multiLinkOutroSchema = lib.z.object({
  title: lib.z.string().default("Connect With Us"),
  links: lib.z.array(lib.z.object({
    platform: lib.z.string(),
    handle: lib.z.string(),
    url: lib.z.string(),
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { platform: "Website", handle: "lapaas.com", url: "https://lapaas.com", color: "#10b981" },
    { platform: "YouTube", handle: "@LapaasIndia", url: "https://youtube.com/lapaasindia", color: "#ef4444" },
    { platform: "Twitter", handle: "@SahilKhanna", url: "https://twitter.com/sahilkhanna", color: "#3b82f6" },
    { platform: "LinkedIn", handle: "Lapaas India", url: "https://linkedin.com/company/lapaas", color: "#0ea5e9" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary)
});
const MultiLinkOutro = ({
  title,
  links,
  backgroundColor,
  textColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor, justifyContent: "center", alignItems: "center" }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      transform: `translateY(${(1 - titleY) * -50}px)`,
      opacity: titleOpacity,
      marginBottom: 60 * scale
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 80 : 96) * scale,
          margin: 0,
          letterSpacing: "-0.02em",
          textAlign: "center"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      display: "flex",
      flexDirection: "column",
      gap: 24 * scale,
      width: isPortrait ? availableWidth : 600 * scale
    }, children: links.map((link, i) => {
      const delay = 20 + i * 8;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 12, mass: 1.2 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        backgroundColor: COLORS.surfaceLight,
        borderRadius: 16 * scale,
        padding: `${20 * scale}px ${30 * scale}px`,
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        transform: `scale(${pop}) translateY(${(1 - pop) * 30}px)`,
        opacity: op,
        border: `1px solid ${COLORS.borderLight}`,
        borderLeft: `6px solid ${link.color}`,
        boxShadow: `0 10px 30px ${link.color}20`
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 16 * scale,
            color: COLORS.textMuted,
            textTransform: "uppercase",
            letterSpacing: "0.1em",
            marginBottom: 4 * scale,
            fontWeight: 600
          }, children: link.platform }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 28 * scale,
            fontWeight: 700,
            color: "#fff"
          }, children: link.handle })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          width: 40 * scale,
          height: 40 * scale,
          borderRadius: "50%",
          backgroundColor: `${link.color}30`,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          color: link.color
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { width: 24 * scale, height: 24 * scale, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round", children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("line", { x1: "5", y1: "12", x2: "19", y2: "12" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "12 5 19 12 12 19" })
        ] }) })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "multi-link-outro-01",
  name: "Multi-Link End Screen",
  description: "An outro card displaying multiple calls to action and links neatly stacked.",
  category: "social-hooks",
  durationInFrames: 150,
  fps: 30,
  component: MultiLinkOutro,
  schema: multiLinkOutroSchema,
  defaultProps: multiLinkOutroSchema.parse({})
});

;// ./src/templates/business-marketing/PricingComparisonTable.tsx










const pricingComparisonSchema = lib.z.object({
  title: lib.z.string().default("Choose Your Plan"),
  plans: lib.z.array(lib.z.object({
    name: lib.z.string(),
    price: lib.z.string(),
    period: lib.z.string(),
    features: lib.z.array(lib.z.string()),
    isPopular: lib.z.boolean().default(false),
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    {
      name: "Basic",
      price: "$29",
      period: "/mo",
      color: "#64748b",
      features: ["1 User", "10GB Storage", "Email Support"]
    },
    {
      name: "Pro",
      price: "$99",
      period: "/mo",
      color: "#3b82f6",
      isPopular: true,
      features: ["5 Users", "100GB Storage", "24/7 Support", "Analytics"]
    },
    {
      name: "Enterprise",
      price: "$299",
      period: "/mo",
      color: "#10b981",
      features: ["Unlimited Users", "1TB Storage", "Dedicated Rep", "Custom API"]
    }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  cardBgColor: lib.z.string().default(COLORS.surface)
});
const PricingComparisonTable = ({
  title,
  plans,
  backgroundColor,
  textColor,
  cardBgColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalPlans = plans.length;
  const gap = 40 * scale;
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  const cardWidth = isPortrait ? availableWidth : (availableWidth - gap * (totalPlans - 1)) / totalPlans;
  const cardHeight = isPortrait ? height * 0.7 / totalPlans : height * 0.6;
  const startY = isPortrait ? height * 0.2 : height * 0.25;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 80 * scale : 80 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -50}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: startY,
      left: paddingX,
      width: availableWidth,
      display: "flex",
      flexDirection: isPortrait ? "column" : "row",
      justifyContent: "center",
      alignItems: isPortrait ? "center" : "stretch",
      gap
    }, children: plans.map((plan, i) => {
      const delay = 15 + i * 15;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 12, mass: 1.2 } });
      const isPopular = plan.isPopular;
      const popularScale = isPopular && !isPortrait ? 1.05 : 1;
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        width: isPortrait ? "100%" : cardWidth,
        height: isPortrait ? "auto" : cardHeight,
        backgroundColor: cardBgColor,
        borderRadius: 24 * scale,
        padding: isPortrait ? 30 * scale : 40 * scale,
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        transform: `scale(${pop * popularScale}) translateY(${(1 - pop) * 50}px)`,
        opacity: (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" }),
        boxShadow: isPopular ? `0 20px 40px ${plan.color}40` : "0 10px 30px rgba(0,0,0,0.2)",
        border: isPopular ? `2px solid ${plan.color}` : "1px solid rgba(255,255,255,0.1)",
        position: "relative"
      }, children: [
        isPopular && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          top: -16 * scale,
          backgroundColor: plan.color,
          color: "#fff",
          padding: `${6 * scale}px ${16 * scale}px`,
          borderRadius: 20 * scale,
          fontSize: 14 * scale,
          fontWeight: 800,
          letterSpacing: "0.05em",
          textTransform: "uppercase"
        }, children: "MOST POPULAR" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: 24 * scale,
          fontWeight: 700,
          color: plan.color,
          marginBottom: 16 * scale,
          textTransform: "uppercase",
          letterSpacing: "0.1em"
        }, children: plan.name }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "baseline", marginBottom: 30 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: (isPortrait ? 48 : 60) * scale, fontWeight: 900, fontFamily: interFont }, children: plan.price }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 20 * scale, color: COLORS.textSecondary, marginLeft: 8 * scale }, children: plan.period })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: "100%", height: 1, backgroundColor: "rgba(255,255,255,0.1)", marginBottom: 30 * scale } }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: 16 * scale, width: "100%", flex: 1 }, children: plan.features.map((feat, j) => {
          const featDelay = delay + 10 + j * 5;
          const featOp = (0,esm.interpolate)(frame - featDelay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
          const featX = (0,esm.spring)({ frame: frame - featDelay, fps, config: { damping: 14 } });
          return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
            display: "flex",
            alignItems: "center",
            gap: 12 * scale,
            opacity: featOp,
            transform: `translateX(${(1 - featX) * -20}px)`
          }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: 20 * scale, height: 20 * scale, viewBox: "0 0 24 24", fill: "none", stroke: plan.color, strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "20 6 9 17 4 12" }) }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 18 * scale, fontWeight: 500, color: COLORS.textPrimary }, children: feat })
          ] }, j);
        }) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          marginTop: 30 * scale,
          width: "100%",
          padding: `${16 * scale}px 0`,
          backgroundColor: isPopular ? plan.color : "rgba(255,255,255,0.1)",
          borderRadius: 12 * scale,
          textAlign: "center",
          fontSize: 18 * scale,
          fontWeight: 700,
          color: isPopular ? "#fff" : plan.color,
          transition: "all 0.2s"
        }, children: "Get Started" })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "pricing-comparison-01",
  name: "Pricing Comparison Table",
  description: "A responsive pricing tier graphic. Add as many plans as you need and it will auto-layout.",
  category: "business-marketing",
  durationInFrames: 210,
  fps: 30,
  component: PricingComparisonTable,
  schema: pricingComparisonSchema,
  defaultProps: pricingComparisonSchema.parse({})
});

;// ./src/templates/business-marketing/PricingTiers.tsx










const pricingTiersSchema = lib.z.object({
  title: lib.z.string().default("Pricing"),
  subtitle: lib.z.string().default("Simple, transparent pricing for everyone."),
  tiers: lib.z.array(lib.z.object({
    name: lib.z.string(),
    price: lib.z.string(),
    period: lib.z.string(),
    features: lib.z.array(lib.z.string()),
    isPopular: lib.z.boolean().default(false),
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    {
      name: "Starter",
      price: "$29",
      period: "/mo",
      color: "#64748b",
      features: ["1 User", "10GB Storage", "Email Support"]
    },
    {
      name: "Pro",
      price: "$99",
      period: "/mo",
      color: "#3b82f6",
      isPopular: true,
      features: ["5 Users", "100GB Storage", "24/7 Support", "Analytics"]
    },
    {
      name: "Enterprise",
      price: "$299",
      period: "/mo",
      color: "#10b981",
      features: ["Unlimited Users", "1TB Storage", "Dedicated Rep", "Custom API"]
    }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  cardBgColor: lib.z.string().default(COLORS.surface)
});
const PricingTiers = ({
  title,
  subtitle,
  tiers,
  backgroundColor,
  textColor,
  cardBgColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalTiers = tiers.length;
  const cols = isPortrait ? 1 : Math.min(3, totalTiers);
  const rows = Math.ceil(totalTiers / cols);
  const paddingX = isPortrait ? 40 * scale : 120 * scale;
  const gap = isPortrait ? 20 * scale : 40 * scale;
  const availableWidth = width - paddingX * 2;
  const verticalOffset = rows > 1 ? -30 : -50;
  const topPos = rows > 1 ? "48%" : "50%";
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 80 * scale : 60 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 60 : 72) * scale,
            margin: 0,
            letterSpacing: "-0.02em",
            color: textColor
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 24 : 32) * scale,
            opacity: 0.6,
            marginTop: 10 * scale
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: topPos,
      left: "50%",
      transform: `translate(-50%, ${verticalOffset}%)`,
      display: "grid",
      gridTemplateColumns: `repeat(${cols}, 1fr)`,
      gap,
      width: availableWidth,
      maxWidth: 1400 * scale
    }, children: tiers.map((tier, i) => {
      const delay = 15 + i * 5;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        backgroundColor: cardBgColor,
        borderRadius: 24 * scale,
        padding: isPortrait ? 24 * scale : 40 * scale,
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        textAlign: "center",
        transform: `translateY(${(1 - pop) * 100}px)`,
        opacity: op,
        boxShadow: tier.isPopular ? `0 20px 40px ${tier.color}40` : "0 20px 40px rgba(0,0,0,0.2)",
        borderTop: `4px solid ${tier.color}`,
        position: "relative",
        overflow: "hidden"
      }, children: [
        tier.isPopular && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          top: 16 * scale,
          right: -32 * scale,
          backgroundColor: tier.color,
          color: "#fff",
          fontSize: 12 * scale,
          fontWeight: 700,
          padding: `4px ${40 * scale}px`,
          transform: "rotate(45deg)",
          textTransform: "uppercase",
          letterSpacing: "0.05em"
        }, children: "Popular" }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: (isPortrait ? 24 : 28) * scale,
          fontWeight: 800,
          fontFamily: interFont,
          color: tier.color,
          marginBottom: 16 * scale
        }, children: tier.name }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "baseline", marginBottom: 30 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: (isPortrait ? 48 : 60) * scale, fontWeight: 900, fontFamily: interFont }, children: tier.price }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 20 * scale, color: COLORS.textSecondary, marginLeft: 8 * scale }, children: tier.period })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: "100%", height: 1, backgroundColor: "rgba(255,255,255,0.1)", marginBottom: 30 * scale } }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: 16 * scale, width: "100%", flex: 1 }, children: tier.features.map((feat, j) => {
          const featDelay = delay + 10 + j * 5;
          const featOp = (0,esm.interpolate)(frame - featDelay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
          const featX = (0,esm.spring)({ frame: frame - featDelay, fps, config: { damping: 14 } });
          return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
            display: "flex",
            alignItems: "center",
            gap: 12 * scale,
            opacity: featOp,
            transform: `translateX(${(1 - featX) * -20}px)`
          }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: 20 * scale, height: 20 * scale, viewBox: "0 0 24 24", fill: "none", stroke: tier.color, strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "20 6 9 17 4 12" }) }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 18 * scale, fontWeight: 500, color: COLORS.textPrimary }, children: feat })
          ] }, j);
        }) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          marginTop: 30 * scale,
          width: "100%",
          padding: `${16 * scale}px 0`,
          backgroundColor: tier.isPopular ? tier.color : "rgba(255,255,255,0.1)",
          borderRadius: 12 * scale,
          textAlign: "center",
          fontSize: 18 * scale,
          fontWeight: 700,
          color: tier.isPopular ? "#fff" : tier.color,
          transition: "all 0.2s"
        }, children: "Get Started" })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "pricing-tiers-01",
  name: "Pricing Tiers Grid",
  description: "A responsive pricing grid that auto-adjusts based on the number of plans.",
  category: "business-marketing",
  durationInFrames: 150,
  fps: 30,
  component: PricingTiers,
  schema: pricingTiersSchema,
  defaultProps: pricingTiersSchema.parse({})
});

;// ./src/templates/business-marketing/ProductFeaturesGrid.tsx










const productFeaturesGridSchema = lib.z.object({
  title: lib.z.string().default("Why Choose Us"),
  subtitle: lib.z.string().default("Everything you need to scale your business."),
  features: lib.z.array(lib.z.object({
    title: lib.z.string(),
    desc: lib.z.string(),
    iconUrl: lib.z.string(),
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { title: "Global Reach", desc: "Deploy to 120+ edge locations instantly.", iconUrl: "https://cdn-icons-png.flaticon.com/512/888/888879.png", color: "#3b82f6" },
    { title: "Zero Downtime", desc: "Our architecture ensures you never go offline.", iconUrl: "https://cdn-icons-png.flaticon.com/512/888/888885.png", color: "#10b981" },
    { title: "Auto Scaling", desc: "Handles sudden traffic spikes without breaking a sweat.", iconUrl: "https://cdn-icons-png.flaticon.com/512/888/888891.png", color: "#f59e0b" },
    { title: "Ironclad Security", desc: "Enterprise-grade encryption for all your data.", iconUrl: "https://cdn-icons-png.flaticon.com/512/888/888898.png", color: "#ef4444" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  cardBgColor: lib.z.string().default(COLORS.surface)
});
const ProductFeaturesGrid = ({
  title,
  subtitle,
  features,
  backgroundColor,
  textColor,
  cardBgColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalFeatures = features.length;
  const cols = isPortrait ? 1 : Math.min(2, Math.ceil(Math.sqrt(totalFeatures)));
  const paddingX = isPortrait ? 40 * scale : 120 * scale;
  const gap = isPortrait ? 20 * scale : 40 * scale;
  const availableWidth = width - paddingX * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 60 : 72) * scale,
            margin: 0,
            letterSpacing: "-0.02em",
            color: textColor
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 24 : 32) * scale,
            opacity: 0.6,
            marginTop: 10 * scale
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -40%)",
      display: "grid",
      gridTemplateColumns: `repeat(${cols}, 1fr)`,
      gap,
      width: availableWidth,
      maxWidth: 1400 * scale
    }, children: features.map((feature, i) => {
      const delay = 15 + i * 5;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        backgroundColor: cardBgColor,
        borderRadius: 24 * scale,
        padding: isPortrait ? 24 * scale : 40 * scale,
        display: "flex",
        alignItems: "center",
        textAlign: "left",
        transform: `translateY(${(1 - pop) * 100}px)`,
        opacity: op,
        boxShadow: "0 20px 40px rgba(0,0,0,0.2)",
        borderLeft: `4px solid ${feature.color}`,
        position: "relative",
        overflow: "hidden",
        gap: 24 * scale
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          width: (isPortrait ? 60 : 80) * scale,
          height: (isPortrait ? 60 : 80) * scale,
          borderRadius: "50%",
          backgroundColor: `${feature.color}20`,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexShrink: 0,
          padding: 16 * scale
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Img,
          {
            src: feature.iconUrl,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "contain"
              // A trick to colorize black PNGs in Remotion (or just use colored ones)
              // filter: `drop-shadow(0 0 0 ${feature.color})`,
            }
          }
        ) }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { flex: 1 }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: (isPortrait ? 24 : 28) * scale,
            fontWeight: 800,
            fontFamily: interFont,
            color: "#fff",
            marginBottom: 8 * scale
          }, children: feature.title }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: (isPortrait ? 16 : 18) * scale,
            color: COLORS.textSecondary,
            lineHeight: 1.4
          }, children: feature.desc })
        ] })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "product-features-grid-01",
  name: "Product Features Grid",
  description: "A clean, responsive grid highlighting core features with icons and descriptions.",
  category: "business-marketing",
  durationInFrames: 150,
  fps: 30,
  component: ProductFeaturesGrid,
  schema: productFeaturesGridSchema,
  defaultProps: productFeaturesGridSchema.parse({})
});

;// ./src/templates/business-marketing/ProductShowcase.tsx










const productShowcaseSchema = lib.z.object({
  title: lib.z.string().default("New Release"),
  productName: lib.z.string().default("Lapaas Editor Pro"),
  description: lib.z.string().default("The fastest way to create viral short-form content with AI. Now with automated B-roll and smart captions."),
  productImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=1000"),
  highlights: lib.z.array(lib.z.string()).default([
    "10x Faster Rendering",
    "Auto Silence Removal",
    "Dynamic B-Roll",
    "1-Click Export"
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  primaryColor: lib.z.string().default("#3b82f6")
});
const ProductShowcase = ({
  title,
  productName,
  description,
  productImageUrl,
  highlights,
  backgroundColor,
  textColor,
  primaryColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  const imageWidth = isPortrait ? availableWidth : availableWidth * 0.45;
  const contentWidth = isPortrait ? availableWidth : availableWidth * 0.5;
  const imageScale = (0,esm.spring)({ frame: frame - 15, fps, config: { damping: 14, mass: 1.2 } });
  const slowZoom = (0,esm.interpolate)(frame, [0, 300], [1, 1.1]);
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
    position: "absolute",
    top: isPortrait ? 100 * scale : "50%",
    left: paddingX,
    width: availableWidth,
    display: "flex",
    flexDirection: isPortrait ? "column" : "row",
    alignItems: "center",
    justifyContent: "space-between",
    transform: isPortrait ? "none" : "translateY(-50%)",
    gap: isPortrait ? 40 * scale : 0
  }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      width: contentWidth,
      display: "flex",
      flexDirection: "column",
      alignItems: isPortrait ? "center" : "flex-start",
      textAlign: isPortrait ? "center" : "left"
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        fontSize: 24 * scale,
        fontWeight: 700,
        color: primaryColor,
        textTransform: "uppercase",
        letterSpacing: "0.1em",
        marginBottom: 16 * scale,
        transform: `translateY(${(1 - titleY) * -20}px)`,
        opacity: titleOpacity
      }, children: title }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: productName,
          style: {
            fontFamily: interFont,
            fontWeight: 900,
            fontSize: (isPortrait ? 64 : 80) * scale,
            margin: 0,
            letterSpacing: "-0.03em",
            lineHeight: 1.1,
            marginBottom: 24 * scale,
            transform: `translateY(${(1 - titleY) * -30}px)`,
            opacity: titleOpacity
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        fontSize: 22 * scale,
        color: COLORS.textSecondary,
        lineHeight: 1.5,
        marginBottom: 40 * scale,
        maxWidth: 600 * scale,
        transform: `translateY(${(1 - titleY) * -40}px)`,
        opacity: titleOpacity
      }, children: description }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        display: "grid",
        gridTemplateColumns: "repeat(2, 1fr)",
        gap: 20 * scale,
        width: "100%"
      }, children: highlights.map((highlight, i) => {
        const delay = 30 + i * 10;
        const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 12 } });
        const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
        return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          display: "flex",
          alignItems: "center",
          gap: 12 * scale,
          transform: `translateX(${(1 - pop) * -20}px)`,
          opacity: op,
          backgroundColor: COLORS.surfaceLight,
          padding: `${16 * scale}px ${20 * scale}px`,
          borderRadius: 12 * scale,
          border: `1px solid ${COLORS.border}`
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: 20 * scale, height: 20 * scale, viewBox: "0 0 24 24", fill: "none", stroke: primaryColor, strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "20 6 9 17 4 12" }) }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 18 * scale, fontWeight: 600, color: COLORS.textPrimary }, children: highlight })
        ] }, i);
      }) }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        marginTop: 50 * scale,
        backgroundColor: primaryColor,
        padding: `${20 * scale}px ${40 * scale}px`,
        borderRadius: 30 * scale,
        fontSize: 24 * scale,
        fontWeight: 800,
        color: "#fff",
        boxShadow: `0 10px 30px ${primaryColor}40`,
        transform: `scale(${(0,esm.spring)({ frame: frame - 70, fps, config: { damping: 10 } })})`,
        opacity: (0,esm.interpolate)(frame - 70, [0, 10], [0, 1], { extrapolateRight: "clamp" })
      }, children: "Learn More" })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      width: imageWidth,
      height: isPortrait ? width * 0.8 : height * 0.6,
      position: "relative",
      transform: `scale(${(0,esm.interpolate)(imageScale, [0, 1], [0.8, 1])})`,
      opacity: (0,esm.interpolate)(imageScale, [0, 1], [0, 1])
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        width: "80%",
        height: "80%",
        backgroundColor: primaryColor,
        borderRadius: "50%",
        filter: `blur(${80 * scale}px)`,
        opacity: 0.3,
        zIndex: 0
      } }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        borderRadius: 32 * scale,
        overflow: "hidden",
        boxShadow: "0 30px 60px rgba(0,0,0,0.5)",
        border: "2px solid rgba(255,255,255,0.1)",
        zIndex: 1
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
        esm.Img,
        {
          src: productImageUrl,
          style: {
            width: "100%",
            height: "100%",
            objectFit: "cover",
            transform: `scale(${slowZoom})`
          }
        }
      ) })
    ] })
  ] }) });
};
registerTemplate({
  tags: [],
  id: "product-showcase-01",
  name: "Product Feature Showcase",
  description: "A split-screen product reveal showing a hero image alongside key highlights.",
  category: "business-marketing",
  durationInFrames: 210,
  fps: 30,
  component: ProductShowcase,
  schema: productShowcaseSchema,
  defaultProps: productShowcaseSchema.parse({})
});

;// ./src/templates/business-marketing/RedditThreadMockup.tsx








const redditThreadMockupSchema = lib.z.object({
  subreddit: lib.z.string().default("r/marketing"),
  author: lib.z.string().default("u/GrowthHacker99"),
  time: lib.z.string().default("4h ago"),
  title: lib.z.string().default("What\u2019s your unfair advantage in 2024?"),
  content: lib.z.string().default("I\u2019ll start: We completely automated our video editing pipeline using AI. What used to take our team a full week now takes about 2 hours on a Tuesday morning. Our output is up 10x and CAC is down 40%.\n\nWhat\u2019s working for you right now?"),
  upvotes: lib.z.string().default("3.2k"),
  commentsCount: lib.z.string().default("428"),
  awardsCount: lib.z.number().default(4),
  darkMode: lib.z.boolean().default(true)
});
const RedditThreadMockup = ({
  subreddit,
  author,
  time,
  title,
  content,
  upvotes,
  commentsCount,
  awardsCount,
  darkMode
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const pop = (0,esm.spring)({ frame: frame - 10, fps, config: { damping: 14, mass: 1.2 } });
  const op = (0,esm.interpolate)(frame - 10, [0, 10], [0, 1], { extrapolateRight: "clamp" });
  const cardWidth = isPortrait ? width * 0.95 : 750 * scale;
  const bg = darkMode ? "#1a1a1b" : "#ffffff";
  const canvasBg = darkMode ? "#030303" : "#dae0e6";
  const textPrimary = darkMode ? "#d7dadc" : "#1c1c1c";
  const textSecondary = darkMode ? "#818384" : "#787c7e";
  const borderCol = darkMode ? "#343536" : "#cccccc";
  const hoverBg = darkMode ? "#272729" : "#f6f7f8";
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(canvasBg, backgroundControls), fontFamily: interFont, alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
    width: cardWidth,
    backgroundColor: bg,
    borderRadius: 8 * scale,
    border: `1px solid ${borderCol}`,
    display: "flex",
    boxShadow: darkMode ? "0 10px 30px rgba(0,0,0,0.8)" : "0 4px 12px rgba(0,0,0,0.05)",
    transform: `scale(${(0,esm.interpolate)(pop, [0, 1], [0.95, 1])}) translateY(${(1 - pop) * 30}px)`,
    opacity: op,
    overflow: "hidden"
  }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      width: 48 * scale,
      backgroundColor: darkMode ? "#1a1a1b" : "#f8f9fa",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      paddingTop: 12 * scale,
      borderRight: isPortrait ? "none" : `1px solid ${borderCol}`
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { color: frame > 30 ? "#ff4500" : textSecondary, transform: `scale(${frame > 30 ? (0,esm.spring)({ frame: frame - 30, fps, config: { damping: 10 } }) : 1})` }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 24 * scale, height: 24 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M12 4l-8 8h5v8h6v-8h5z" }) }) }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 14 * scale, fontWeight: 700, color: frame > 30 ? "#ff4500" : textPrimary, margin: `${4 * scale}px 0` }, children: upvotes }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { color: textSecondary }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 24 * scale, height: 24 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M12 20l8-8h-5v-8h-6v8h-5z" }) }) })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { flex: 1, padding: `${12 * scale}px ${16 * scale}px`, display: "flex", flexDirection: "column" }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", fontSize: 13 * scale, marginBottom: 8 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: "https://www.redditstatic.com/desktop2x/img/favicon/apple-icon-57x57.png", style: { width: 20 * scale, height: 20 * scale, borderRadius: "50%", marginRight: 8 * scale } }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontWeight: 700, color: textPrimary, marginRight: 8 * scale }, children: subreddit }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { color: textSecondary, marginRight: 8 * scale }, children: "\u2022" }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("span", { style: { color: textSecondary, marginRight: 8 * scale }, children: [
          "Posted by ",
          author
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { color: textSecondary }, children: time }),
        awardsCount > 0 && /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 4 * scale, marginLeft: 12 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 14 * scale }, children: "\u{1F3C6}" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 14 * scale }, children: "\u{1F525}" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 14 * scale }, children: "\u{1F680}" })
        ] })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        fontSize: 20 * scale,
        fontWeight: 600,
        color: textPrimary,
        marginBottom: 12 * scale,
        lineHeight: 1.2
      }, children: title }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        fontSize: 15 * scale,
        lineHeight: 1.5,
        color: textPrimary,
        whiteSpace: "pre-wrap",
        marginBottom: 16 * scale
      }, children: content }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 4 * scale, marginTop: "auto" }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 6 * scale, padding: `${6 * scale}px ${8 * scale}px`, borderRadius: 4 * scale, color: textSecondary, fontSize: 13 * scale, fontWeight: 700, backgroundColor: hoverBg }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z" }) }),
          commentsCount,
          " Comments"
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 6 * scale, padding: `${6 * scale}px ${8 * scale}px`, borderRadius: 4 * scale, color: textSecondary, fontSize: 13 * scale, fontWeight: 700 }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M20 18v-2h-2v2h2zm-2-8h2v6h-2v-6zm-4-4h2v12h-2V6zm-4 4h2v8h-2v-8zm-4 4h2v4H6v-4z" }) }),
          "Share"
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 6 * scale, padding: `${6 * scale}px ${8 * scale}px`, borderRadius: 4 * scale, color: textSecondary, fontSize: 13 * scale, fontWeight: 700 }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z" }) }),
          "Save"
        ] })
      ] })
    ] })
  ] }) });
};
registerTemplate({
  tags: [],
  id: "reddit-thread-mockup-01",
  name: "Reddit Thread Mockup",
  description: "A pixel-perfect Reddit post simulation complete with upvote animations.",
  category: "platform-mockups",
  durationInFrames: 150,
  fps: 30,
  component: RedditThreadMockup,
  schema: redditThreadMockupSchema,
  defaultProps: redditThreadMockupSchema.parse({})
});

;// ./src/templates/business-marketing/ResourceDownloadList.tsx










const resourceDownloadSchema = lib.z.object({
  title: lib.z.string().default("Free SEO Guide"),
  subtitle: lib.z.string().default("Master the algorithms"),
  bullets: lib.z.array(lib.z.string()).default([
    "Keyword research mastery",
    "On-page optimization tips",
    "Backlink building strategy",
    "Technical SEO checklist"
  ]),
  bookTitle: lib.z.string().default("SEO\n2024"),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  primaryColor: lib.z.string().default("#3b82f6"),
  secondaryColor: lib.z.string().default("#1e293b")
});
const ResourceDownloadList = ({
  title,
  subtitle,
  bullets,
  bookTitle,
  backgroundColor,
  textColor,
  primaryColor,
  secondaryColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  const bookWidth = isPortrait ? availableWidth * 0.6 : availableWidth * 0.4;
  const listWidth = isPortrait ? availableWidth : availableWidth * 0.55;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: isPortrait ? "center" : "left",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 60 : 72) * scale,
            margin: 0,
            letterSpacing: "-0.02em",
            color: textColor
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 30 : 36) * scale,
            opacity: 0.6,
            marginTop: 10 * scale
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 300 * scale : 250 * scale,
      left: paddingX,
      width: availableWidth,
      display: "flex",
      flexDirection: isPortrait ? "column" : "row",
      alignItems: isPortrait ? "center" : "center",
      justifyContent: "space-between",
      gap: 60 * scale
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        width: bookWidth,
        aspectRatio: "0.7",
        // typical book cover
        perspective: "1000px",
        transform: `translateY(${(1 - titleY) * 50}px)`,
        opacity: titleOpacity
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        width: "100%",
        height: "100%",
        backgroundColor: primaryColor,
        borderRadius: `0 ${20 * scale}px ${20 * scale}px 0`,
        boxShadow: `
                            -10px 0 20px rgba(0,0,0,0.5) inset,
                            30px 20px 40px rgba(0,0,0,0.4)
                        `,
        transform: "rotateY(-20deg)",
        transformStyle: "preserve-3d",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        padding: 40 * scale,
        position: "relative",
        borderLeft: "4px solid rgba(255,255,255,0.2)"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          left: -20 * scale,
          top: 0,
          bottom: 0,
          width: 20 * scale,
          backgroundColor: "#2563eb",
          // slightly darker
          transformOrigin: "right",
          transform: "rotateY(90deg)"
        } }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: 48 * scale,
          fontWeight: 900,
          fontFamily: interFont,
          color: "#fff",
          textAlign: "center",
          lineHeight: 1.2,
          whiteSpace: "pre-wrap",
          textShadow: "0 4px 10px rgba(0,0,0,0.3)"
        }, children: bookTitle })
      ] }) }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        width: listWidth,
        display: "flex",
        flexDirection: "column",
        gap: 24 * scale
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: 24 * scale,
          fontWeight: 700,
          color: COLORS.textMuted,
          textTransform: "uppercase",
          letterSpacing: "0.1em",
          marginBottom: 10 * scale
        }, children: "What's Inside" }),
        bullets.map((bullet, i) => {
          const delay = 20 + i * 10;
          const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
          const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
          return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
            backgroundColor: secondaryColor,
            padding: 20 * scale,
            borderRadius: 16 * scale,
            display: "flex",
            alignItems: "center",
            gap: 20 * scale,
            transform: `translateX(${(1 - pop) * 40}px)`,
            opacity: op,
            border: `1px solid ${COLORS.border}`,
            boxShadow: "0 10px 20px rgba(0,0,0,0.1)"
          }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
              width: 32 * scale,
              height: 32 * scale,
              borderRadius: "50%",
              backgroundColor: `${primaryColor}20`,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              color: primaryColor,
              flexShrink: 0
            }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: 20 * scale, height: 20 * scale, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "20 6 9 17 4 12" }) }) }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
              fontSize: 20 * scale,
              fontWeight: 500,
              color: COLORS.textPrimary
            }, children: bullet })
          ] }, i);
        }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          marginTop: 20 * scale,
          backgroundColor: primaryColor,
          padding: 20 * scale,
          borderRadius: 16 * scale,
          textAlign: "center",
          fontSize: 24 * scale,
          fontWeight: 800,
          color: "#fff",
          boxShadow: `0 10px 30px ${primaryColor}40`,
          transform: `scale(${(0,esm.spring)({ frame: frame - (40 + bullets.length * 10), fps, config: { damping: 10 } })})`,
          opacity: (0,esm.interpolate)(frame - (40 + bullets.length * 10), [0, 10], [0, 1], { extrapolateRight: "clamp" })
        }, children: "Download Now \u2193" })
      ] })
    ] })
  ] });
};
registerTemplate({
  tags: [],
  id: "resource-download-list-01",
  name: "Resource Download CTA",
  description: "A 3D book mockup paired with a dynamic list of bullet points detailing what is inside.",
  category: "social-hooks",
  durationInFrames: 180,
  fps: 30,
  component: ResourceDownloadList,
  schema: resourceDownloadSchema,
  defaultProps: resourceDownloadSchema.parse({})
});

;// ./src/templates/business-marketing/ReviewMockup.tsx








const reviewMockupSchema = lib.z.object({
  platform: lib.z.enum(["trustpilot", "g2", "capterra"]).default("trustpilot"),
  reviewerName: lib.z.string().default("Michael R."),
  reviewerRole: lib.z.string().default("Marketing Director"),
  rating: lib.z.number().min(1).max(5).default(5),
  title: lib.z.string().default("Literally changed how we work."),
  content: lib.z.string().default("Before Lapaas, we struggled to keep up with the demand for video content across all our social channels. Now, a single editor can produce 10x the output without sacrificing quality. The AI auto-B-roll feature is actual magic."),
  date: lib.z.string().default("2 days ago"),
  backgroundColor: lib.z.string().default("#f4f4f5"),
  // Light gray bg
  textColor: lib.z.string().default("#1c1c1f")
});
const ReviewMockup = ({
  platform,
  reviewerName,
  reviewerRole,
  rating,
  title,
  content,
  date,
  textColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const pop = (0,esm.spring)({ frame: frame - 15, fps, config: { damping: 14, mass: 1.2 } });
  const op = (0,esm.interpolate)(frame - 15, [0, 10], [0, 1], { extrapolateRight: "clamp" });
  const cardWidth = isPortrait ? width * 0.9 : 800 * scale;
  let platformColor = "#00b67a";
  let platformLogoText = "Trustpilot";
  if (platform === "g2") {
    platformColor = "#ff492c";
    platformLogoText = "G2";
  } else if (platform === "capterra") {
    platformColor = "#0033cc";
    platformLogoText = "Capterra";
  }
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground("#f8f9fa", backgroundControls), fontFamily: interFont, alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
    width: cardWidth,
    backgroundColor: "#ffffff",
    borderRadius: 16 * scale,
    padding: `${40 * scale}px`,
    display: "flex",
    flexDirection: "column",
    boxShadow: "0 20px 40px rgba(0,0,0,0.08)",
    border: "1px solid rgba(0,0,0,0.05)",
    transform: `scale(${(0,esm.interpolate)(pop, [0, 1], [0.95, 1])}) translateY(${(1 - pop) * 40}px)`,
    opacity: op,
    position: "relative",
    overflow: "hidden"
  }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      height: 6 * scale,
      backgroundColor: platformColor
    } }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 24 * scale }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 8 * scale }, children: [
        platform === "trustpilot" && /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 512 512", width: 32 * scale, height: 32 * scale, fill: platformColor, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M256,12.2l76.7,155.3l171.3,24.9L380.1,313.2l29.2,170.6L256,403.3l-153.3,80.6L132,313.2L8.1,192.4 l171.3-24.9L256,12.2z" }) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 24 * scale, fontWeight: 800, color: textColor, letterSpacing: "-0.5px" }, children: platformLogoText })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 16 * scale, color: "#6b7280" }, children: date })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 16 * scale, marginBottom: 24 * scale }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        width: 56 * scale,
        height: 56 * scale,
        borderRadius: "50%",
        backgroundColor: "#f3f4f6",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        fontSize: 24 * scale,
        fontWeight: 700,
        color: platformColor,
        border: `2px solid ${platformColor}20`
      }, children: reviewerName.charAt(0) }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column" }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 20 * scale, fontWeight: 700, color: textColor }, children: reviewerName }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 16 * scale, color: "#6b7280" }, children: reviewerRole })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { marginLeft: "auto", display: "flex", alignItems: "center", gap: 6 * scale, color: "#6b7280", fontSize: 14 * scale, fontWeight: 600 }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: 18 * scale, height: 18 * scale, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "20 6 9 17 4 12" }) }),
        "Verified User"
      ] })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { display: "flex", gap: 4 * scale, marginBottom: 20 * scale }, children: [1, 2, 3, 4, 5].map((star) => {
      const starDelay = 25 + star * 5;
      const starPop = (0,esm.spring)({ frame: frame - starDelay, fps, config: { damping: 12 } });
      return /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        width: 36 * scale,
        height: 36 * scale,
        backgroundColor: star <= rating ? platformColor : "#e5e7eb",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        borderRadius: 4 * scale,
        // Trustpilot style blocks
        transform: `scale(${(0,esm.interpolate)(starPop, [0, 1], [0.5, 1])})`,
        opacity: (0,esm.interpolate)(frame - starDelay, [0, 5], [0, 1], { extrapolateRight: "clamp" })
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 24 * scale, height: 24 * scale, fill: "#ffffff", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z" }) }) }, star);
    }) }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      fontSize: 28 * scale,
      fontWeight: 800,
      color: textColor,
      marginBottom: 16 * scale,
      lineHeight: 1.3
    }, children: [
      '"',
      title,
      '"'
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      fontSize: 20 * scale,
      color: "#374151",
      lineHeight: 1.6,
      whiteSpace: "pre-wrap"
    }, children: content })
  ] }) });
};
registerTemplate({
  tags: [],
  id: "review-mockup-01",
  name: "Trustpilot/G2 Review Card",
  description: "A realistic review card simulating Trustpilot, G2, or Capterra to build instant credibility.",
  category: "platform-mockups",
  durationInFrames: 180,
  fps: 30,
  component: ReviewMockup,
  schema: reviewMockupSchema,
  defaultProps: reviewMockupSchema.parse({})
});

;// ./src/templates/business-marketing/SocialPostGrid.tsx










const socialPostGridSchema = lib.z.object({
  title: lib.z.string().default("Everyone is talking about it"),
  posts: lib.z.array(lib.z.object({
    username: lib.z.string(),
    handle: lib.z.string(),
    text: lib.z.string(),
    avatarUrl: lib.z.string(),
    likes: lib.z.string(),
    platform: lib.z.enum(["twitter", "linkedin", "threads"]).default("twitter"),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    {
      username: "Alex Hormozi",
      handle: "@AlexHormozi",
      platform: "twitter",
      likes: "14.2K",
      text: "Just tried the new Lapaas AI Editor. It cut our video production time by 80%. This is the future of content.",
      avatarUrl: "https://images.unsplash.com/photo-1550525811-e5869dd03032?w=150"
    },
    {
      username: "Sarah Drasner",
      handle: "@swyx",
      platform: "twitter",
      likes: "8,421",
      text: "I cannot believe how good the timeline auto-cutting is. Worth every penny.",
      avatarUrl: "https://images.unsplash.com/photo-1494790108377-be9c29b29330?w=150"
    },
    {
      username: "Naval Ravikant",
      handle: "@naval",
      platform: "threads",
      likes: "32K",
      text: "The best tools give you leverage. This gives you leverage over time itself.",
      avatarUrl: "https://images.unsplash.com/photo-1599566150163-29194dcaad36?w=150"
    }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  cardBgColor: lib.z.string().default(COLORS.surface)
});
const SocialPostGrid = ({
  title,
  posts,
  backgroundColor,
  textColor,
  cardBgColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalPosts = posts.length;
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  const colCount = isPortrait ? 1 : Math.min(3, totalPosts);
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity,
      zIndex: 100
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em",
          textShadow: "0 4px 20px rgba(0,0,0,0.5)"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 250 * scale : 200 * scale,
      left: paddingX,
      width: availableWidth,
      display: "grid",
      gridTemplateColumns: `repeat(${colCount}, 1fr)`,
      gap: 30 * scale,
      alignItems: "start"
      // allows masonry stagger
    }, children: posts.map((post, i) => {
      const delay = 20 + i * 15;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      const yOffset = !isPortrait && i % 2 !== 0 ? 80 * scale : 0;
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        backgroundColor: cardBgColor,
        borderRadius: 24 * scale,
        padding: 30 * scale,
        transform: `translateY(${(1 - pop) * 100 + yOffset}px) scale(${(0,esm.interpolate)(pop, [0, 1], [0.9, 1])}) rotate(${(1 - pop) * (i % 2 === 0 ? 2 : -2)}deg)`,
        opacity: op,
        boxShadow: "0 20px 40px rgba(0,0,0,0.2)",
        border: `1px solid ${COLORS.borderLight}`,
        display: "flex",
        flexDirection: "column",
        gap: 20 * scale
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 16 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            esm.Img,
            {
              src: post.avatarUrl,
              style: {
                width: 60 * scale,
                height: 60 * scale,
                borderRadius: "50%",
                objectFit: "cover"
              }
            }
          ),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { flex: 1 }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 20 * scale, fontWeight: 700, color: "#fff" }, children: post.username }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 16 * scale, color: COLORS.textMuted }, children: post.handle })
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 24 * scale, opacity: 0.5 }, children: post.platform === "twitter" ? "\u{1D54F}" : post.platform === "linkedin" ? "in" : "\u{1F9F5}" })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: 22 * scale,
          lineHeight: 1.5,
          color: COLORS.textPrimary
        }, children: post.text }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          display: "flex",
          alignItems: "center",
          gap: 24 * scale,
          color: COLORS.textMuted,
          fontSize: 16 * scale,
          marginTop: 10 * scale
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { children: "\u{1F4AC} Reply" }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { children: "\u{1F501} Repost" }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("span", { style: { color: "#ef4444" }, children: [
            "\u2764\uFE0F ",
            post.likes
          ] })
        ] })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "social-post-grid-01",
  name: "Social Proof Post Grid",
  description: "A staggered grid of simulated social media posts popping up to show viral traction.",
  category: "business-marketing",
  durationInFrames: 180,
  fps: 30,
  component: SocialPostGrid,
  schema: socialPostGridSchema,
  defaultProps: socialPostGridSchema.parse({})
});

;// ./src/templates/business-marketing/SpeakerRoster.tsx










const speakerRosterSchema = lib.z.object({
  title: lib.z.string().default("Hosted By"),
  subtitle: lib.z.string().default("Industry Experts & Thought Leaders"),
  speakers: lib.z.array(lib.z.object({
    name: lib.z.string(),
    title: lib.z.string(),
    company: lib.z.string(),
    avatarUrl: lib.z.string(),
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { name: "Dr. Emily Chen", title: "Chief AI Officer", company: "TechNova", avatarUrl: "https://images.unsplash.com/photo-1573496359142-b8d87734a5a2?w=300", color: "#3b82f6" },
    { name: "James Wilson", title: "VP of Engineering", company: "GlobalData", avatarUrl: "https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?w=300", color: "#10b981" },
    { name: "Sarah Patel", title: "Director of Product", company: "InnovateInc", avatarUrl: "https://images.unsplash.com/photo-1580489944761-15a19d654956?w=300", color: "#f59e0b" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  cardBgColor: lib.z.string().default(COLORS.surface)
});
const SpeakerRoster = ({
  title,
  subtitle,
  speakers,
  backgroundColor,
  textColor,
  cardBgColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalSpeakers = speakers.length;
  const cols = isPortrait ? 1 : Math.min(3, totalSpeakers);
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const gap = isPortrait ? 30 * scale : 60 * scale;
  const availableWidth = width - paddingX * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 60 : 72) * scale,
            margin: 0,
            letterSpacing: "-0.02em",
            color: textColor
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 24 : 32) * scale,
            opacity: 0.6,
            marginTop: 10 * scale
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -40%)",
      display: "grid",
      gridTemplateColumns: `repeat(${cols}, 1fr)`,
      gap,
      width: availableWidth,
      maxWidth: 1400 * scale
    }, children: speakers.map((speaker, i) => {
      const delay = 15 + i * 10;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        backgroundColor: cardBgColor,
        borderRadius: 24 * scale,
        padding: isPortrait ? 30 * scale : 40 * scale,
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        textAlign: "center",
        transform: `translateY(${(1 - pop) * 100}px)`,
        opacity: op,
        boxShadow: "0 20px 40px rgba(0,0,0,0.2)",
        position: "relative",
        overflow: "hidden"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          height: 8 * scale,
          backgroundColor: speaker.color
        } }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          width: (isPortrait ? 120 : 160) * scale,
          height: (isPortrait ? 120 : 160) * scale,
          borderRadius: "50%",
          marginBottom: 24 * scale,
          padding: 6 * scale,
          border: `2px dashed ${speaker.color}40`,
          position: "relative"
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            esm.Img,
            {
              src: speaker.avatarUrl,
              style: {
                width: "100%",
                height: "100%",
                borderRadius: "50%",
                objectFit: "cover",
                backgroundColor: "#fff"
              }
            }
          ),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            position: "absolute",
            bottom: 0,
            right: 0,
            width: 40 * scale,
            height: 40 * scale,
            backgroundColor: speaker.color,
            borderRadius: "50%",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            color: "#fff",
            fontSize: 20 * scale,
            boxShadow: "0 4px 10px rgba(0,0,0,0.3)"
          }, children: "\u{1F3A4}" })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: (isPortrait ? 28 : 32) * scale,
          fontWeight: 800,
          fontFamily: interFont,
          color: "#fff",
          marginBottom: 12 * scale
        }, children: speaker.name }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: (isPortrait ? 18 : 20) * scale,
          fontWeight: 600,
          color: speaker.color,
          marginBottom: 4 * scale
        }, children: speaker.title }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: (isPortrait ? 16 : 18) * scale,
          color: COLORS.textSecondary,
          textTransform: "uppercase",
          letterSpacing: "0.05em"
        }, children: speaker.company })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "speaker-roster-01",
  name: "Event Speaker Roster",
  description: "A dynamic grid of speaker profiles with avatars, names, titles, and companies.",
  category: "business-marketing",
  durationInFrames: 180,
  fps: 30,
  component: SpeakerRoster,
  schema: speakerRosterSchema,
  defaultProps: speakerRosterSchema.parse({})
});

;// ./src/templates/business-marketing/SplitScreenMetrics.tsx










const splitScreenMetricsSchema = lib.z.object({
  leftTitle: lib.z.string().default("Industry Avg"),
  rightTitle: lib.z.string().default("With Our App"),
  leftMetric: lib.z.string().default("14 days"),
  rightMetric: lib.z.string().default("2 hours"),
  leftSub: lib.z.string().default("Time to value"),
  rightSub: lib.z.string().default("Time to value"),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  leftColor: lib.z.string().default("#ef4444"),
  rightColor: lib.z.string().default("#10b981")
});
const SplitScreenMetrics = ({
  leftTitle,
  rightTitle,
  leftMetric,
  rightMetric,
  leftSub,
  rightSub,
  backgroundColor,
  textColor,
  leftColor,
  rightColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const popL = (0,esm.spring)({ frame: frame - 15, fps, config: { damping: 14, mass: 1.2 } });
  const popR = (0,esm.spring)({ frame: frame - 30, fps, config: { damping: 14, mass: 1.2 } });
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: isPortrait ? (
    // Top / Bottom Split
    /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        height: halfHeight,
        backgroundColor: `${leftColor}10`,
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        borderBottom: `2px solid ${leftColor}40`,
        transform: `translateY(${(1 - popL) * -50}px)`,
        opacity: popL
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 28 * scale, fontWeight: 700, color: leftColor, textTransform: "uppercase", letterSpacing: "0.1em", marginBottom: 20 * scale }, children: leftTitle }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(EditableText, { text: leftMetric, style: { fontFamily: interFont, fontWeight: 900, fontSize: 80 * scale, margin: 0, color: "#fff", textShadow: `0 4px 20px ${leftColor}40` } }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 24 * scale, color: COLORS.textSecondary, marginTop: 10 * scale }, children: leftSub })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        position: "absolute",
        bottom: 0,
        left: 0,
        right: 0,
        height: halfHeight,
        backgroundColor: `${rightColor}20`,
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        transform: `translateY(${(1 - popR) * 50}px)`,
        opacity: popR
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 28 * scale, fontWeight: 700, color: rightColor, textTransform: "uppercase", letterSpacing: "0.1em", marginBottom: 20 * scale }, children: rightTitle }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(EditableText, { text: rightMetric, style: { fontFamily: interFont, fontWeight: 900, fontSize: 100 * scale, margin: 0, color: "#fff", textShadow: `0 4px 30px ${rightColor}60` } }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 24 * scale, color: "rgba(255,255,255,0.8)", marginTop: 10 * scale }, children: rightSub })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        width: 80 * scale,
        height: 80 * scale,
        borderRadius: "50%",
        backgroundColor: textColor,
        color: backgroundColor,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        fontSize: 24 * scale,
        fontWeight: 900,
        fontFamily: interFont,
        boxShadow: "0 10px 30px rgba(0,0,0,0.5)",
        zIndex: 10,
        opacity: (0,esm.interpolate)(frame - 45, [0, 10], [0, 1], { extrapolateRight: "clamp" })
      }, children: "VS" })
    ] })
  ) : (
    // Left / Right Split
    /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        width: halfWidth,
        backgroundColor: `${leftColor}10`,
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        borderRight: `2px solid ${leftColor}40`,
        transform: `translateX(${(1 - popL) * -50}px)`,
        opacity: popL
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 32 * scale, fontWeight: 700, color: leftColor, textTransform: "uppercase", letterSpacing: "0.1em", marginBottom: 30 * scale }, children: leftTitle }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(EditableText, { text: leftMetric, style: { fontFamily: interFont, fontWeight: 900, fontSize: 100 * scale, margin: 0, color: "#fff", textShadow: `0 4px 20px ${leftColor}40` } }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 28 * scale, color: COLORS.textSecondary, marginTop: 16 * scale }, children: leftSub })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        width: halfWidth,
        backgroundColor: `${rightColor}20`,
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        transform: `translateX(${(1 - popR) * 50}px)`,
        opacity: popR
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 32 * scale, fontWeight: 700, color: rightColor, textTransform: "uppercase", letterSpacing: "0.1em", marginBottom: 30 * scale }, children: rightTitle }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(EditableText, { text: rightMetric, style: { fontFamily: interFont, fontWeight: 900, fontSize: 120 * scale, margin: 0, color: "#fff", textShadow: `0 4px 40px ${rightColor}60` } }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 28 * scale, color: "rgba(255,255,255,0.8)", marginTop: 16 * scale }, children: rightSub })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        width: 100 * scale,
        height: 100 * scale,
        borderRadius: "50%",
        backgroundColor: textColor,
        color: backgroundColor,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        fontSize: 32 * scale,
        fontWeight: 900,
        fontFamily: interFont,
        boxShadow: "0 10px 40px rgba(0,0,0,0.5)",
        zIndex: 10,
        opacity: (0,esm.interpolate)(frame - 45, [0, 10], [0, 1], { extrapolateRight: "clamp" })
      }, children: "VS" })
    ] })
  ) });
};
registerTemplate({
  tags: [],
  id: "split-screen-metrics-01",
  name: "Split Screen Metric Compare",
  description: "A bold, split-screen layout comparing a bad metric to a good metric.",
  category: "data-visualization",
  durationInFrames: 180,
  fps: 30,
  component: SplitScreenMetrics,
  schema: splitScreenMetricsSchema,
  defaultProps: splitScreenMetricsSchema.parse({})
});

;// ./src/templates/business-marketing/SponsorBanner.tsx










const sponsorBannerSchema = lib.z.object({
  title: lib.z.string().default("Sponsored By"),
  sponsors: lib.z.array(lib.z.string()).default([
    "https://upload.wikimedia.org/wikipedia/commons/a/a9/Amazon_logo.svg",
    "https://upload.wikimedia.org/wikipedia/commons/2/2f/Google_2015_logo.svg",
    "https://upload.wikimedia.org/wikipedia/commons/e/e8/Tesla_logo.png",
    "https://upload.wikimedia.org/wikipedia/commons/0/08/Netflix_2015_logo.svg",
    "https://upload.wikimedia.org/wikipedia/commons/f/fa/Apple_logo_black.svg",
    "https://upload.wikimedia.org/wikipedia/commons/4/44/Microsoft_logo.svg"
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  bannerBgColor: lib.z.string().default("#1e293b"),
  speed: lib.z.number().min(1).max(10).default(3)
});
const SponsorBanner = ({
  title,
  sponsors,
  backgroundColor,
  textColor,
  bannerBgColor,
  speed
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const duplicatedSponsors = [...sponsors, ...sponsors, ...sponsors, ...sponsors];
  const logoWidth = isPortrait ? 200 * scale : 300 * scale;
  const gap = isPortrait ? 60 * scale : 100 * scale;
  const setWidth = sponsors.length * (logoWidth + gap);
  const scrollPixelsPerFrame = speed * scale * 2;
  const currentOffset = frame * scrollPixelsPerFrame % setWidth;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor, justifyContent: "center" }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 200 * scale : 250 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 48 : 60) * scale,
          margin: 0,
          letterSpacing: "0.1em",
          textTransform: "uppercase",
          color: COLORS.textSecondary
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      width: "100%",
      height: isPortrait ? 250 * scale : 300 * scale,
      backgroundColor: bannerBgColor,
      borderTop: "2px solid rgba(255,255,255,0.1)",
      borderBottom: "2px solid rgba(255,255,255,0.1)",
      boxShadow: "0 20px 50px rgba(0,0,0,0.3)",
      display: "flex",
      alignItems: "center",
      overflow: "hidden",
      position: "relative",
      opacity: (0,esm.interpolate)(frame, [15, 30], [0, 1], { extrapolateRight: "clamp" }),
      transform: `scaleY(${(0,esm.interpolate)((0,esm.spring)({ frame: frame - 15, fps, config: { damping: 14 } }), [0, 1], [0, 1])})`
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        display: "flex",
        alignItems: "center",
        gap,
        transform: `translateX(${-currentOffset}px)`,
        // We start the container slightly offset to the right so it begins offscreen if needed,
        // but since we duplicated it, we just start at 0 and let it scroll continuously.
        paddingLeft: gap
      }, children: duplicatedSponsors.map((logoUrl, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        width: logoWidth,
        height: (isPortrait ? 100 : 150) * scale,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: 0
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
        esm.Img,
        {
          src: logoUrl,
          style: {
            maxWidth: "100%",
            maxHeight: "100%",
            objectFit: "contain",
            filter: "grayscale(100%) opacity(0.7)"
          }
        }
      ) }, i)) }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        width: 200 * scale,
        background: `linear-gradient(90deg, ${bannerBgColor} 0%, transparent 100%)`,
        zIndex: 10
      } }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: 0,
        right: 0,
        bottom: 0,
        width: 200 * scale,
        background: `linear-gradient(-90deg, ${bannerBgColor} 0%, transparent 100%)`,
        zIndex: 10
      } })
    ] })
  ] });
};
registerTemplate({
  tags: [],
  id: "sponsor-banner-01",
  name: "Infinite Scrolling Sponsor Banner",
  description: "A seamless, continuously scrolling ticker tape of sponsor or partner logos.",
  category: "business-marketing",
  durationInFrames: 300,
  fps: 30,
  component: SponsorBanner,
  schema: sponsorBannerSchema,
  defaultProps: sponsorBannerSchema.parse({})
});

;// ./src/templates/business-marketing/SprintProgressBar.tsx











const sprintProgressBarSchema = lib.z.object({
  title: lib.z.string().default("Q4 Product Roadmap"),
  sprints: lib.z.array(lib.z.object({
    name: lib.z.string(),
    status: lib.z.enum(["done", "active", "pending"]),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { name: "User Auth", status: "done" },
    { name: "Dashboard UI", status: "done" },
    { name: "Stripe Integration", status: "active" },
    { name: "Analytics Beta", status: "pending" },
    { name: "Public Launch", status: "pending" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  doneColor: lib.z.string().default("#10b981"),
  // Green
  activeColor: lib.z.string().default("#3b82f6"),
  // Blue
  pendingColor: lib.z.string().default("rgba(255,255,255,0.1)")
  // Gray
});
const SprintProgressBar = ({
  title,
  sprints,
  backgroundColor,
  textColor,
  doneColor,
  activeColor,
  pendingColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalSprints = sprints.length;
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  const startY = height * 0.5;
  const segmentWidth = availableWidth / totalSprints;
  let targetProgressIndex = 0;
  for (let i = 0; i < sprints.length; i++) {
    if (sprints[i].status === "done") targetProgressIndex = i + 1;
    if (sprints[i].status === "active") {
      targetProgressIndex = i + 0.5;
      break;
    }
  }
  const targetFillWidth = targetProgressIndex / totalSprints * availableWidth;
  const fillProgress = (0,esm.spring)({ frame: frame - 20, fps, config: { damping: 20, mass: 1.5 } });
  const currentFillWidth = fillProgress * targetFillWidth;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 150 * scale : 150 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: startY,
      left: paddingX,
      width: availableWidth,
      height: 16 * scale,
      backgroundColor: pendingColor,
      borderRadius: 8 * scale,
      boxShadow: "inset 0 2px 4px rgba(0,0,0,0.5)"
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        width: currentFillWidth,
        backgroundColor: activeColor,
        // default to active blue for the moving part
        borderRadius: 8 * scale,
        boxShadow: `0 0 20px ${activeColor}80`
      } }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        width: Math.min(currentFillWidth, Math.floor(targetProgressIndex) / totalSprints * availableWidth),
        backgroundColor: doneColor,
        borderRadius: 8 * scale,
        boxShadow: `0 0 20px ${doneColor}80`,
        transition: "width 0.1s"
        // snap to green as the blue bar passes
      } }),
      sprints.map((sprint, i) => {
        const nodeX = (i + 0.5) * segmentWidth;
        const hasReached = currentFillWidth >= nodeX;
        const pop = (0,esm.spring)({ frame: frame - (20 + i * 5), fps, config: { damping: 10 } });
        let nodeColor = pendingColor;
        if (hasReached) {
          nodeColor = sprint.status === "done" ? doneColor : sprint.status === "active" ? activeColor : pendingColor;
        }
        return /* @__PURE__ */ (0,jsx_runtime.jsxs)(react.Fragment, { children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            position: "absolute",
            top: "50%",
            left: nodeX,
            width: 32 * scale,
            height: 32 * scale,
            backgroundColor,
            border: `${6 * scale}px solid ${nodeColor}`,
            borderRadius: "50%",
            transform: "translate(-50%, -50%)",
            zIndex: 10,
            transition: "all 0.2s",
            boxShadow: hasReached && sprint.status !== "pending" ? `0 0 15px ${nodeColor}` : "none"
          } }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
            position: "absolute",
            top: isPortrait && i % 2 !== 0 ? -80 * scale : 40 * scale,
            // Stagger up/down in portrait
            left: nodeX,
            width: segmentWidth * 0.9,
            textAlign: "center",
            transform: `translateX(-50%) scale(${pop})`,
            opacity: pop
          }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
              fontSize: 18 * scale,
              fontWeight: 700,
              fontFamily: interFont,
              color: hasReached && sprint.status !== "pending" ? "#fff" : "rgba(255,255,255,0.4)",
              transition: "color 0.2s"
            }, children: sprint.name }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
              fontSize: 14 * scale,
              fontWeight: 800,
              textTransform: "uppercase",
              color: nodeColor,
              marginTop: 4 * scale,
              opacity: hasReached ? 1 : 0,
              transition: "opacity 0.2s"
            }, children: sprint.status })
          ] })
        ] }, i);
      })
    ] })
  ] });
};
registerTemplate({
  tags: [],
  id: "sprint-progress-bar-01",
  name: "Dynamic Sprint Roadmap",
  description: "A horizontal progress bar that fills up to indicate completed vs active milestones.",
  category: "business-marketing",
  durationInFrames: 180,
  fps: 30,
  component: SprintProgressBar,
  schema: sprintProgressBarSchema,
  defaultProps: sprintProgressBarSchema.parse({})
});

;// ./src/templates/business-marketing/StatGrid3x3.tsx










const statGridSchema = lib.z.object({
  title: lib.z.string().default("Platform Scale"),
  stats: lib.z.array(lib.z.object({
    value: lib.z.string(),
    label: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { value: "50M+", label: "API Requests / Day" },
    { value: "99.99%", label: "Guaranteed Uptime" },
    { value: "<50ms", label: "Average Latency" },
    { value: "120+", label: "Global PoPs" },
    { value: "Zero", label: "Maintenance Windows" },
    { value: "SOC2", label: "Type II Certified" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  accentColor: lib.z.string().default(COLORS.accent)
});
const StatGrid3x3 = ({
  title,
  stats,
  backgroundColor,
  textColor,
  accentColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalStats = stats.length;
  const cols = isPortrait ? 2 : Math.min(3, Math.ceil(Math.sqrt(totalStats)));
  const paddingX = isPortrait ? 40 * scale : 120 * scale;
  const gap = isPortrait ? 20 * scale : 30 * scale;
  const availableWidth = width - paddingX * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 120 * scale : 100 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em",
          color: accentColor,
          textTransform: "uppercase"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      display: "grid",
      gridTemplateColumns: `repeat(${cols}, 1fr)`,
      gap,
      width: availableWidth,
      maxWidth: 1400 * scale
    }, children: stats.map((stat, i) => {
      const delay = 15 + i * 5;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        backgroundColor: COLORS.surface,
        border: `1px solid ${accentColor}40`,
        borderRadius: 24 * scale,
        padding: isPortrait ? 30 * scale : 50 * scale,
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        textAlign: "center",
        transform: `translateY(${(1 - pop) * 50}px) scale(${(0,esm.interpolate)(pop, [0, 1], [0.9, 1])})`,
        opacity: op,
        boxShadow: `0 10px 30px ${accentColor}10`,
        position: "relative",
        overflow: "hidden",
        aspectRatio: isPortrait ? "1" : "16/9"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          top: -50 * scale,
          left: "50%",
          transform: "translateX(-50%)",
          width: 100 * scale,
          height: 100 * scale,
          backgroundColor: accentColor,
          filter: `blur(${40 * scale}px)`,
          opacity: 0.3,
          zIndex: 0
        } }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: (isPortrait ? 48 : 72) * scale,
          fontWeight: 900,
          fontFamily: interFont,
          color: "#fff",
          marginBottom: 16 * scale,
          zIndex: 1,
          letterSpacing: "-0.03em"
        }, children: stat.value }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: (isPortrait ? 16 : 20) * scale,
          fontWeight: 500,
          color: COLORS.textSecondary,
          zIndex: 1,
          textTransform: "uppercase",
          letterSpacing: "0.1em"
        }, children: stat.label })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "stat-grid-3x3-01",
  name: "Metric Grid Cards",
  description: "A clean, modern grid of statistics cards that pop in sequentially. Great for highlighting scale.",
  category: "data-visualization",
  durationInFrames: 150,
  fps: 30,
  component: StatGrid3x3,
  schema: statGridSchema,
  defaultProps: statGridSchema.parse({})
});

;// ./src/templates/business-marketing/StepByStepProcess.tsx










const stepByStepProcessSchema = lib.z.object({
  title: lib.z.string().default("How It Works"),
  steps: lib.z.array(lib.z.object({
    title: lib.z.string(),
    desc: lib.z.string(),
    icon: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { title: "Create Account", desc: "Sign up in under 60 seconds. No credit card required.", icon: "\u{1F4DD}" },
    { title: "Connect Data", desc: "Securely sync your analytics and CRM platforms.", icon: "\u{1F517}" },
    { title: "AI Analysis", desc: "Our engine identifies hidden revenue opportunities.", icon: "\u{1F916}" },
    { title: "Execute", desc: "Deploy automated campaigns and watch metrics soar.", icon: "\u{1F680}" }
  ]),
  backgroundColor: lib.z.string().default("#f8fafc"),
  textColor: lib.z.string().default("#0f172a"),
  primaryColor: lib.z.string().default("#3b82f6")
});
const StepByStepProcess = ({
  title,
  steps,
  backgroundColor,
  textColor,
  primaryColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalSteps = steps.length;
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const startY = isPortrait ? height * 0.25 : height * 0.35;
  const availableWidth = width - paddingX * 2;
  const gap = isPortrait ? 60 * scale : 40 * scale;
  const stepWidth = isPortrait ? availableWidth : (availableWidth - gap * (totalSteps - 1)) / totalSteps;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 100 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? startY : startY + 40 * scale,
      // center of icon
      left: isPortrait ? paddingX + 40 * scale : paddingX + stepWidth / 2,
      width: isPortrait ? 4 * scale : availableWidth - stepWidth,
      height: isPortrait ? height * 0.6 : 4 * scale,
      backgroundColor: `${primaryColor}30`,
      zIndex: 0
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: 0,
      left: 0,
      width: isPortrait ? "100%" : `${(0,esm.interpolate)(frame, [20, 20 + totalSteps * 15], [0, 100], { extrapolateRight: "clamp" })}%`,
      height: isPortrait ? `${(0,esm.interpolate)(frame, [20, 20 + totalSteps * 15], [0, 100], { extrapolateRight: "clamp" })}%` : "100%",
      backgroundColor: primaryColor,
      boxShadow: `0 0 10px ${primaryColor}`
    } }) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: startY,
      left: paddingX,
      width: availableWidth,
      display: "flex",
      flexDirection: isPortrait ? "column" : "row",
      justifyContent: "space-between",
      alignItems: isPortrait ? "flex-start" : "flex-start",
      gap,
      zIndex: 1
    }, children: steps.map((step, i) => {
      const delay = 20 + i * 15;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 12, mass: 1.2 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        width: isPortrait ? "100%" : stepWidth,
        display: "flex",
        flexDirection: isPortrait ? "row" : "column",
        alignItems: isPortrait ? "flex-start" : "center",
        textAlign: isPortrait ? "left" : "center",
        gap: 20 * scale,
        opacity: op
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          width: 80 * scale,
          height: 80 * scale,
          borderRadius: "50%",
          backgroundColor: "#fff",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          fontSize: 32 * scale,
          transform: `scale(${pop})`,
          boxShadow: `0 10px 20px ${primaryColor}40`,
          border: `4px solid ${primaryColor}`,
          flexShrink: 0,
          position: "relative"
        }, children: [
          step.icon,
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            position: "absolute",
            top: -10 * scale,
            right: -10 * scale,
            width: 32 * scale,
            height: 32 * scale,
            backgroundColor: textColor,
            color: backgroundColor,
            borderRadius: "50%",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            fontSize: 16 * scale,
            fontWeight: 800,
            fontFamily: interFont
          }, children: i + 1 })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          display: "flex",
          flexDirection: "column",
          gap: 10 * scale,
          transform: `translateY(${(1 - pop) * 20}px)`,
          marginTop: isPortrait ? 10 * scale : 0
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 24 * scale,
            fontWeight: 800,
            fontFamily: interFont,
            color: textColor
          }, children: step.title }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 18 * scale,
            color: "#64748b",
            lineHeight: 1.5
          }, children: step.desc })
        ] })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "step-by-step-process-01",
  name: "Dynamic Step-by-Step Process",
  description: "A connected roadmap showing N steps in a process. Draws lines between nodes automatically.",
  category: "business-marketing",
  durationInFrames: 180,
  fps: 30,
  component: StepByStepProcess,
  schema: stepByStepProcessSchema,
  defaultProps: stepByStepProcessSchema.parse({})
});

;// ./src/templates/business-marketing/TeamQuote.tsx










const teamQuoteSchema = lib.z.object({
  quote: lib.z.string().default("Innovation distinguishes between a leader and a follower."),
  author: lib.z.string().default("Steve Jobs"),
  role: lib.z.string().default("Co-founder, Apple"),
  avatarUrl: lib.z.string().default("https://images.unsplash.com/photo-1550525811-e5869dd03032?w=300"),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  accentColor: lib.z.string().default(COLORS.accent)
});
const TeamQuote = ({
  quote,
  author,
  role,
  avatarUrl,
  textColor,
  accentColor,
  backgroundColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor, justifyContent: "center", alignItems: "center" }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
    width: availableWidth,
    maxWidth: 1200 * scale,
    position: "relative",
    display: "flex",
    flexDirection: "column",
    alignItems: isPortrait ? "center" : "flex-start",
    textAlign: isPortrait ? "center" : "left"
  }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: -60 * scale,
      left: isPortrait ? "50%" : -60 * scale,
      transform: isPortrait ? "translateX(-50%)" : "none",
      fontSize: 200 * scale,
      color: accentColor,
      opacity: 0.1,
      fontFamily: "serif",
      lineHeight: 1,
      zIndex: 0
    }, children: '"' }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: `"${quote}"`,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          lineHeight: 1.3,
          margin: 0,
          letterSpacing: "-0.02em",
          color: textColor,
          transform: `translateY(${(1 - titleY) * -30}px)`,
          opacity: titleOpacity,
          zIndex: 1,
          marginBottom: 60 * scale,
          textShadow: "0 4px 20px rgba(0,0,0,0.5)"
        }
      }
    ),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      display: "flex",
      alignItems: "center",
      gap: 30 * scale,
      transform: `translateX(${(1 - (0,esm.spring)({ frame: frame - 20, fps, config: { damping: 12 } })) * -50}px)`,
      opacity: (0,esm.interpolate)(frame - 20, [0, 10], [0, 1], { extrapolateRight: "clamp" }),
      zIndex: 1
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        esm.Img,
        {
          src: avatarUrl,
          style: {
            width: 100 * scale,
            height: 100 * scale,
            borderRadius: "50%",
            objectFit: "cover",
            border: `3px solid ${accentColor}`,
            boxShadow: `0 10px 30px ${accentColor}40`
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column", gap: 4 * scale, textAlign: "left" }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: 32 * scale,
          fontWeight: 800,
          fontFamily: interFont,
          color: "#fff"
        }, children: author }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: 20 * scale,
          color: accentColor,
          fontWeight: 600,
          textTransform: "uppercase",
          letterSpacing: "0.05em"
        }, children: role })
      ] })
    ] })
  ] }) });
};
registerTemplate({
  tags: [],
  id: "team-quote-01",
  name: "Impactful Quote",
  description: "A bold, cinematic quote layout with a prominent author avatar and role.",
  category: "business-marketing",
  durationInFrames: 180,
  fps: 30,
  component: TeamQuote,
  schema: teamQuoteSchema,
  defaultProps: teamQuoteSchema.parse({})
});

;// ./src/templates/business-marketing/TeamRosterGrid.tsx










const teamRosterSchema = lib.z.object({
  title: lib.z.string().default("Meet The Experts"),
  subtitle: lib.z.string().default("Industry leaders ready to help you scale."),
  members: lib.z.array(lib.z.object({
    name: lib.z.string(),
    role: lib.z.string(),
    avatarUrl: lib.z.string(),
    color: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { name: "Sarah Jenkins", role: "Chief Marketing Officer", avatarUrl: "https://images.unsplash.com/photo-1494790108377-be9c29b29330?w=300", color: "#3b82f6" },
    { name: "Marcus Chen", role: "Head of Growth", avatarUrl: "https://images.unsplash.com/photo-1599566150163-29194dcaad36?w=300", color: "#10b981" },
    { name: "Elena Rodriguez", role: "VP of Product", avatarUrl: "https://images.unsplash.com/photo-1535713875002-d1d0cf377fde?w=300", color: "#f43f5e" },
    { name: "David Kim", role: "Lead Data Scientist", avatarUrl: "https://images.unsplash.com/photo-1527980965255-d3b416303d12?w=300", color: "#a855f7" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  cardBgColor: lib.z.string().default(COLORS.surface)
});
const TeamRosterGrid = ({
  title,
  subtitle,
  members,
  backgroundColor,
  textColor,
  cardBgColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalMembers = members.length;
  const cols = isPortrait ? 2 : Math.min(4, Math.ceil(Math.sqrt(totalMembers)));
  const paddingX = isPortrait ? 40 * scale : 120 * scale;
  const gap = isPortrait ? 20 * scale : 40 * scale;
  const availableWidth = width - paddingX * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 800,
            fontSize: (isPortrait ? 60 : 72) * scale,
            margin: 0,
            letterSpacing: "-0.02em",
            color: textColor
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 24 : 32) * scale,
            opacity: 0.6,
            marginTop: 10 * scale
          }
        }
      )
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -40%)",
      display: "grid",
      gridTemplateColumns: `repeat(${cols}, 1fr)`,
      gap,
      width: availableWidth,
      maxWidth: 1400 * scale
    }, children: members.map((member, i) => {
      const delay = 15 + i * 5;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        backgroundColor: cardBgColor,
        borderRadius: 24 * scale,
        padding: isPortrait ? 20 * scale : 40 * scale,
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        textAlign: "center",
        transform: `translateY(${(1 - pop) * 100}px)`,
        opacity: op,
        boxShadow: "0 20px 40px rgba(0,0,0,0.2)",
        borderTop: `4px solid ${member.color}`,
        position: "relative",
        overflow: "hidden"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          width: (isPortrait ? 100 : 160) * scale,
          height: (isPortrait ? 100 : 160) * scale,
          borderRadius: "50%",
          marginBottom: 20 * scale,
          padding: 4 * scale,
          backgroundColor: member.color,
          boxShadow: `0 10px 20px ${member.color}40`
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Img,
          {
            src: member.avatarUrl,
            style: {
              width: "100%",
              height: "100%",
              borderRadius: "50%",
              objectFit: "cover"
            }
          }
        ) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: (isPortrait ? 20 : 28) * scale,
          fontWeight: 800,
          fontFamily: interFont,
          color: "#fff",
          marginBottom: 8 * scale
        }, children: member.name }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: (isPortrait ? 14 : 18) * scale,
          fontWeight: 500,
          color: member.color,
          textTransform: "uppercase",
          letterSpacing: "0.05em"
        }, children: member.role })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "team-roster-grid-01",
  name: "Team Roster Grid",
  description: "A responsive grid of team members with avatars, names, and roles.",
  category: "business-news",
  durationInFrames: 150,
  fps: 30,
  component: TeamRosterGrid,
  schema: teamRosterSchema,
  defaultProps: teamRosterSchema.parse({})
});

;// ./src/templates/business-marketing/TechStackOrbit.tsx










const techStackOrbitSchema = lib.z.object({
  title: lib.z.string().default("Integrates With Everything"),
  centerLogoUrl: lib.z.string().default("https://upload.wikimedia.org/wikipedia/commons/a/a9/Amazon_logo.svg"),
  orbitLogos: lib.z.array(lib.z.string()).default([
    "https://upload.wikimedia.org/wikipedia/commons/2/2f/Google_2015_logo.svg",
    "https://upload.wikimedia.org/wikipedia/commons/e/e8/Tesla_logo.png",
    "https://upload.wikimedia.org/wikipedia/commons/0/08/Netflix_2015_logo.svg",
    "https://upload.wikimedia.org/wikipedia/commons/f/fa/Apple_logo_black.svg",
    "https://upload.wikimedia.org/wikipedia/commons/4/44/Microsoft_logo.svg",
    "https://upload.wikimedia.org/wikipedia/commons/b/b8/YouTube_Logo_2017.svg"
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  orbitColor: lib.z.string().default("rgba(255,255,255,0.1)")
});
const TechStackOrbit = ({
  title,
  centerLogoUrl,
  orbitLogos,
  backgroundColor,
  textColor,
  orbitColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalOrbitItems = orbitLogos.length;
  const anglePerItem = 360 / Math.max(1, totalOrbitItems);
  const maxRadius = isPortrait ? width * 0.35 : height * 0.35;
  const rotation = (0,esm.interpolate)(frame, [0, 300], [0, 360], { extrapolateRight: "extend" });
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -50}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      width: maxRadius * 2,
      height: maxRadius * 2
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        border: `2px dashed ${orbitColor}`,
        borderRadius: "50%",
        transform: `rotate(${rotation * 0.5}deg)`
      } }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: maxRadius * 0.3,
        left: maxRadius * 0.3,
        right: maxRadius * 0.3,
        bottom: maxRadius * 0.3,
        border: `1px solid ${orbitColor}`,
        borderRadius: "50%",
        transform: `rotate(${-rotation}deg)`
      } }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: `translate(-50%, -50%) scale(${(0,esm.spring)({ frame: frame - 10, fps, config: { damping: 12 } })})`,
        width: 140 * scale,
        height: 140 * scale,
        backgroundColor: "#fff",
        borderRadius: "50%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        boxShadow: "0 20px 40px rgba(0,0,0,0.3), 0 0 40px rgba(255,255,255,0.2)",
        zIndex: 10,
        padding: 20 * scale
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: centerLogoUrl, style: { maxWidth: "100%", maxHeight: "100%", objectFit: "contain" } }) }),
      orbitLogos.map((logo, i) => {
        const isOnOuterRing = i % 2 === 0;
        const r = isOnOuterRing ? maxRadius : maxRadius * 0.7;
        const startAngle = i * anglePerItem;
        const currentAngle = isOnOuterRing ? startAngle + rotation : startAngle - rotation * 1.5;
        const rad = (currentAngle - 90) * Math.PI / 180;
        const x = Math.cos(rad) * r;
        const y = Math.sin(rad) * r;
        const delay = 30 + i * 5;
        const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 12, mass: 0.8 } });
        return /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          top: "50%",
          left: "50%",
          // Translate to orbit position, then counter-rotate so the logo stays upright
          transform: `translate(-50%, -50%) translate(${x}px, ${y}px) scale(${pop})`,
          width: 80 * scale,
          height: 80 * scale,
          backgroundColor: "#fff",
          borderRadius: "50%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          boxShadow: "0 10px 20px rgba(0,0,0,0.2)",
          zIndex: isOnOuterRing ? 5 : 2,
          padding: 16 * scale
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: logo, style: { maxWidth: "100%", maxHeight: "100%", objectFit: "contain" } }) }, i);
      })
    ] })
  ] });
};
registerTemplate({
  tags: [],
  id: "tech-stack-orbit-01",
  name: "Tech Stack Orbit",
  description: "Dynamic planetary orbit showing integrations circling around a central product logo.",
  category: "business-marketing",
  durationInFrames: 240,
  fps: 30,
  component: TechStackOrbit,
  schema: techStackOrbitSchema,
  defaultProps: techStackOrbitSchema.parse({})
});

;// ./src/templates/business-marketing/TestimonialCarousel.tsx










const testimonialCarouselSchema = lib.z.object({
  title: lib.z.string().default("What Our Clients Say"),
  testimonials: lib.z.array(lib.z.object({
    name: lib.z.string(),
    role: lib.z.string(),
    text: lib.z.string(),
    avatarUrl: lib.z.string(),
    rating: lib.z.number().min(1).max(5).default(5),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    {
      name: "Sarah Jenkins",
      role: "CMO at TechFlow",
      text: '"This product completely transformed our marketing workflow. We saw a 300% increase in lead generation within the first month alone."',
      avatarUrl: "https://images.unsplash.com/photo-1494790108377-be9c29b29330?w=150",
      rating: 5
    },
    {
      name: "Marcus Chen",
      role: "Founder, StartupX",
      text: '"The analytics dashboard is incredibly intuitive. I finally understand where our marketing spend is actually going."',
      avatarUrl: "https://images.unsplash.com/photo-1599566150163-29194dcaad36?w=150",
      rating: 5
    },
    {
      name: "Elena Rodriguez",
      role: "VP of Sales",
      text: '"Customer support is top-notch. Any time we had an issue, they resolved it in minutes. Highly recommend to any growing team."',
      avatarUrl: "https://images.unsplash.com/photo-1535713875002-d1d0cf377fde?w=150",
      rating: 4
    }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  cardBgColor: lib.z.string().default(COLORS.surface),
  accentColor: lib.z.string().default(COLORS.accent)
});
const TestimonialCarousel = ({
  title,
  testimonials,
  backgroundColor,
  textColor,
  cardBgColor,
  accentColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalFrames = 300;
  const framesPerSlide = Math.floor(totalFrames / Math.max(1, testimonials.length));
  const activeIndex = Math.min(
    Math.floor(frame / framesPerSlide),
    testimonials.length - 1
  );
  const slideFrame = frame % framesPerSlide;
  const isExiting = slideFrame > framesPerSlide - 15 && activeIndex < testimonials.length - 1;
  const enterSpring = (0,esm.spring)({ frame: slideFrame, fps, config: { damping: 14, mass: 1.2 } });
  const exitSpring = isExiting ? (0,esm.spring)({ frame: slideFrame - (framesPerSlide - 15), fps, config: { damping: 14 } }) : 0;
  const cardScale = (0,esm.interpolate)(enterSpring - exitSpring, [0, 1], [0.9, 1]);
  const cardY = (0,esm.interpolate)(enterSpring - exitSpring, [0, 1], [100, 0]);
  const cardOpacity = (0,esm.interpolate)(enterSpring - exitSpring, [0, 1], [0, 1]);
  const activeTestimonial = testimonials[activeIndex];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 120 * scale : 100 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: `translate(-50%, -50%) scale(${cardScale}) translateY(${cardY}px)`,
      opacity: cardOpacity,
      width: isPortrait ? width * 0.85 : width * 0.6,
      backgroundColor: cardBgColor,
      borderRadius: 30 * scale,
      padding: isPortrait ? 50 * scale : 80 * scale,
      boxShadow: "0 30px 60px rgba(0,0,0,0.3)",
      border: `1px solid ${COLORS.border}`,
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      textAlign: "center"
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        fontSize: 80 * scale,
        color: accentColor,
        opacity: 0.5,
        lineHeight: 0.5,
        marginBottom: 20 * scale,
        fontFamily: "serif"
      }, children: '"' }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        fontSize: (isPortrait ? 32 : 40) * scale,
        fontWeight: 500,
        lineHeight: 1.4,
        marginBottom: 50 * scale,
        color: COLORS.textPrimary
      }, children: activeTestimonial == null ? void 0 : activeTestimonial.text }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { display: "flex", gap: 8 * scale, marginBottom: 30 * scale }, children: Array.from({ length: 5 }).map((_, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: 24 * scale, height: 24 * scale, viewBox: "0 0 24 24", fill: i < ((activeTestimonial == null ? void 0 : activeTestimonial.rating) || 5) ? "#fbbf24" : "transparent", stroke: i < ((activeTestimonial == null ? void 0 : activeTestimonial.rating) || 5) ? "#fbbf24" : "rgba(255,255,255,0.2)", strokeWidth: "2", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("polygon", { points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2" }) }, i)) }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 20 * scale }, children: [
        (activeTestimonial == null ? void 0 : activeTestimonial.avatarUrl) && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Img,
          {
            src: activeTestimonial.avatarUrl,
            style: {
              width: 80 * scale,
              height: 80 * scale,
              borderRadius: "50%",
              objectFit: "cover",
              border: `3px solid ${accentColor}`
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { textAlign: "left" }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 24 * scale, fontWeight: 700 }, children: activeTestimonial == null ? void 0 : activeTestimonial.name }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 18 * scale, color: COLORS.textSecondary }, children: activeTestimonial == null ? void 0 : activeTestimonial.role })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      bottom: 80 * scale,
      left: 0,
      width: "100%",
      display: "flex",
      justifyContent: "center",
      gap: 12 * scale,
      opacity: titleOpacity
    }, children: testimonials.map((_, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      width: i === activeIndex ? 30 * scale : 12 * scale,
      height: 12 * scale,
      borderRadius: 6 * scale,
      backgroundColor: i === activeIndex ? accentColor : "rgba(255,255,255,0.2)",
      transition: "all 0.3s ease"
    } }, i)) })
  ] });
};
registerTemplate({
  tags: [],
  id: "testimonial-carousel-01",
  name: "Dynamic Testimonial Carousel",
  description: "Automatically divides the video duration evenly among all provided testimonials, animating them in and out.",
  category: "business-marketing",
  durationInFrames: 300,
  fps: 30,
  component: TestimonialCarousel,
  schema: testimonialCarouselSchema,
  defaultProps: testimonialCarouselSchema.parse({})
});

;// ./src/templates/business-marketing/TrustMetricsTicker.tsx










const trustMetricsSchema = lib.z.object({
  title: lib.z.string().default("By The Numbers"),
  metrics: lib.z.array(lib.z.object({
    number: lib.z.string(),
    label: lib.z.string(),
    icon: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { number: "1M+", label: "Active Users", icon: "\u{1F465}" },
    { number: "99.9%", label: "Uptime SLA", icon: "\u26A1" },
    { number: "24/7", label: "Support", icon: "\u{1F3A7}" },
    { number: "50+", label: "Countries", icon: "\u{1F30D}" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  accentColor: lib.z.string().default(COLORS.accent)
});
const TrustMetricsTicker = ({
  title,
  metrics,
  textColor,
  accentColor,
  backgroundColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const cols = isPortrait ? 2 : Math.min(4, metrics.length);
  const gap = isPortrait ? 40 * scale : 60 * scale;
  const paddingX = isPortrait ? 40 * scale : 100 * scale;
  const availableWidth = width - paddingX * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      background: `radial-gradient(circle at 50% 50%, ${accentColor}20 0%, transparent 60%)`
    } }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 150 * scale : 150 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em",
          color: accentColor,
          textTransform: "uppercase"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)",
      display: "grid",
      gridTemplateColumns: `repeat(${cols}, 1fr)`,
      gap,
      width: availableWidth,
      maxWidth: 1400 * scale
    }, children: metrics.map((m, i) => {
      const delay = 20 + i * 8;
      const pop = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 12, mass: 1.2 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        textAlign: "center",
        transform: `scale(${pop}) translateY(${(1 - pop) * 40}px)`,
        opacity: op,
        gap: 16 * scale
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: 48 * scale,
          opacity: 0.8
        }, children: m.icon }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: (isPortrait ? 72 : 96) * scale,
          fontWeight: 900,
          fontFamily: interFont,
          letterSpacing: "-0.03em",
          color: "#fff",
          textShadow: `0 10px 30px ${accentColor}40`,
          lineHeight: 1
        }, children: m.number }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: 24 * scale,
          fontWeight: 600,
          color: COLORS.textSecondary,
          textTransform: "uppercase",
          letterSpacing: "0.1em"
        }, children: m.label })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "trust-metrics-ticker-01",
  name: "Trust Metrics Grid",
  description: "A bold, punchy grid of stats/numbers to build instant social proof.",
  category: "business-marketing",
  durationInFrames: 150,
  fps: 30,
  component: TrustMetricsTicker,
  schema: trustMetricsSchema,
  defaultProps: trustMetricsSchema.parse({})
});

;// ./src/templates/business-marketing/TwitterPostMockup.tsx








const twitterPostMockupSchema = lib.z.object({
  name: lib.z.string().default("Sahil Khanna"),
  handle: lib.z.string().default("@SahilKhanna"),
  avatarUrl: lib.z.string().default("https://images.unsplash.com/photo-1550525811-e5869dd03032?w=150"),
  verified: lib.z.boolean().default(true),
  content: lib.z.string().default("Video editing used to take me 6 hours per video. Now with AI, it takes 15 minutes. The leverage here is absolutely insane. \u{1F92F}\u{1F3AC}"),
  time: lib.z.string().default("10:42 AM \xB7 Oct 12, 2024"),
  views: lib.z.string().default("1.2M"),
  retweets: lib.z.string().default("4,291"),
  quotes: lib.z.string().default("184"),
  likes: lib.z.string().default("24.5K"),
  bookmarks: lib.z.string().default("3,812"),
  darkMode: lib.z.boolean().default(true)
});
const TwitterPostMockup = ({
  name,
  handle,
  avatarUrl,
  verified,
  content,
  time,
  views,
  retweets,
  quotes,
  likes,
  bookmarks,
  darkMode
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const pop = (0,esm.spring)({ frame: frame - 10, fps, config: { damping: 14, mass: 1.2 } });
  const op = (0,esm.interpolate)(frame - 10, [0, 10], [0, 1], { extrapolateRight: "clamp" });
  const bg = darkMode ? "#000000" : "#ffffff";
  const textPrimary = darkMode ? "#d9d9d9" : "#0f1419";
  const textSecondary = darkMode ? "#71767b" : "#536471";
  const borderCol = darkMode ? "#2f3336" : "#eff3f4";
  const accent = "#1d9bf0";
  const cardWidth = isPortrait ? width * 0.9 : 600 * scale;
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(darkMode ? "#15202b" : "#f7f9f9", backgroundControls), fontFamily: interFont, alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
    width: cardWidth,
    backgroundColor: bg,
    borderRadius: 16 * scale,
    border: `1px solid ${borderCol}`,
    padding: `${16 * scale}px ${16 * scale}px ${4 * scale}px`,
    display: "flex",
    flexDirection: "column",
    boxShadow: darkMode ? "0 20px 40px rgba(0,0,0,0.8)" : "0 10px 30px rgba(0,0,0,0.1)",
    transform: `scale(${(0,esm.interpolate)(pop, [0, 1], [0.9, 1])}) translateY(${(1 - pop) * 40}px)`,
    opacity: op
  }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 12 * scale }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 12 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: avatarUrl, style: { width: 48 * scale, height: 48 * scale, borderRadius: "50%", objectFit: "cover" } }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column" }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontSize: 16 * scale, fontWeight: 700, color: textPrimary, display: "flex", alignItems: "center", gap: 4 * scale }, children: [
            name,
            verified && /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 18 * scale, height: 18 * scale, fill: accent, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M22.5 12.5c0-1.58-.875-2.95-2.148-3.6.154-.435.238-.905.238-1.4 0-2.21-1.71-3.998-3.918-3.998-.47 0-.92.084-1.336.25C14.818 2.415 13.51 1.5 12 1.5s-2.816.917-3.337 2.25c-.416-.165-.866-.25-1.336-.25-2.21 0-3.918 1.792-3.918 4 0 .495.084.965.238 1.4-1.273.65-2.148 2.02-2.148 3.6 0 1.46.756 2.76 1.88 3.48-.066.36-.102.73-.102 1.12 0 2.21 1.71 4 3.918 4 .56 0 1.1-.13 1.593-.36.574 1.15 1.734 1.94 3.076 1.94s2.503-.79 3.076-1.94c.493.23 1.033.36 1.593.36 2.208 0 3.918-1.79 3.918-4 0-.39-.036-.76-.102-1.12 1.124-.72 1.88-2.02 1.88-3.48zm-10.46 3.88L7.1 11.43l1.83-1.83 2.76 2.77 6.07-6.07 1.83 1.83-7.55 8.25z" }) })
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 15 * scale, color: textSecondary }, children: handle })
        ] })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: textSecondary, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M3 12c0-1.1.9-2 2-2s2 .9 2 2-.9 2-2 2-2-.9-2-2zm9 2c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm7 0c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2z" }) })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      fontSize: 20 * scale,
      lineHeight: 1.4,
      color: textPrimary,
      whiteSpace: "pre-wrap",
      marginBottom: 16 * scale
    }, children: content }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      display: "flex",
      alignItems: "center",
      gap: 8 * scale,
      fontSize: 15 * scale,
      color: textSecondary,
      paddingBottom: 16 * scale,
      borderBottom: `1px solid ${borderCol}`,
      marginBottom: 16 * scale
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { children: time }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { children: "\xB7" }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontWeight: 700, color: textPrimary }, children: views }),
      " Views"
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      display: "flex",
      alignItems: "center",
      gap: 20 * scale,
      fontSize: 15 * scale,
      color: textSecondary,
      paddingBottom: 16 * scale,
      borderBottom: `1px solid ${borderCol}`,
      marginBottom: 4 * scale
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontWeight: 700, color: textPrimary }, children: retweets }),
        " Retweets"
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontWeight: 700, color: textPrimary }, children: quotes }),
        " Quotes"
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontWeight: 700, color: textPrimary }, children: likes }),
        " Likes"
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontWeight: 700, color: textPrimary }, children: bookmarks }),
        " Bookmarks"
      ] })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-around",
      padding: `${8 * scale}px 0`
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 22 * scale, height: 22 * scale, fill: textSecondary, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M1.751 10c0-4.42 3.584-8 8.005-8h4.366c4.49 0 8.129 3.64 8.129 8.13 0 2.96-1.607 5.68-4.196 7.11l-8.054 4.46v-3.69h-.067c-4.49.1-8.183-3.51-8.183-8.01zm8.005-6c-3.317 0-6.005 2.69-6.005 6 0 3.37 2.77 6.08 6.138 6.01l.351-.01h1.761v2.3l5.087-2.81c1.951-1.08 3.163-3.13 3.163-5.36 0-3.39-2.744-6.13-6.129-6.13H9.756z" }) }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 22 * scale, height: 22 * scale, fill: textSecondary, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M4.5 3.88l4.432 4.14-1.364 1.46L5.5 7.55V16c0 1.1.896 2 2 2H13v2H7.5c-2.209 0-4-1.79-4-4V7.55L1.432 9.48.068 8.02 4.5 3.88zM16.5 6H11V4h5.5c2.209 0 4 1.79 4 4v8.45l2.068-1.93 1.364 1.46-4.432 4.14-4.432-4.14 1.364-1.46 2.068 1.93V8c0-1.1-.896-2-2-2z" }) }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        "svg",
        {
          viewBox: "0 0 24 24",
          width: 22 * scale,
          height: 22 * scale,
          fill: frame > 30 ? "#f91880" : textSecondary,
          style: { transform: `scale(${(0,esm.interpolate)((0,esm.spring)({ frame: frame - 30, fps, config: { damping: 10 } }), [0, 0.5, 1], [1, 1.4, 1])})` },
          children: frame > 30 ? /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M20.884 13.19c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z" }) : /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M16.697 5.5c-1.222-.06-2.679.51-3.89 2.16l-.805 1.09-.806-1.09C9.984 6.01 8.526 5.44 7.304 5.5c-1.243.07-2.349.78-2.91 1.91-.552 1.12-.633 2.78.479 4.82 1.074 1.97 3.257 4.27 7.129 6.61 3.87-2.34 6.052-4.64 7.126-6.61 1.111-2.04 1.03-3.7.477-4.82-.561-1.13-1.666-1.84-2.908-1.91zm4.187 7.69c-1.351 2.48-4.001 5.12-8.379 7.67l-.503.3-.504-.3c-4.379-2.55-7.029-5.19-8.382-7.67-1.36-2.5-1.41-4.86-.514-6.67.887-1.79 2.647-2.91 4.601-3.01 1.651-.09 3.368.56 4.798 2.01 1.429-1.45 3.146-2.1 4.796-2.01 1.954.1 3.714 1.22 4.601 3.01.896 1.81.846 4.17-.514 6.67z" })
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 22 * scale, height: 22 * scale, fill: textSecondary, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M4 4.5C4 3.12 5.119 2 6.5 2h11C18.881 2 20 3.12 20 4.5v18.44l-8-5.71-8 5.71V4.5zM6.5 4c-.276 0-.5.22-.5.5v14.56l6-4.29 6 4.29V4.5c0-.28-.224-.5-.5-.5h-11z" }) }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 22 * scale, height: 22 * scale, fill: textSecondary, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M12 2.59l5.7 5.7-1.41 1.42L13 6.41V16h-2V6.41l-3.3 3.3-1.41-1.42L12 2.59zM21 15l-.02 3.51c0 1.38-1.12 2.49-2.5 2.49H5.5C4.11 21 3 19.88 3 18.5V15h2v3.5c0 .28.22.5.5.5h12.98c.28 0 .5-.22.5-.5L19 15h2z" }) })
    ] })
  ] }) });
};
registerTemplate({
  tags: [],
  id: "twitter-post-mockup-01",
  name: "Twitter / X Post Mockup",
  description: "A pixel-perfect simulation of a viral X post with animated like button.",
  category: "platform-mockups",
  durationInFrames: 150,
  fps: 30,
  component: TwitterPostMockup,
  schema: twitterPostMockupSchema,
  defaultProps: twitterPostMockupSchema.parse({})
});

;// ./src/templates/business-marketing/UsVsThemTable.tsx










const vsTableSchema = lib.z.object({
  title: lib.z.string().default("Why Us?"),
  competitors: lib.z.array(lib.z.string()).default(["Us", "Them"]),
  features: lib.z.array(lib.z.object({
    name: lib.z.string(),
    values: lib.z.array(lib.z.boolean()),
    backgroundColor: lib.z.string().default(COLORS.bg)
    // true = check, false = X
  })).default([
    { name: "AI-Powered Automation", values: [true, false] },
    { name: "24/7 Dedicated Support", values: [true, false] },
    { name: "Unlimited Cloud Storage", values: [true, true] },
    { name: "Custom API Integrations", values: [true, false] },
    { name: "No Hidden Fees", values: [true, false] }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  accentColor: lib.z.string().default(COLORS.accent)
});
const UsVsThemTable = ({
  title,
  competitors,
  features,
  backgroundColor,
  textColor,
  accentColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const paddingX = isPortrait ? 40 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  const featureColWidth = availableWidth * 0.4;
  const valueColWidth = availableWidth * 0.6 / competitors.length;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 220 * scale : 200 * scale,
      left: paddingX,
      width: availableWidth,
      backgroundColor: "rgba(255,255,255,0.02)",
      borderRadius: 24 * scale,
      border: `1px solid ${COLORS.border}`,
      overflow: "hidden",
      boxShadow: "0 20px 40px rgba(0,0,0,0.2)"
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        display: "flex",
        backgroundColor: COLORS.surfaceLight,
        padding: `${20 * scale}px 0`,
        borderBottom: "1px solid rgba(255,255,255,0.1)"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: featureColWidth, paddingLeft: 30 * scale, fontSize: 18 * scale, fontWeight: 600, color: COLORS.textMuted }, children: "FEATURES" }),
        competitors.map((comp, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          width: valueColWidth,
          textAlign: "center",
          fontSize: 24 * scale,
          fontWeight: 800,
          fontFamily: interFont,
          color: i === 0 ? accentColor : "rgba(255,255,255,0.7)",
          textTransform: "uppercase",
          letterSpacing: "0.05em"
        }, children: comp }, i))
      ] }),
      features.map((feat, r) => {
        const rowDelay = 20 + r * 10;
        const pop = (0,esm.spring)({ frame: frame - rowDelay, fps, config: { damping: 14 } });
        const op = (0,esm.interpolate)(frame - rowDelay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
        return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          display: "flex",
          padding: `${24 * scale}px 0`,
          borderBottom: r < features.length - 1 ? "1px solid rgba(255,255,255,0.05)" : "none",
          alignItems: "center",
          backgroundColor: r % 2 === 0 ? "transparent" : "rgba(255,255,255,0.01)",
          opacity: op,
          transform: `translateY(${(1 - pop) * 20}px)`
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            width: featureColWidth,
            paddingLeft: 30 * scale,
            fontSize: 20 * scale,
            fontWeight: 500,
            color: COLORS.textPrimary
          }, children: feat.name }),
          feat.values.map((val, c) => {
            const valDelay = rowDelay + 5 + c * 5;
            const valPop = (0,esm.spring)({ frame: frame - valDelay, fps, config: { damping: 12, mass: 0.8 } });
            return /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
              width: valueColWidth,
              display: "flex",
              justifyContent: "center",
              alignItems: "center"
            }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
              width: 40 * scale,
              height: 40 * scale,
              borderRadius: "50%",
              backgroundColor: val ? `${accentColor}20` : "rgba(239, 68, 68, 0.1)",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              transform: `scale(${valPop})`,
              boxShadow: val ? `0 0 15px ${accentColor}40` : "none"
            }, children: val ? /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { width: 24 * scale, height: 24 * scale, viewBox: "0 0 24 24", fill: "none", stroke: accentColor, strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("polyline", { points: "20 6 9 17 4 12" }) }) : /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { width: 20 * scale, height: 20 * scale, viewBox: "0 0 24 24", fill: "none", stroke: "#ef4444", strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round", children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
            ] }) }) }, c);
          })
        ] }, r);
      })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 220 * scale : 200 * scale,
      left: paddingX + featureColWidth,
      width: valueColWidth,
      height: (features.length + 1) * (72 * scale),
      // approx height, would be exact in real DOM
      bottom: 0,
      backgroundColor: `${accentColor}05`,
      borderLeft: `2px solid ${accentColor}40`,
      borderRight: `2px solid ${accentColor}40`,
      pointerEvents: "none",
      opacity: (0,esm.interpolate)(frame - 20, [0, 20], [0, 1], { extrapolateRight: "clamp" }),
      zIndex: 10
      // Ensure it's on top of table rows
    } })
  ] });
};
registerTemplate({
  tags: [],
  id: "us-vs-them-table-01",
  name: "Dynamic Us Vs Them Table",
  description: "A responsive comparison matrix that animates checkmarks and cross marks row by row.",
  category: "business-marketing",
  durationInFrames: 180,
  fps: 30,
  component: UsVsThemTable,
  schema: vsTableSchema,
  defaultProps: vsTableSchema.parse({})
});

;// ./src/templates/business-marketing/VerticalTimeline.tsx










const verticalTimelineSchema = lib.z.object({
  title: lib.z.string().default("Company History"),
  events: lib.z.array(lib.z.object({
    date: lib.z.string(),
    title: lib.z.string(),
    desc: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { date: "2020", title: "Founded", desc: "Started in a small garage in San Francisco." },
    { date: "2021", title: "Seed Funding", desc: "Raised $2M to build the MVP." },
    { date: "2022", title: "Launch", desc: "Released to the public with 10k waitlist." },
    { date: "2023", title: "Series A", desc: "Raised $15M to scale the team globally." },
    { date: "2024", title: "1M Users", desc: "Crossed the 1 million active users milestone." }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  primaryColor: lib.z.string().default("#f43f5e")
});
const VerticalTimeline = ({
  title,
  events,
  backgroundColor,
  textColor,
  primaryColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width, height } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalEvents = events.length;
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  const startY = isPortrait ? height * 0.25 : height * 0.3;
  const endY = height * 0.85;
  const pathHeight = endY - startY;
  const spacingY = pathHeight / Math.max(1, totalEvents - 1);
  const lineProgress = (0,esm.spring)({ frame: frame - 20, fps, config: { damping: 20, mass: 2 } });
  const currentLineHeight = lineProgress * pathHeight;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 100 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: "center",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      EditableText,
      {
        text: title,
        style: {
          fontFamily: interFont,
          fontWeight: 800,
          fontSize: (isPortrait ? 60 : 72) * scale,
          margin: 0,
          letterSpacing: "-0.02em"
        }
      }
    ) }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: startY,
      left: isPortrait ? paddingX + 40 * scale : "50%",
      width: 6 * scale,
      height: pathHeight,
      backgroundColor: "rgba(255,255,255,0.1)",
      borderRadius: 3 * scale,
      transform: "translateX(-50%)",
      zIndex: 0
    } }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: startY,
      left: isPortrait ? paddingX + 40 * scale : "50%",
      width: 6 * scale,
      height: currentLineHeight,
      backgroundColor: primaryColor,
      borderRadius: 3 * scale,
      transform: "translateX(-50%)",
      boxShadow: `0 0 15px ${primaryColor}80`,
      zIndex: 1
    } }),
    events.map((event, i) => {
      const nodeY = startY + i * spacingY;
      const isLeft = !isPortrait && i % 2 === 0;
      const reachTime = 20 + i / Math.max(1, totalEvents - 1) * 40;
      const pop = (0,esm.spring)({ frame: frame - reachTime, fps, config: { damping: 10 } });
      const opacity = (0,esm.interpolate)(frame - reachTime, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      const dotSize = 32 * scale;
      const cardWidth = isPortrait ? availableWidth - (dotSize + 40 * scale) : 400 * scale;
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        position: "absolute",
        top: nodeY,
        left: isPortrait ? paddingX + 40 * scale : "50%",
        transform: "translate(-50%, -50%)",
        zIndex: 2
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          width: dotSize,
          height: dotSize,
          backgroundColor: frame >= reachTime ? primaryColor : backgroundColor,
          border: `${4 * scale}px solid ${frame >= reachTime ? primaryColor : "rgba(255,255,255,0.3)"}`,
          borderRadius: "50%",
          transform: `scale(${pop || 1})`,
          // stay 1 if before pop, then pop
          transition: "background-color 0.2s, border-color 0.2s",
          boxShadow: frame >= reachTime ? `0 0 20px ${primaryColor}` : "none",
          position: "relative"
        } }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          position: "absolute",
          top: "50%",
          // If portrait, push everything right. If landscape, push left or right.
          left: isPortrait ? dotSize + 20 * scale : isLeft ? -(dotSize / 2 + cardWidth + 40 * scale) : dotSize / 2 + 40 * scale,
          transform: `translateY(-50%) translateX(${(1 - pop) * (isLeft ? 20 : -20)}px)`,
          opacity,
          width: cardWidth,
          display: "flex",
          flexDirection: "column",
          gap: 8 * scale,
          textAlign: isLeft ? "right" : "left"
        }, children: [
          !isPortrait && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            position: "absolute",
            top: "50%",
            [isLeft ? "right" : "left"]: -(40 * scale),
            width: 30 * scale,
            height: 2 * scale,
            backgroundColor: primaryColor,
            transform: "translateY(-50%)",
            opacity: 0.5
          } }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 20 * scale,
            fontWeight: 800,
            color: primaryColor,
            fontFamily: interFont,
            letterSpacing: "0.1em"
          }, children: event.date }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 28 * scale,
            fontWeight: 700,
            color: textColor,
            fontFamily: interFont
          }, children: event.title }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: 18 * scale,
            color: COLORS.textSecondary,
            lineHeight: 1.4
          }, children: event.desc })
        ] })
      ] }, i);
    })
  ] });
};
registerTemplate({
  tags: [],
  id: "vertical-timeline-01",
  name: "Dynamic Vertical Timeline",
  description: "A scrolling history timeline that draws a line downwards connecting N events.",
  category: "business-marketing",
  durationInFrames: 210,
  fps: 30,
  component: VerticalTimeline,
  schema: verticalTimelineSchema,
  defaultProps: verticalTimelineSchema.parse({})
});

;// ./src/templates/business-marketing/WebinarAgenda.tsx










const webinarAgendaSchema = lib.z.object({
  title: lib.z.string().default("Summit 2024"),
  subtitle: lib.z.string().default("Day 1 Schedule"),
  sessions: lib.z.array(lib.z.object({
    time: lib.z.string(),
    title: lib.z.string(),
    speaker: lib.z.string(),
    backgroundColor: lib.z.string().default(COLORS.bg)
  })).default([
    { time: "09:00 AM", title: "Opening Keynote", speaker: "CEO Jane Doe" },
    { time: "10:30 AM", title: "The Future of AI", speaker: "Dr. Alan Turing" },
    { time: "01:00 PM", title: "Panel: Scaling Remote Teams", speaker: "Founders Round Table" },
    { time: "03:15 PM", title: "Product Deep Dive", speaker: "Product Team" },
    { time: "05:00 PM", title: "Closing Remarks", speaker: "VP of Marketing" }
  ]),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary),
  accentColor: lib.z.string().default(COLORS.accent)
});
const WebinarAgenda = ({
  title,
  subtitle,
  sessions,
  backgroundColor,
  textColor,
  accentColor
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const isPortrait = useIsPortrait();
  const titleY = (0,esm.spring)({ frame, fps, config: { damping: 12 } });
  const titleOpacity = (0,esm.interpolate)(frame, [0, 15], [0, 1], { extrapolateRight: "clamp" });
  const totalSessions = sessions.length;
  const paddingX = isPortrait ? 60 * scale : 120 * scale;
  const availableWidth = width - paddingX * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground(backgroundColor, backgroundControls), fontFamily: interFont, color: textColor }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      position: "absolute",
      top: isPortrait ? 100 * scale : 80 * scale,
      left: paddingX,
      width: availableWidth,
      textAlign: "left",
      transform: `translateY(${(1 - titleY) * -30}px)`,
      opacity: titleOpacity
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: title,
          style: {
            fontFamily: interFont,
            fontWeight: 900,
            fontSize: (isPortrait ? 80 : 96) * scale,
            margin: 0,
            letterSpacing: "-0.03em",
            color: accentColor,
            textTransform: "uppercase"
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)(
        EditableText,
        {
          text: subtitle,
          style: {
            fontSize: (isPortrait ? 32 : 40) * scale,
            fontWeight: 600,
            opacity: 0.8,
            marginTop: 10 * scale,
            letterSpacing: "0.05em",
            textTransform: "uppercase"
          }
        }
      ),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 100 * scale, height: 4 * scale, backgroundColor: accentColor, marginTop: 20 * scale } })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
      position: "absolute",
      top: isPortrait ? 350 * scale : 280 * scale,
      left: paddingX,
      width: availableWidth,
      display: "flex",
      flexDirection: "column",
      gap: isPortrait ? 30 * scale : 20 * scale
    }, children: sessions.map((session, i) => {
      const delay = 20 + i * 12;
      const slideX = (0,esm.spring)({ frame: frame - delay, fps, config: { damping: 14 } });
      const op = (0,esm.interpolate)(frame - delay, [0, 10], [0, 1], { extrapolateRight: "clamp" });
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        display: "flex",
        flexDirection: isPortrait ? "column" : "row",
        alignItems: isPortrait ? "flex-start" : "center",
        gap: isPortrait ? 8 * scale : 40 * scale,
        transform: `translateX(${(1 - slideX) * 100}px)`,
        opacity: op,
        padding: isPortrait ? `${16 * scale}px 0` : `${20 * scale}px 0`,
        borderBottom: i < totalSessions - 1 ? "1px solid rgba(255,255,255,0.1)" : "none"
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          fontSize: 24 * scale,
          fontWeight: 800,
          fontFamily: interFont,
          color: accentColor,
          width: isPortrait ? "auto" : 160 * scale,
          flexShrink: 0,
          letterSpacing: "0.05em"
        }, children: session.time }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { flex: 1, display: "flex", flexDirection: "column", gap: 4 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            fontSize: (isPortrait ? 28 : 32) * scale,
            fontWeight: 700,
            color: "#fff"
          }, children: session.title }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
            fontSize: 20 * scale,
            color: COLORS.textSecondary,
            display: "flex",
            alignItems: "center",
            gap: 12 * scale
          }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { children: "\u{1F3A4}" }),
            " ",
            session.speaker
          ] })
        ] })
      ] }, i);
    }) })
  ] });
};
registerTemplate({
  tags: [],
  id: "webinar-agenda-01",
  name: "Event Schedule/Agenda",
  description: "A clean list of sessions or schedule items that animate in sequentially.",
  category: "business-marketing",
  durationInFrames: 180,
  fps: 30,
  component: WebinarAgenda,
  schema: webinarAgendaSchema,
  defaultProps: webinarAgendaSchema.parse({})
});

;// ./src/templates/business-marketing/YouTubePlayerMockup.tsx








const youtubePlayerMockupSchema = lib.z.object({
  videoTitle: lib.z.string().default("How I Built a $1M ARR Business with AI"),
  channelName: lib.z.string().default("Lapaas"),
  avatarUrl: lib.z.string().default("https://images.unsplash.com/photo-1550525811-e5869dd03032?w=150"),
  views: lib.z.string().default("1.2M views"),
  timeAgo: lib.z.string().default("2 weeks ago"),
  subscribers: lib.z.string().default("450K"),
  likes: lib.z.string().default("124K"),
  thumbnailUrl: lib.z.string().default("https://images.unsplash.com/photo-1517694712202-14dd9538aa97?w=1000"),
  duration: lib.z.string().default("14:28"),
  backgroundColor: lib.z.string().default("#0f0f0f"),
  textColor: lib.z.string().default("#ffffff"),
  darkMode: lib.z.boolean().default(true)
});
const YouTubePlayerMockup = ({
  videoTitle,
  channelName,
  avatarUrl,
  views,
  timeAgo,
  subscribers,
  likes,
  thumbnailUrl,
  duration,
  darkMode
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps, width } = (0,esm.useVideoConfig)();
  const scale = useScaleFactor();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const pop = (0,esm.spring)({ frame: frame - 10, fps, config: { damping: 14, mass: 1.2 } });
  const op = (0,esm.interpolate)(frame - 10, [0, 10], [0, 1], { extrapolateRight: "clamp" });
  const cardWidth = isPortrait ? width : 800 * scale;
  const bg = darkMode ? "#0f0f0f" : "#ffffff";
  const textPrimary = darkMode ? "#f1f1f1" : "#0f0f0f";
  const textSecondary = darkMode ? "#aaaaaa" : "#606060";
  const buttonBg = darkMode ? "#272727" : "#0000000d";
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { background: resolveCanvasBackground("#0f0f0f", backgroundControls), fontFamily: interFont, alignItems: "center", justifyContent: "center" }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
    width: cardWidth,
    backgroundColor: bg,
    display: "flex",
    flexDirection: "column",
    transform: isPortrait ? "none" : `scale(${(0,esm.interpolate)(pop, [0, 1], [0.95, 1])}) translateY(${(1 - pop) * 40}px)`,
    opacity: isPortrait ? 1 : op,
    boxShadow: isPortrait ? "none" : "0 30px 60px rgba(0,0,0,0.5)",
    borderRadius: isPortrait ? 0 : 16 * scale,
    overflow: "hidden",
    border: isPortrait ? "none" : `1px solid ${darkMode ? "#272727" : "#e5e5e5"}`
  }, children: [
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
      width: "100%",
      aspectRatio: "16/9",
      backgroundColor: "#000",
      position: "relative",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: thumbnailUrl, style: { width: "100%", height: "100%", objectFit: "cover", opacity: 0.8 } }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: "linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 20%)"
      } }),
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
        position: "absolute",
        width: 68 * scale,
        height: 48 * scale,
        backgroundColor: "rgba(0,0,0,0.7)",
        borderRadius: 12 * scale,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        transform: `scale(${(0,esm.interpolate)((0,esm.spring)({ frame: frame - 30, fps, config: { damping: 10 } }), [0, 0.5, 1], [1, 1.2, 1])})`
      }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 24 * scale, height: 24 * scale, fill: "#fff", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M8 5v14l11-7z" }) }) }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { position: "absolute", bottom: 10 * scale, left: 16 * scale, right: 16 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: "100%", height: 4 * scale, backgroundColor: "rgba(255,255,255,0.2)", marginBottom: 12 * scale }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: "35%", height: "100%", backgroundColor: "#ff0000", position: "relative" }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { position: "absolute", right: -6 * scale, top: "50%", transform: "translateY(-50%)", width: 12 * scale, height: 12 * scale, borderRadius: "50%", backgroundColor: "#ff0000" } }) }) }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", justifyContent: "space-between", color: "#fff", fontSize: 13 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 16 * scale }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M8 5v14l11-7z" }) }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M16 21c3.527-1.547 5.999-4.909 5.999-9S19.527 4.547 16 3v2c2.387 1.386 3.999 4.047 3.999 7S18.387 10.614 16 12v2zM12 21V3H8L3 8v8h5l4 5z" }) }),
            /* @__PURE__ */ (0,jsx_runtime.jsxs)("span", { children: [
              "04:12 / ",
              duration
            ] })
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { display: "flex", alignItems: "center", gap: 16 * scale }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z" }) }) })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { padding: `${16 * scale}px ${16 * scale}px ${24 * scale}px` }, children: [
      /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 22 * scale, fontWeight: 700, color: textPrimary, marginBottom: 12 * scale, lineHeight: 1.4 }, children: videoTitle }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: isPortrait ? "column" : "row", justifyContent: "space-between", alignItems: isPortrait ? "flex-start" : "center", gap: 16 * scale, marginBottom: 16 * scale }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 12 * scale }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Img, { src: avatarUrl, style: { width: 40 * scale, height: 40 * scale, borderRadius: "50%", objectFit: "cover" } }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column" }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: 16 * scale, fontWeight: 700, color: textPrimary }, children: channelName }),
            /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontSize: 13 * scale, color: textSecondary }, children: [
              subscribers,
              " subscribers"
            ] })
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            backgroundColor: textPrimary,
            color: bg,
            padding: `${8 * scale}px ${16 * scale}px`,
            borderRadius: 18 * scale,
            fontSize: 14 * scale,
            fontWeight: 600,
            marginLeft: 12 * scale
          }, children: "Subscribe" })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", gap: 8 * scale, overflowX: isPortrait ? "auto" : "visible", width: isPortrait ? "100%" : "auto", paddingBottom: isPortrait ? 4 * scale : 0 }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", backgroundColor: buttonBg, borderRadius: 18 * scale, overflow: "hidden" }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 6 * scale, padding: `${8 * scale}px ${16 * scale}px`, color: textPrimary, fontSize: 14 * scale, fontWeight: 600, borderRight: `1px solid ${darkMode ? "#3f3f3f" : "#d3d3d3"}` }, children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z" }) }),
              likes
            ] }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { display: "flex", alignItems: "center", padding: `${8 * scale}px ${16 * scale}px`, color: textPrimary }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z" }) }) })
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 6 * scale, backgroundColor: buttonBg, padding: `${8 * scale}px ${16 * scale}px`, borderRadius: 18 * scale, color: textPrimary, fontSize: 14 * scale, fontWeight: 600 }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M11 7.141V4l9 7.828-9 7.828v-3.328c-4.995 0-8.243 1.343-11 4.672 1.332-5.334 4.537-8.995 11-9.859z" }) }),
            "Share"
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 6 * scale, backgroundColor: buttonBg, padding: `${8 * scale}px ${16 * scale}px`, borderRadius: 18 * scale, color: textPrimary, fontSize: 14 * scale, fontWeight: 600 }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("svg", { viewBox: "0 0 24 24", width: 20 * scale, height: 20 * scale, fill: "currentColor", children: /* @__PURE__ */ (0,jsx_runtime.jsx)("path", { d: "M17 18V19H6V18H17ZM16.5 11.4L15.8 10.7L12 14.4V4H11V14.4L7.2 10.6L6.5 11.3L11.5 16.3L16.5 11.4Z" }) }),
            "Download"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
        backgroundColor: buttonBg,
        borderRadius: 12 * scale,
        padding: 12 * scale,
        fontSize: 14 * scale,
        color: textPrimary,
        lineHeight: 1.5
      }, children: [
        /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { fontWeight: 600, marginBottom: 4 * scale }, children: [
          views,
          " \u2022 ",
          timeAgo
        ] }),
        "In this video, I break down the exact strategies and AI tools we used to scale Lapaas to $1M ARR in under 12 months.",
        /* @__PURE__ */ (0,jsx_runtime.jsx)("br", {}),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("br", {}),
        "Get the tool here: https://lapaas.com"
      ] })
    ] })
  ] }) });
};
registerTemplate({
  tags: [],
  id: "youtube-player-mockup-01",
  name: "YouTube Player Mockup",
  description: "A pixel-perfect YouTube video player and description layout.",
  category: "platform-mockups",
  durationInFrames: 180,
  fps: 30,
  component: YouTubePlayerMockup,
  schema: youtubePlayerMockupSchema,
  defaultProps: youtubePlayerMockupSchema.parse({})
});

;// ./src/lib/animations.ts
/* unused harmony import specifier */ var interpolate;


function fadeIn(frame, delay = 0, duration = 20) {
  return (0,esm.interpolate)(frame - delay, [0, duration], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
}
function fadeOut(frame, startFrame, duration = 20) {
  return interpolate(frame - startFrame, [0, duration], [1, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
}
function slideIn(frame, direction, delay = 0, distance = 100, duration = 20) {
  const progress = (0,esm.interpolate)(frame - delay, [0, duration], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const remaining = (1 - progress) * distance;
  switch (direction) {
    case "left":
      return `translateX(${-remaining}px)`;
    case "right":
      return `translateX(${remaining}px)`;
    case "up":
      return `translateY(${-remaining}px)`;
    case "down":
      return `translateY(${remaining}px)`;
  }
}
function scaleIn(frame, fps, delay = 0) {
  return (0,esm.spring)({
    frame: frame - delay,
    fps,
    config: { damping: 12, stiffness: 200, mass: 0.5 }
  });
}
function typewriter(frame, text, charsPerFrame = 0.5, delay = 0) {
  const elapsed = Math.max(0, frame - delay);
  const charCount = Math.min(
    text.length,
    Math.floor(elapsed * charsPerFrame)
  );
  return text.slice(0, charCount);
}
function animatedCounter(frame, target, delay = 0, duration = 60) {
  const progress = interpolate(frame - delay, [0, duration], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  return Math.round(progress * target);
}
function pulse(frame, speed = 0.05, amplitude = 0.05) {
  return 1 + Math.sin(frame * speed) * amplitude;
}
function staggerDelay(index, stagger = 5) {
  return index * stagger;
}

;// ./src/components/AnimatedImage.tsx




const AnimatedImage = ({
  src,
  opacity = 0.35,
  blur = 2,
  zoomRange = [1, 1.15],
  panDirection = "right",
  panAmount = 60,
  style = {},
  showBackground,
  transparentBackground
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { durationInFrames } = (0,esm.useVideoConfig)();
  const controls = useResolvedBackgroundControls({
    showBackground,
    transparentBackground
  });
  if (!shouldRenderBackgroundLayer(controls)) {
    return null;
  }
  const scale = (0,esm.interpolate)(frame, [0, durationInFrames], zoomRange, {
    extrapolateRight: "clamp"
  });
  const pan = (0,esm.interpolate)(frame, [0, durationInFrames], [0, panAmount], {
    extrapolateRight: "clamp"
  });
  const panTransform = {
    left: `translateX(${pan}px)`,
    right: `translateX(-${pan}px)`,
    up: `translateY(${pan}px)`,
    down: `translateY(-${pan}px)`
  }[panDirection];
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(
    "div",
    {
      style: {
        position: "absolute",
        top: -panAmount,
        left: -panAmount,
        right: -panAmount,
        bottom: -panAmount,
        opacity,
        overflow: "hidden",
        ...style
      },
      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
        esm.Img,
        {
          src,
          style: {
            width: "100%",
            height: "100%",
            objectFit: "cover",
            transform: `scale(${scale}) ${panTransform}`,
            filter: blur > 0 ? `blur(${blur}px)` : void 0,
            willChange: "transform"
          }
        }
      )
    }
  );
};

;// ./src/lib/colors.ts

const PALETTES = {
  // Professional / Corporate
  corporate: {
    primary: "#1a1a2e",
    secondary: "#16213e",
    accent: "#0f3460",
    highlight: "#e94560",
    text: "#ffffff",
    textSecondary: "#a0a0b0",
    background: "#0a0a1a"
  },
  // Modern Tech
  tech: {
    primary: "#0d1117",
    secondary: "#161b22",
    accent: "#58a6ff",
    highlight: "#f78166",
    text: "#f0f6fc",
    textSecondary: "#8b949e",
    background: "#010409"
  },
  // Bold News
  news: {
    primary: "#b71c1c",
    secondary: "#1a1a1a",
    accent: "#ff5252",
    highlight: "#ffd740",
    text: "#ffffff",
    textSecondary: "#cccccc",
    background: "#121212"
  },
  // Vibrant Business
  business: {
    primary: "#1e3a5f",
    secondary: "#2d5a8a",
    accent: "#4fc3f7",
    highlight: "#ff8a65",
    text: "#ffffff",
    textSecondary: "#b0c4de",
    background: "#0d1b2a"
  },
  // Clean / Minimal
  clean: {
    primary: "#ffffff",
    secondary: "#f5f5f5",
    accent: "#2962ff",
    highlight: "#00c853",
    text: "#212121",
    textSecondary: "#757575",
    background: "#fafafa"
  },
  // Dark Gold (Case Studies)
  darkGold: {
    primary: "#1c1c1c",
    secondary: "#2a2a2a",
    accent: "#d4af37",
    highlight: "#f5d060",
    text: "#ffffff",
    textSecondary: "#b0b0b0",
    background: "#111111"
  },
  // Neon Tech
  neon: {
    primary: "#0a0a0a",
    secondary: "#1a1a2e",
    accent: "#00ff87",
    highlight: "#ff00ff",
    text: "#ffffff",
    textSecondary: "#888888",
    background: "#050505"
  }
};
function getPalette(name) {
  return PALETTES[name];
}
function linearGradient(angle, ...colors) {
  return `linear-gradient(${angle}deg, ${colors.join(", ")})`;
}
function radialGradient(...colors) {
  return `radial-gradient(circle, ${colors.join(", ")})`;
}

;// ./src/templates/business-news/BizNewsBreaking01.tsx














const bizNewsBreakingSchema = lib.z.object({
  breakingLabel: lib.z.string().default("BREAKING NEWS"),
  headline: lib.z.string().default("Major Tech Acquisition: Company X to Buy Startup Y for $3.2B"),
  subheadline: lib.z.string().default("The deal marks the largest acquisition in the sector this year, signaling a shift in market dynamics"),
  source: lib.z.string().default("Business Wire"),
  timestamp: lib.z.string().default("Feb 11, 2026 \u2022 10:30 AM IST"),
  imageUrl: lib.z.string().default("https://images.unsplash.com/photo-1611974789855-9c2a0a7236a3?w=800"),
  category: lib.z.string().default("MERGERS & ACQUISITIONS"),
  primaryColor: lib.z.string().default(COLORS.accent),
  backgroundColor: lib.z.string().default(COLORS.bg),
  accentColor: lib.z.string().default(COLORS.accentLight)
});
const BizNewsBreaking01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const pulseOpacity = 0.5 + Math.sin(frame * 0.15) * 0.5;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              opacity: fadeIn(frame, 0, 20) * 0.25
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedImage, { src: props.imageUrl })
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: linearGradient(180, "rgba(10,10,10,0.3)", "rgba(10,10,10,0.95)")
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              height: isPortrait ? 56 : 60,
              background: COLORS.accent,
              display: "flex",
              alignItems: "center",
              paddingLeft: isPortrait ? 20 : 40,
              gap: 24 * scale,
              transform: slideIn(frame, "down", 0, 20, 10),
              opacity: fadeIn(frame, 0, 10)
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    width: 12 * scale,
                    height: 12 * scale,
                    borderRadius: "50%",
                    background: "#fff",
                    opacity: pulseOpacity,
                    boxShadow: "0 0 8px rgba(255,255,255,0.8)"
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.breakingLabel,
                  fontSize: 48 * scale,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 900,
                  letterSpacing: 4
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              justifyContent: isPortrait ? "center" : "flex-end",
              width: "100%",
              height: "100%",
              padding: isPortrait ? "120px 80px 90px" : "0 80px 80px",
              gap: 32 * scale
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "inline-flex",
                    alignSelf: "flex-start",
                    padding: `${6 * scale}px ${16 * scale}px`,
                    borderRadius: 4 * scale,
                    background: COLORS.accentLight,
                    opacity: fadeIn(frame, 15)
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.category,
                      fontSize: 36 * scale,
                      fontFamily: interFont,
                      color: COLORS.textPrimary,
                      fontWeight: 700,
                      letterSpacing: 2
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 104 : 128,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.1,
                  letterSpacing: -1,
                  maxLines: 3,
                  style: {
                    opacity: fadeIn(frame, 20),
                    transform: slideIn(frame, "up", 20, 30)
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subheadline,
                  fontSize: isPortrait ? 52 : 64,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  lineHeight: 1.5,
                  maxLines: 2,
                  style: { opacity: fadeIn(frame, 35) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: 32 * scale,
                    marginTop: 16 * scale,
                    opacity: fadeIn(frame, 45)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.source,
                        fontSize: 40 * scale,
                        fontFamily: interFont,
                        color: COLORS.accentLight,
                        fontWeight: 600
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          width: 4 * scale,
                          height: 8 * scale,
                          borderRadius: "50%",
                          background: "#ffffff44"
                        }
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.timestamp,
                        fontSize: 40 * scale,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: 400
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], {
                extrapolateRight: "clamp"
              })}% `,
              height: 8 * scale,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "biz-news-breaking-01",
  name: "Breaking Business News",
  category: "business-news",
  description: "Bold breaking news layout with red alert bar, pulsing live dot, and big headline",
  tags: ["breaking", "alert", "headline", "business-news", "urgent"],
  component: BizNewsBreaking01,
  schema: bizNewsBreakingSchema,
  defaultProps: bizNewsBreakingSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/components/AnimatedGradient.tsx




const AnimatedGradient = ({
  baseColor = "#0F0F0F",
  accentColor = "rgba(0,230,118,0.08)",
  secondaryColor = "rgba(0,200,83,0.05)",
  speed = 1,
  style = {},
  showBackground,
  transparentBackground
}) => {
  const frame = (0,esm.useCurrentFrame)();
  const { durationInFrames } = (0,esm.useVideoConfig)();
  const controls = useResolvedBackgroundControls({
    showBackground,
    transparentBackground
  });
  if (!shouldRenderBackgroundLayer(controls)) {
    return null;
  }
  const x1 = (0,esm.interpolate)(
    frame,
    [0, durationInFrames],
    [15, 75],
    { extrapolateRight: "clamp" }
  ) * speed;
  const y1 = (0,esm.interpolate)(
    frame,
    [0, durationInFrames],
    [10, 65],
    { extrapolateRight: "clamp" }
  ) * speed;
  const x2 = (0,esm.interpolate)(
    frame,
    [0, durationInFrames],
    [80, 25],
    { extrapolateRight: "clamp" }
  ) * speed;
  const y2 = (0,esm.interpolate)(
    frame,
    [0, durationInFrames],
    [70, 20],
    { extrapolateRight: "clamp" }
  ) * speed;
  const x3 = (0,esm.interpolate)(
    frame,
    [0, durationInFrames],
    [40, 60],
    { extrapolateRight: "clamp" }
  );
  const y3 = (0,esm.interpolate)(
    frame,
    [0, durationInFrames],
    [55, 35],
    { extrapolateRight: "clamp" }
  );
  const background = [
    `radial-gradient(ellipse 800px 800px at ${x1}% ${y1}%, ${accentColor} 0%, transparent 70%)`,
    `radial-gradient(ellipse 600px 600px at ${x2}% ${y2}%, ${secondaryColor} 0%, transparent 70%)`,
    `radial-gradient(ellipse 500px 500px at ${x3}% ${y3}%, ${secondaryColor} 0%, transparent 60%)`,
    baseColor
  ].join(", ");
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(
    "div",
    {
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background,
        willChange: "background",
        ...style
      }
    }
  );
};

;// ./src/templates/business-news/BizNewsEarnings01.tsx













const bizNewsEarningsSchema = lib.z.object({
  companyName: lib.z.string().default("Tesla Inc."),
  tickerSymbol: lib.z.string().default("TSLA"),
  quarter: lib.z.string().default("Q4 2025"),
  headline: lib.z.string().default("Tesla Beats Q4 Estimates with Record Deliveries"),
  revenueValue: lib.z.string().default("$25.7B"),
  revenueLabel: lib.z.string().default("Revenue"),
  revenueChange: lib.z.string().default("+12.3% YoY"),
  epsValue: lib.z.string().default("$1.24"),
  epsLabel: lib.z.string().default("EPS"),
  epsChange: lib.z.string().default("vs $1.08 est."),
  guidanceText: lib.z.string().default("FY2026 guidance raised to $105-110B revenue"),
  source: lib.z.string().default("Bloomberg"),
  timestamp: lib.z.string().default("After Hours \u2022 Feb 12, 2026"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const BizNewsEarnings01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: GRADIENTS.bgMain
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 80 : 60
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: 32,
                    opacity: fadeIn(frame, 0)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          padding: `${6 * scale}px ${16 * scale}px`,
                          borderRadius: 12,
                          background: COLORS.accent,
                          display: "flex",
                          gap: 16,
                          alignItems: "center"
                        },
                        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: props.tickerSymbol,
                            fontSize: 36 * scale,
                            fontFamily: interFont,
                            color: COLORS.textPrimary,
                            fontWeight: 800,
                            letterSpacing: 1
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: `EARNINGS \u2022 ${props.quarter}`,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: 600,
                        letterSpacing: 2
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.companyName,
                  fontSize: isPortrait ? 48 : 64,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 500,
                  style: { opacity: fadeIn(frame, 5), transform: slideIn(frame, "left", 5, 20) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 92 : 112,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.1,
                  letterSpacing: -1,
                  maxLines: 3,
                  style: {
                    opacity: fadeIn(frame, 10),
                    transform: slideIn(frame, "up", 10, 25)
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: isPortrait ? "column" : "row",
                    gap: isPortrait ? 24 : 48,
                    marginTop: isPortrait ? 0 : "auto"
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          flex: isPortrait ? void 0 : 1,
                          padding: `${24 * scale}px`,
                          borderRadius: 32,
                          background: "rgba(255,255,255,0.03)",
                          border: "2px solid rgba(255,255,255,0.08)",
                          display: "flex",
                          flexDirection: "column",
                          gap: 16,
                          opacity: fadeIn(frame, 30),
                          transform: `scale(${(0,esm.spring)({ frame: frame - 30, fps, config: { damping: 12, stiffness: 150, mass: 0.5 } })})`
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.revenueLabel,
                              fontSize: 32 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 600,
                              textTransform: "uppercase",
                              letterSpacing: 2
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.revenueValue,
                              fontSize: 96 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 800
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.revenueChange,
                              fontSize: 36 * scale,
                              fontFamily: interFont,
                              color: COLORS.accentLight,
                              fontWeight: 600
                            }
                          )
                        ]
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          flex: isPortrait ? void 0 : 1,
                          padding: `${24 * scale}px`,
                          borderRadius: 32,
                          background: "rgba(255,255,255,0.03)",
                          border: "2px solid rgba(255,255,255,0.08)",
                          display: "flex",
                          flexDirection: "column",
                          gap: 16,
                          opacity: fadeIn(frame, 40),
                          transform: `scale(${(0,esm.spring)({ frame: frame - 40, fps, config: { damping: 12, stiffness: 150, mass: 0.5 } })})`
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.epsLabel,
                              fontSize: 32 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 600,
                              textTransform: "uppercase",
                              letterSpacing: 2
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.epsValue,
                              fontSize: 96 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 800
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.epsChange,
                              fontSize: 36 * scale,
                              fontFamily: interFont,
                              color: COLORS.accentLight,
                              fontWeight: 600
                            }
                          )
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    padding: `${14 * scale}px ${24 * scale}px`,
                    borderRadius: 20,
                    background: `${props.accentColor}10`,
                    border: `2px solid ${props.accentColor}25`,
                    opacity: fadeIn(frame, 60),
                    transform: slideIn(frame, "up", 60, 15)
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: `\u{1F4CA} ${props.guidanceText}`,
                      fontSize: 40 * scale,
                      fontFamily: interFont,
                      color: COLORS.textSecondary,
                      fontWeight: 500
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    gap: 24,
                    alignItems: "center",
                    flexWrap: isPortrait ? "wrap" : "nowrap",
                    opacity: fadeIn(frame, 70)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.source,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 600
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 4, height: 8, borderRadius: "50%", background: "#ffffff33" } }),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.timestamp,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: 400
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 80], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "biz-news-earnings-01",
  name: "Earnings Report",
  category: "business-news",
  description: "Quarterly earnings report with revenue/EPS cards, guidance bar, and editorial layout",
  tags: ["earnings", "quarterly", "revenue", "business-news", "finance"],
  component: BizNewsEarnings01,
  schema: bizNewsEarningsSchema,
  defaultProps: bizNewsEarningsSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/business-news/BizNewsIPO01.tsx













const bizNewsIPOSchema = lib.z.object({
  badge: lib.z.string().default("IPO WATCH"),
  headline: lib.z.string().default("Stripe Files for Long-Awaited IPO"),
  subheadline: lib.z.string().default("Payments giant targets $70B+ valuation in Q2 2026 listing"),
  expectedValuation: lib.z.string().default("$70B+"),
  lastPrivateVal: lib.z.string().default("$50B"),
  exchange: lib.z.string().default("NYSE"),
  expectedDate: lib.z.string().default("Q2 2026"),
  revenue: lib.z.string().default("$18.6B"),
  employees: lib.z.string().default("10,000+"),
  source: lib.z.string().default("Wall Street Journal"),
  timestamp: lib.z.string().default("Exclusive \u2022 Feb 12, 2026"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const BizNewsIPO01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const stats = [
    { label: "Target", value: props.expectedValuation },
    { label: "Last Round", value: props.lastPrivateVal },
    { label: "Exchange", value: props.exchange },
    { label: "Timeline", value: props.expectedDate },
    { label: "Revenue", value: props.revenue },
    { label: "Team", value: props.employees }
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "svg",
          {
            viewBox: "0 0 1920 1080",
            style: { position: "absolute", top: 0, left: 0, right: 0, bottom: 0, opacity: 0.03 },
            children: Array.from({ length: 8 }).map((_, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "path",
              {
                d: `M${240 * i},1080 L${240 * i + 120},${600 - i * 50} L${240 * (i + 1)},1080`,
                fill: props.primaryColor,
                opacity: (0,esm.interpolate)(frame, [i * 8, i * 8 + 40], [0, 0.5], {
                  extrapolateLeft: "clamp",
                  extrapolateRight: "clamp"
                })
              },
              i
            ))
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 32 : 48
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { display: "flex", alignItems: "center", gap: 24, opacity: fadeIn(frame, 0) }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    padding: `${5 * scale}px ${14 * scale}px`,
                    borderRadius: 12,
                    background: COLORS.accent
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.badge,
                      fontSize: 32 * scale,
                      fontFamily: interFont,
                      color: COLORS.textPrimary,
                      fontWeight: 800,
                      letterSpacing: 2
                    }
                  )
                }
              ) }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 92 : 112,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.1,
                  letterSpacing: -1,
                  maxLines: 3,
                  style: { opacity: fadeIn(frame, 8), transform: slideIn(frame, "up", 8, 25) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subheadline,
                  fontSize: isPortrait ? 44 : 56,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  lineHeight: 1.5,
                  maxLines: 2,
                  style: { opacity: fadeIn(frame, 18) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "grid",
                    gridTemplateColumns: isPortrait ? "repeat(2, 1fr)" : "repeat(3, 1fr)",
                    gap: isPortrait ? 20 : 32,
                    marginTop: isPortrait ? 0 : "auto",
                    marginBottom: isPortrait ? 0 : 16
                  },
                  children: stats.map((stat, i) => {
                    const delay = 30 + staggerDelay(i, 8);
                    const cardScale = (0,esm.spring)({
                      frame: frame - delay,
                      fps,
                      config: { damping: 12, stiffness: 130, mass: 0.5 }
                    });
                    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "center",
                          padding: `${14 * scale}px`,
                          borderRadius: 24,
                          background: "rgba(255,255,255,0.03)",
                          border: "2px solid rgba(255,255,255,0.06)",
                          transform: `scale(${cardScale})`,
                          opacity: fadeIn(frame, delay),
                          gap: 8
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: stat.label,
                              fontSize: 28 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 500,
                              textTransform: "uppercase",
                              letterSpacing: 2
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: stat.value,
                              fontSize: 52 * scale,
                              fontFamily: interFont,
                              color: COLORS.accentLight,
                              fontWeight: 700
                            }
                          )
                        ]
                      },
                      i
                    );
                  })
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    gap: 24,
                    alignItems: "center",
                    flexWrap: isPortrait ? "wrap" : "nowrap",
                    opacity: fadeIn(frame, 75)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.source,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 600
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 4, height: 8, borderRadius: "50%", background: "#ffffff33" } }),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.timestamp,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: 400
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "biz-news-ipo-01",
  name: "IPO Watch",
  category: "business-news",
  description: "IPO filing announcement with 6-stat grid, upward arrow SVG pattern, and editorial layout",
  tags: ["IPO", "listing", "stock", "business-news", "public"],
  component: BizNewsIPO01,
  schema: bizNewsIPOSchema,
  defaultProps: bizNewsIPOSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/business-news/BizNewsMarketUpdate01.tsx













const bizNewsMarketUpdateSchema = lib.z.object({
  headline: lib.z.string().default("Markets Rally on Strong Jobs Data"),
  subheadline: lib.z.string().default("S&P 500 posts best weekly gain since November as employment numbers beat expectations"),
  ticker1Symbol: lib.z.string().default("S&P 500"),
  ticker1Value: lib.z.string().default("5,234.18"),
  ticker1Change: lib.z.string().default("+1.82%"),
  ticker1Up: lib.z.boolean().default(true),
  ticker2Symbol: lib.z.string().default("NASDAQ"),
  ticker2Value: lib.z.string().default("16,742.39"),
  ticker2Change: lib.z.string().default("+2.14%"),
  ticker2Up: lib.z.boolean().default(true),
  ticker3Symbol: lib.z.string().default("DOW"),
  ticker3Value: lib.z.string().default("39,131.53"),
  ticker3Change: lib.z.string().default("+0.97%"),
  ticker3Up: lib.z.boolean().default(true),
  source: lib.z.string().default("MarketWatch"),
  timestamp: lib.z.string().default("Market Close \u2022 Feb 12, 2026"),
  primaryColor: lib.z.string().default(COLORS.accent),
  upColor: lib.z.string().default("#4CAF50"),
  downColor: lib.z.string().default("#F44336"),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const BizNewsMarketUpdate01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const tickers = [
    { symbol: props.ticker1Symbol, value: props.ticker1Value, change: props.ticker1Change, up: props.ticker1Up },
    { symbol: props.ticker2Symbol, value: props.ticker2Value, change: props.ticker2Change, up: props.ticker2Up },
    { symbol: props.ticker3Symbol, value: props.ticker3Value, change: props.ticker3Change, up: props.ticker3Up }
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundImage: `
            linear-gradient(${props.primaryColor}06 1px, transparent 1px),
            linear-gradient(90deg, ${props.primaryColor}06 1px, transparent 1px)
          `,
              backgroundSize: "40px 40px",
              opacity: fadeIn(frame, 0, 20)
            }
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "svg",
          {
            viewBox: "0 0 1920 200",
            style: {
              position: "absolute",
              bottom: isPortrait ? "30%" : "25%",
              left: 0,
              right: 0,
              opacity: 0.08
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "path",
              {
                d: `M0,150 Q200,${100 + Math.sin(frame * 0.03) * 40} 400,120 T800,${80 + Math.sin(frame * 0.05) * 30} T1200,${60 + Math.cos(frame * 0.04) * 20} T1600,40 T1920,${30 + Math.sin(frame * 0.06) * 15}`,
                fill: "none",
                stroke: props.upColor,
                strokeWidth: "3",
                strokeDasharray: `${(0,esm.interpolate)(frame, [0, 120], [0, 2e3], { extrapolateRight: "clamp" })}`
              }
            )
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 80px",
              gap: isPortrait ? 48 : 72
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: 24,
                    opacity: fadeIn(frame, 0)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          width: 8,
                          height: 8,
                          borderRadius: "50%",
                          background: props.upColor,
                          boxShadow: `0 0 8px ${props.upColor}`
                        }
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: "MARKET UPDATE",
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 700,
                        letterSpacing: 3
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 92 : 112,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.1,
                  letterSpacing: -1,
                  maxLines: 2,
                  style: {
                    opacity: fadeIn(frame, 8),
                    transform: slideIn(frame, "up", 8, 25)
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subheadline,
                  fontSize: isPortrait ? 44 : 56,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  lineHeight: 1.5,
                  maxLines: 2,
                  style: { opacity: fadeIn(frame, 20) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "grid",
                    gridTemplateColumns: isPortrait ? "1fr" : "repeat(3, 1fr)",
                    gap: isPortrait ? 24 : 48,
                    flex: isPortrait ? void 0 : 0,
                    marginTop: isPortrait ? 0 : "auto",
                    marginBottom: isPortrait ? 0 : 20
                  },
                  children: tickers.map((ticker, i) => {
                    const delay = 30 + staggerDelay(i, 10);
                    const cardScale = (0,esm.spring)({
                      frame: frame - delay,
                      fps,
                      config: { damping: 12, stiffness: 150, mass: 0.5 }
                    });
                    const changeColor = ticker.up ? props.upColor : props.downColor;
                    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          flexDirection: "column",
                          padding: `${20 * scale}px ${24 * scale}px`,
                          borderRadius: 32,
                          background: "rgba(255,255,255,0.03)",
                          border: `2px solid rgba(255,255,255,0.06)`,
                          transform: `scale(${cardScale})`,
                          opacity: fadeIn(frame, delay),
                          gap: 16
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: ticker.symbol,
                              fontSize: 32 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 600,
                              letterSpacing: 1
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: ticker.value,
                              fontSize: 72 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 700
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 12 }, children: [
                            /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 36 * scale, color: changeColor }, children: ticker.up ? "\u25B2" : "\u25BC" }),
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              EditableText,
                              {
                                text: ticker.change,
                                fontSize: 40 * scale,
                                fontFamily: interFont,
                                color: changeColor,
                                fontWeight: 600
                              }
                            )
                          ] })
                        ]
                      },
                      i
                    );
                  })
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    gap: 24,
                    alignItems: "center",
                    flexWrap: isPortrait ? "wrap" : "nowrap",
                    opacity: fadeIn(frame, 60)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.source,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 600
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 4, height: 8, borderRadius: "50%", background: "#ffffff33" } }),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.timestamp,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: 400
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "biz-news-market-update-01",
  name: "Market Update",
  category: "business-news",
  description: "Stock market update with 3 ticker cards, animated chart line, and headline",
  tags: ["market", "stocks", "ticker", "business-news", "finance"],
  component: BizNewsMarketUpdate01,
  schema: bizNewsMarketUpdateSchema,
  defaultProps: bizNewsMarketUpdateSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/business-news/BizNewsMerger01.tsx













const bizNewsMergerSchema = lib.z.object({
  badge: lib.z.string().default("M&A ALERT"),
  headline: lib.z.string().default("Adobe to Acquire Figma in Landmark $20B Deal"),
  subheadline: lib.z.string().default("Largest design-tool acquisition creates end-to-end creative platform"),
  acquirerName: lib.z.string().default("Adobe"),
  acquirerTicker: lib.z.string().default("ADBE"),
  targetName: lib.z.string().default("Figma"),
  dealValue: lib.z.string().default("$20B"),
  dealType: lib.z.string().default("Cash & Stock"),
  expectedClose: lib.z.string().default("Q2 2026"),
  premium: lib.z.string().default("+42% premium"),
  source: lib.z.string().default("Reuters"),
  timestamp: lib.z.string().default("Breaking \u2022 Feb 12, 2026"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const BizNewsMerger01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const mergeAnimation = (0,esm.spring)({
    frame: frame - 40,
    fps,
    config: { damping: 10, stiffness: 80, mass: 0.8 }
  });
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: "20%",
              left: "50%",
              transform: "translateX(-50%)",
              width: 500 * scale,
              height: 500 * scale,
              borderRadius: "50%",
              background: `${props.primaryColor}0a`,
              filter: "blur(120px)"
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 40 : 56
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: 24 * scale,
                    opacity: fadeIn(frame, 0)
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        padding: `${6 * scale}px ${16 * scale}px`,
                        borderRadius: 12 * scale,
                        background: COLORS.accent
                      },
                      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                        EditableText,
                        {
                          text: props.badge,
                          fontSize: 32 * scale,
                          fontFamily: interFont,
                          color: COLORS.textPrimary,
                          fontWeight: 800,
                          letterSpacing: 2
                        }
                      )
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 92 : 112,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.1,
                  letterSpacing: -1,
                  maxLines: 3,
                  style: {
                    opacity: fadeIn(frame, 8),
                    transform: slideIn(frame, "up", 8, 25)
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subheadline,
                  fontSize: isPortrait ? 44 : 56,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  lineHeight: 1.5,
                  maxLines: 2,
                  style: { opacity: fadeIn(frame, 18) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: isPortrait ? "column" : "row",
                    alignItems: isPortrait ? "stretch" : "center",
                    justifyContent: "center",
                    gap: isPortrait ? 32 : 80,
                    marginTop: isPortrait ? 0 : "auto",
                    marginBottom: isPortrait ? 0 : 16
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          flex: isPortrait ? void 0 : 1,
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "center",
                          padding: `${24 * scale}px`,
                          borderRadius: 32 * scale,
                          background: "rgba(255,255,255,0.04)",
                          border: "2px solid rgba(255,255,255,0.08)",
                          opacity: fadeIn(frame, 25),
                          transform: `translateX(${(0,esm.interpolate)(mergeAnimation, [0, 1], [isPortrait ? 0 : -30, 0])}px)`,
                          gap: 16 * scale
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.acquirerTicker,
                              fontSize: 32 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 700,
                              letterSpacing: 2
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.acquirerName,
                              fontSize: 64 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 800
                            }
                          )
                        ]
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          width: 56 * scale,
                          height: 56 * scale,
                          borderRadius: "50%",
                          background: GRADIENTS.bgMain,
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          fontSize: 48 * scale,
                          color: "#fff",
                          fontWeight: 800,
                          transform: `scale(${mergeAnimation}) rotate(${mergeAnimation * 180}deg)`,
                          boxShadow: `0 0 40px ${props.primaryColor}44`
                        },
                        children: "+"
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          flex: isPortrait ? void 0 : 1,
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "center",
                          padding: `${24 * scale}px`,
                          borderRadius: 32 * scale,
                          background: "rgba(255,255,255,0.04)",
                          border: "2px solid rgba(255,255,255,0.08)",
                          opacity: fadeIn(frame, 30),
                          transform: `translateX(${(0,esm.interpolate)(mergeAnimation, [0, 1], [isPortrait ? 0 : 30, 0])}px)`,
                          gap: 16 * scale
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: "PRIVATE",
                              fontSize: 32 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 700,
                              letterSpacing: 2
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.targetName,
                              fontSize: 64 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 800
                            }
                          )
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "grid",
                    gridTemplateColumns: isPortrait ? "1fr 1fr" : "repeat(4, 1fr)",
                    gap: isPortrait ? 16 : 32,
                    opacity: fadeIn(frame, 60),
                    transform: slideIn(frame, "up", 60, 15)
                  },
                  children: [
                    { label: "Deal Value", value: props.dealValue },
                    { label: "Structure", value: props.dealType },
                    { label: "Premium", value: props.premium },
                    { label: "Close", value: props.expectedClose }
                  ].map((item, i) => /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                    "div",
                    {
                      style: {
                        textAlign: "center",
                        padding: `${12 * scale}px`,
                        borderRadius: 20 * scale,
                        background: "rgba(255,255,255,0.03)",
                        border: "2px solid rgba(255,255,255,0.06)"
                      },
                      children: [
                        /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: item.label,
                            fontSize: 28 * scale,
                            fontFamily: interFont,
                            color: COLORS.textSecondary,
                            fontWeight: 500,
                            textTransform: "uppercase",
                            letterSpacing: 2
                          }
                        ),
                        /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: item.value,
                            fontSize: 40 * scale,
                            fontFamily: interFont,
                            color: COLORS.accentLight,
                            fontWeight: 700
                          }
                        )
                      ]
                    },
                    i
                  ))
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    gap: 24 * scale,
                    alignItems: "center",
                    flexWrap: isPortrait ? "wrap" : "nowrap",
                    opacity: fadeIn(frame, 75)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.source,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 600
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 4 * scale, height: 8 * scale, borderRadius: "50%", background: "#ffffff33" } }),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.timestamp,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: 400
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6 * scale,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "biz-news-merger-01",
  name: "M&A / Merger Alert",
  category: "business-news",
  description: "Merger & acquisition alert with animated company merge visual and deal details grid",
  tags: ["merger", "acquisition", "deal", "business-news", "M&A"],
  component: BizNewsMerger01,
  schema: bizNewsMergerSchema,
  defaultProps: bizNewsMergerSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/business-news/BizNewsPolicy01.tsx













const bizNewsPolicySchema = lib.z.object({
  badge: lib.z.string().default("POLICY UPDATE"),
  headline: lib.z.string().default("EU Approves Comprehensive AI Regulation Framework"),
  subheadline: lib.z.string().default("New rules set global precedent for artificial intelligence governance"),
  detail1Icon: lib.z.string().default("\u{1F4CB}"),
  detail1Label: lib.z.string().default("Scope"),
  detail1Value: lib.z.string().default("All AI systems in EU market"),
  detail2Icon: lib.z.string().default("\u{1F4C5}"),
  detail2Label: lib.z.string().default("Effective"),
  detail2Value: lib.z.string().default("January 2027"),
  detail3Icon: lib.z.string().default("\u{1F4B0}"),
  detail3Label: lib.z.string().default("Max Fine"),
  detail3Value: lib.z.string().default("\u20AC35M or 7% revenue"),
  detail4Icon: lib.z.string().default("\u{1F30D}"),
  detail4Label: lib.z.string().default("Impact"),
  detail4Value: lib.z.string().default("Global tech companies"),
  source: lib.z.string().default("European Commission"),
  timestamp: lib.z.string().default("Feb 12, 2026 \u2022 Official"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const BizNewsPolicy01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const details = [
    { icon: props.detail1Icon, label: props.detail1Label, value: props.detail1Value },
    { icon: props.detail2Icon, label: props.detail2Label, value: props.detail2Value },
    { icon: props.detail3Icon, label: props.detail3Label, value: props.detail3Value },
    { icon: props.detail4Icon, label: props.detail4Label, value: props.detail4Value }
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundImage: `
            linear-gradient(rgba(255,255,255,0.015) 1px, transparent 1px),
            linear-gradient(90deg, rgba(255,255,255,0.015) 1px, transparent 1px)
          `,
              backgroundSize: "60px 60px",
              opacity: fadeIn(frame, 0, 20)
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 28 : 40
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { opacity: fadeIn(frame, 0) }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "inline-flex",
                    padding: `${5 * scale}px ${14 * scale}px`,
                    borderRadius: 12,
                    background: `${props.primaryColor}20`,
                    border: `2px solid ${props.primaryColor}40`
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.badge,
                      fontSize: 32 * scale,
                      fontFamily: interFont,
                      color: COLORS.accent,
                      fontWeight: 800,
                      letterSpacing: 2
                    }
                  )
                }
              ) }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 88 : 112,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.1,
                  letterSpacing: -1,
                  maxLines: 3,
                  style: { opacity: fadeIn(frame, 8), transform: slideIn(frame, "up", 8, 25) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subheadline,
                  fontSize: isPortrait ? 44 : 56,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  lineHeight: 1.5,
                  maxLines: 2,
                  style: { opacity: fadeIn(frame, 20) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "grid",
                    gridTemplateColumns: isPortrait ? "1fr" : "1fr 1fr",
                    gap: isPortrait ? 20 : 32,
                    marginTop: isPortrait ? 0 : "auto",
                    marginBottom: isPortrait ? 0 : 16
                  },
                  children: details.map((detail, i) => {
                    const delay = 30 + staggerDelay(i, 10);
                    const cardSpring = (0,esm.spring)({
                      frame: frame - delay,
                      fps,
                      config: { damping: 14, stiffness: 120, mass: 0.5 }
                    });
                    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          alignItems: "center",
                          gap: 28,
                          padding: `${14 * scale}px ${18 * scale}px`,
                          borderRadius: 24,
                          background: "rgba(255,255,255,0.03)",
                          border: "2px solid rgba(255,255,255,0.06)",
                          transform: `translateX(${(0,esm.interpolate)(cardSpring, [0, 1], [30, 0])}px)`,
                          opacity: fadeIn(frame, delay)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 64 * scale }, children: detail.icon }),
                          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column", gap: 4 }, children: [
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              EditableText,
                              {
                                text: detail.label,
                                fontSize: 28 * scale,
                                fontFamily: interFont,
                                color: COLORS.textSecondary,
                                fontWeight: 500,
                                textTransform: "uppercase",
                                letterSpacing: 2
                              }
                            ),
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              EditableText,
                              {
                                text: detail.value,
                                fontSize: 40 * scale,
                                fontFamily: interFont,
                                color: COLORS.textSecondary,
                                fontWeight: 600
                              }
                            )
                          ] })
                        ]
                      },
                      i
                    );
                  })
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    gap: 24,
                    alignItems: "center",
                    flexWrap: isPortrait ? "wrap" : "nowrap",
                    opacity: fadeIn(frame, 75)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.source,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 600
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 4, height: 8, borderRadius: "50%", background: "#ffffff33" } }),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.timestamp,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: 400
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "biz-news-policy-01",
  name: "Policy & Regulation Update",
  category: "business-news",
  description: "Policy update with 4 detail cards with emoji icons, grid background, and editorial layout",
  tags: ["policy", "regulation", "government", "compliance", "law"],
  component: BizNewsPolicy01,
  schema: bizNewsPolicySchema,
  defaultProps: bizNewsPolicySchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/case-study/CaseStudyBeforeAfter01.tsx













const caseStudyBeforeAfterSchema = lib.z.object({
  companyName: lib.z.string().default("BrightPath"),
  headline: lib.z.string().default("Digital Transformation Results"),
  beforeTitle: lib.z.string().default("BEFORE"),
  beforeItems: lib.z.string().default("Manual processes\nSlow customer response\nHigh operational costs\nLimited reach"),
  afterTitle: lib.z.string().default("AFTER"),
  afterItems: lib.z.string().default("Fully automated workflows\n<2hr response time\n60% cost reduction\nGlobal market presence"),
  imageUrl: lib.z.string().default("https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=800"),
  primaryColor: lib.z.string().default(COLORS.accent),
  successColor: lib.z.string().default("#00E676"),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const CaseStudyBeforeAfter01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const beforeItems = props.beforeItems.split("\n").filter(Boolean);
  const afterItems = props.afterItems.split("\n").filter(Boolean);
  const dividerProgress = (0,esm.interpolate)(frame, [60, 90], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "absolute",
              top: isPortrait ? 40 : 50,
              left: 0,
              right: 0,
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              gap: 24 * scale,
              opacity: fadeIn(frame, 0),
              transform: slideIn(frame, "down", 0, 20),
              zIndex: 2
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.companyName,
                  fontSize: 40 * scale,
                  fontFamily: interFont,
                  color: COLORS.accent,
                  fontWeight: 600,
                  textTransform: "uppercase",
                  letterSpacing: 4
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 84 : 112,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  textAlign: "center",
                  letterSpacing: -1,
                  style: { padding: "0 40px" }
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "absolute",
              top: isPortrait ? 260 : 170,
              bottom: isPortrait ? 70 : 50,
              left: isPortrait ? 80 : 80,
              right: isPortrait ? 80 : 80,
              display: "flex",
              flexDirection: isPortrait ? "column" : "row",
              justifyContent: isPortrait ? "center" : "flex-start",
              gap: isPortrait ? 60 : 80
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    display: "flex",
                    flexDirection: "column",
                    padding: 64 * scale,
                    borderRadius: 40 * scale,
                    background: `${props.primaryColor}0a`,
                    border: `2px solid ${props.primaryColor}33`,
                    opacity: fadeIn(frame, 15),
                    transform: slideIn(frame, "left", 15, 40)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.beforeTitle,
                        fontSize: isPortrait ? 64 : 52 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 800,
                        letterSpacing: 4,
                        style: { marginBottom: 40 * scale }
                      }
                    ),
                    beforeItems.map((item, i) => /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          alignItems: "center",
                          gap: 24 * scale,
                          marginBottom: 28 * scale,
                          opacity: fadeIn(frame, 30 + i * 6)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            "div",
                            {
                              style: {
                                width: 8 * scale,
                                height: 8 * scale,
                                borderRadius: "50%",
                                background: COLORS.accent,
                                flexShrink: 0
                              }
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: item,
                              fontSize: isPortrait ? 48 : 40 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 400
                            }
                          )
                        ]
                      },
                      i
                    ))
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    justifyContent: isPortrait ? "flex-end" : "center",
                    opacity: dividerProgress,
                    transform: `scale(${dividerProgress})`
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        width: isPortrait ? 50 : 60,
                        height: isPortrait ? 50 : 60,
                        borderRadius: "50%",
                        background: GRADIENTS.bgMain,
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        fontSize: 56 * scale,
                        boxShadow: `0 0 30px ${props.successColor}44`
                      },
                      children: isPortrait ? "\u2193" : "\u2192"
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    display: "flex",
                    flexDirection: "column",
                    padding: 64 * scale,
                    borderRadius: 40 * scale,
                    background: `${props.successColor}0a`,
                    border: `2px solid ${props.successColor}33`,
                    opacity: fadeIn(frame, 60),
                    transform: slideIn(frame, "right", 60, 40)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.afterTitle,
                        fontSize: isPortrait ? 64 : 52 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 800,
                        letterSpacing: 4,
                        style: { marginBottom: 40 * scale }
                      }
                    ),
                    afterItems.map((item, i) => /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          alignItems: "center",
                          gap: 24 * scale,
                          marginBottom: 28 * scale,
                          opacity: fadeIn(frame, 75 + i * 6)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            "div",
                            {
                              style: {
                                width: 20 * scale,
                                height: 20 * scale,
                                borderRadius: "50%",
                                background: `${props.successColor}33`,
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                fontSize: 24 * scale,
                                color: props.successColor,
                                flexShrink: 0
                              },
                              children: "\u2713"
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: item,
                              fontSize: isPortrait ? 48 : 40 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 400
                            }
                          )
                        ]
                      },
                      i
                    ))
                  ]
                }
              )
            ]
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "case-study-before-after-01",
  name: "Case Study Before & After",
  category: "case-study",
  description: "Side-by-side comparison with animated reveal showing transformation results",
  tags: ["before-after", "comparison", "transformation", "case-study"],
  component: CaseStudyBeforeAfter01,
  schema: caseStudyBeforeAfterSchema,
  defaultProps: caseStudyBeforeAfterSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/case-study/CaseStudyCompanyProfile01.tsx














const caseStudyCompanyProfileSchema = lib.z.object({
  companyName: lib.z.string().default("NovaTech Solutions"),
  tagline: lib.z.string().default("Enterprise Cloud Infrastructure"),
  founded: lib.z.string().default("2019"),
  headquarters: lib.z.string().default("San Francisco, CA"),
  employees: lib.z.string().default("2,400+"),
  revenue: lib.z.string().default("$180M ARR"),
  logoUrl: lib.z.string().default(""),
  imageUrl: lib.z.string().default("https://images.unsplash.com/photo-1497366216548-37526070297c?w=800"),
  description: lib.z.string().default("NovaTech Solutions provides next-generation cloud infrastructure for enterprises scaling globally. Their platform powers 500+ Fortune 1000 companies."),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const CaseStudyCompanyProfile01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const infoItems = [
    { label: "Founded", value: props.founded },
    { label: "HQ", value: props.headquarters },
    { label: "Team", value: props.employees },
    { label: "Revenue", value: props.revenue }
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              opacity: fadeIn(frame, 0, 30) * 0.15
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedImage, { src: props.imageUrl })
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: linearGradient(180, `${props.backgroundColor}88`, `${props.backgroundColor}ee`, props.backgroundColor)
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              alignItems: isPortrait ? "center" : "flex-start",
              justifyContent: "center",
              width: "100%",
              height: "100%",
              padding: isPortrait ? "120px 60px" : "80px 100px",
              gap: isPortrait ? 48 : 64
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    padding: `${6 * scale}px ${18 * scale}px`,
                    borderRadius: 12 * scale,
                    background: `${props.primaryColor}20`,
                    border: `2px solid ${props.primaryColor}40`,
                    opacity: fadeIn(frame, 5),
                    transform: `scale(${scaleIn(frame, fps, 5)})`
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: "COMPANY PROFILE",
                      fontSize: 32 * scale,
                      fontFamily: interFont,
                      color: COLORS.accent,
                      fontWeight: 700,
                      letterSpacing: 3
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.companyName,
                  fontSize: isPortrait ? 104 : 144,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 900,
                  lineHeight: 1.05,
                  letterSpacing: -2,
                  textAlign: isPortrait ? "center" : "left",
                  style: {
                    opacity: fadeIn(frame, 10),
                    transform: slideIn(frame, "up", 10, 25)
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.tagline,
                  fontSize: isPortrait ? 48 : 64,
                  fontFamily: interFont,
                  color: COLORS.accent,
                  fontWeight: 500,
                  textAlign: isPortrait ? "center" : "left",
                  style: { opacity: fadeIn(frame, 20) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.description,
                  fontSize: isPortrait ? 40 : 48,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  lineHeight: 1.6,
                  maxLines: 3,
                  textAlign: isPortrait ? "center" : "left",
                  style: {
                    opacity: fadeIn(frame, 30),
                    maxWidth: isPortrait ? "100%" : 700
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "grid",
                    gridTemplateColumns: isPortrait ? "1fr 1fr" : "repeat(4, 1fr)",
                    gap: isPortrait ? 24 : 40,
                    marginTop: 16 * scale,
                    width: "100%",
                    maxWidth: isPortrait ? "100%" : 900
                  },
                  children: infoItems.map((item, i) => /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                    "div",
                    {
                      style: {
                        display: "flex",
                        flexDirection: "column",
                        alignItems: isPortrait ? "center" : "flex-start",
                        gap: 8 * scale,
                        padding: `${16 * scale}px`,
                        borderRadius: 24 * scale,
                        background: "rgba(255,255,255,0.03)",
                        border: "2px solid rgba(255,255,255,0.06)",
                        opacity: fadeIn(frame, 45 + i * 8),
                        transform: slideIn(frame, "up", 45 + i * 8, 20)
                      },
                      children: [
                        /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: item.label,
                            fontSize: 28 * scale,
                            fontFamily: interFont,
                            color: COLORS.textSecondary,
                            fontWeight: 500,
                            textTransform: "uppercase",
                            letterSpacing: 2
                          }
                        ),
                        /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: item.value,
                            fontSize: 48 * scale,
                            fontFamily: interFont,
                            color: COLORS.textSecondary,
                            fontWeight: 700
                          }
                        )
                      ]
                    },
                    i
                  ))
                }
              )
            ]
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6 * scale,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "case-study-company-profile-01",
  name: "Case Study Company Profile",
  category: "case-study",
  description: "Company overview card with name, tagline, description, and key stats grid",
  tags: ["profile", "company", "overview", "case-study", "intro"],
  component: CaseStudyCompanyProfile01,
  schema: caseStudyCompanyProfileSchema,
  defaultProps: caseStudyCompanyProfileSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/case-study/CaseStudyHero01.tsx













const caseStudyHeroSchema = lib.z.object({
  companyName: lib.z.string().default("Acme Corp"),
  headline: lib.z.string().default("How Acme Corp Increased Revenue by 340%"),
  subheadline: lib.z.string().default("A deep dive into their digital transformation strategy"),
  industry: lib.z.string().default("Technology"),
  metric: lib.z.string().default("340%"),
  metricLabel: lib.z.string().default("Revenue Growth"),
  imageUrl: lib.z.string().default("https://images.unsplash.com/photo-1486406146926-c627a92ad1ab?w=800"),
  logoUrl: lib.z.string().default(""),
  primaryColor: lib.z.string().default(COLORS.accent),
  backgroundColor: lib.z.string().default(COLORS.bg),
  accentColor: lib.z.string().default(COLORS.accentLight)
});
const CaseStudyHero01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const metricValueSize = pSize(isPortrait ? 168 : 176, isPortrait);
  const metricLabelSize = pSize(FONT.bodySmall, isPortrait);
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              opacity: fadeIn(frame, 0, 30) * 0.3
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedImage, { src: props.imageUrl })
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: "linear-gradient(180deg, rgba(0,0,0,0.78), rgba(0,0,0,0.9), var(--template-bg, #0F0F0F))"
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: isPortrait ? "column" : "row",
              alignItems: isPortrait ? "stretch" : "center",
              justifyContent: isPortrait ? "flex-end" : "center",
              width: "100%",
              height: "100%",
              padding: pPad(isPortrait),
              gap: isPortrait ? SPACING.xl : SPACING.xxl
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    display: "flex",
                    flexDirection: "column",
                    gap: isPortrait ? SPACING.lg : SPACING.md,
                    opacity: fadeIn(frame, 5),
                    transform: slideIn(frame, "left", 5, 60)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          display: "inline-flex",
                          alignSelf: "flex-start",
                          padding: `${SPACING.xs}px ${SPACING.md}px`,
                          borderRadius: RADIUS.pill,
                          background: COLORS.accentMuted,
                          border: `2px solid ${COLORS.accentBorder}`,
                          opacity: fadeIn(frame, 15)
                        },
                        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: `CASE STUDY \u2022 ${props.industry.toUpperCase()} `,
                            fontSize: FONT.label,
                            fontFamily: interFont,
                            color: COLORS.accent,
                            fontWeight: FONT.semibold,
                            letterSpacing: FONT.wide
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.companyName,
                        fontSize: FONT.h4,
                        fontFamily: interFont,
                        color: COLORS.textMuted,
                        fontWeight: FONT.medium,
                        textTransform: "uppercase",
                        letterSpacing: FONT.wide,
                        style: { opacity: fadeIn(frame, 20) }
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.headline,
                        fontSize: pSize(FONT.hero, isPortrait),
                        fontFamily: interFont,
                        color: COLORS.textPrimary,
                        fontWeight: FONT.black,
                        lineHeight: FONT.tight,
                        letterSpacing: FONT.tighter,
                        maxLines: 3,
                        style: {
                          opacity: fadeIn(frame, 25),
                          transform: slideIn(frame, "up", 25, 30)
                        }
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.subheadline,
                        fontSize: pSize(FONT.body, isPortrait),
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: FONT.regular,
                        lineHeight: FONT.relaxed,
                        maxLines: 2,
                        style: { opacity: fadeIn(frame, 35) }
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    justifyContent: "center",
                    width: isPortrait ? "100%" : 650,
                    height: isPortrait ? "auto" : 650,
                    padding: isPortrait ? SPACING.xxl : 0,
                    borderRadius: RADIUS.xl,
                    background: COLORS.surface,
                    backdropFilter: "blur(20px)",
                    border: `2px solid ${COLORS.borderLight}`,
                    boxShadow: `0 0 120px ${COLORS.glow}`,
                    transform: `scale(${scaleIn(frame, fps, 40)})`,
                    gap: 24
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.metric,
                        fontSize: metricValueSize,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: FONT.black,
                        letterSpacing: FONT.tighter
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.metricLabel,
                        fontSize: metricLabelSize,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: FONT.medium,
                        textTransform: "uppercase",
                        letterSpacing: FONT.wide
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], {
                extrapolateRight: "clamp"
              })}% `,
              height: 6,
              background: GRADIENTS.accentLine
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "case-study-hero-01",
  name: "Case Study Hero",
  category: "case-study",
  description: "Bold hero intro with company name, headline, and a prominent metric card",
  tags: ["hero", "intro", "metric", "case-study", "business"],
  component: CaseStudyHero01,
  schema: caseStudyHeroSchema,
  defaultProps: caseStudyHeroSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/case-study/CaseStudyProblemSolution01.tsx














const caseStudyProblemSolutionSchema = lib.z.object({
  companyName: lib.z.string().default("DataSync Inc."),
  problemTitle: lib.z.string().default("THE CHALLENGE"),
  problemText: lib.z.string().default("Legacy systems caused 40% data loss during migration, costing $2M annually in manual reconciliation and delayed reporting."),
  solutionTitle: lib.z.string().default("THE SOLUTION"),
  solutionText: lib.z.string().default("Implemented an AI-powered data pipeline with real-time validation, automated error correction, and self-healing architecture."),
  resultText: lib.z.string().default("99.97% data accuracy \u2022 $1.8M saved annually"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const CaseStudyProblemSolution01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const arrowProgress = (0,esm.spring)({
    frame: frame - 80,
    fps,
    config: { damping: 12, stiffness: 100, mass: 0.8 }
  });
  const companyLabelSize = isPortrait ? 34 : 38;
  const panelTitleSize = isPortrait ? 52 : 60;
  const panelBodySize = isPortrait ? 30 : 34;
  const resultTextSize = isPortrait ? 52 : 64;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                top: isPortrait ? "15%" : "30%",
                left: "-10%",
                width: 500,
                height: 500,
                borderRadius: "50%",
                background: `${props.primaryColor}10`,
                filter: "blur(120px)"
              }
            }
          ),
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                bottom: isPortrait ? "15%" : "20%",
                right: "-10%",
                width: 500,
                height: 500,
                borderRadius: "50%",
                background: `${props.accentColor}10`,
                filter: "blur(120px)"
              }
            }
          )
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "120px 60px" : "60px 100px",
              gap: isPortrait ? 40 : 60
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { opacity: fadeIn(frame, 0), transform: slideIn(frame, "down", 0, 20) }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.companyName,
                  fontSize: companyLabelSize * scale,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 600,
                  textAlign: "left",
                  textTransform: "uppercase",
                  letterSpacing: 4,
                  style: { textAlign: "left" }
                }
              ) }),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    display: "flex",
                    flexDirection: isPortrait ? "column" : "row",
                    gap: isPortrait ? 32 : 80,
                    alignItems: "stretch"
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          flex: isPortrait ? void 0 : 1,
                          display: "flex",
                          flexDirection: "column",
                          padding: isPortrait ? "24px" : "40px",
                          borderRadius: 40,
                          background: `${props.primaryColor}08`,
                          border: `2px solid ${props.primaryColor}25`,
                          opacity: fadeIn(frame, 10),
                          transform: slideIn(frame, "left", 10, 40),
                          justifyContent: isPortrait ? "flex-end" : "center",
                          gap: 32
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            "div",
                            {
                              style: {
                                width: 48 * scale,
                                height: 48 * scale,
                                borderRadius: 24,
                                background: `${props.primaryColor}20`,
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                fontSize: 48 * scale
                              },
                              children: "\u26A0"
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.problemTitle,
                              fontSize: panelTitleSize * scale,
                              fontFamily: interFont,
                              color: COLORS.accent,
                              fontWeight: 800,
                              letterSpacing: 4
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.problemText,
                              fontSize: panelBodySize * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 400,
                              lineHeight: 1.6,
                              maxLines: 4
                            }
                          )
                        ]
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          opacity: arrowProgress,
                          transform: `scale(${arrowProgress})`
                        },
                        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          "div",
                          {
                            style: {
                              width: isPortrait ? 44 : 56,
                              height: isPortrait ? 44 : 56,
                              borderRadius: "50%",
                              background: GRADIENTS.bgMain,
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                              fontSize: 38 * scale,
                              color: "#fff",
                              boxShadow: `0 0 30px ${props.accentColor}44`
                            },
                            children: isPortrait ? "\u2193" : "\u2192"
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          flex: isPortrait ? void 0 : 1,
                          display: "flex",
                          flexDirection: "column",
                          padding: isPortrait ? "24px" : "40px",
                          borderRadius: 40,
                          background: `${props.accentColor}08`,
                          border: `2px solid ${props.accentColor}25`,
                          opacity: fadeIn(frame, 50),
                          transform: slideIn(frame, "right", 50, 40),
                          justifyContent: "center",
                          gap: 32
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            "div",
                            {
                              style: {
                                width: 48 * scale,
                                height: 48 * scale,
                                borderRadius: 24,
                                background: `${props.accentColor}20`,
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                fontSize: 48 * scale
                              },
                              children: "\u2726"
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.solutionTitle,
                              fontSize: panelTitleSize * scale,
                              fontFamily: interFont,
                              color: COLORS.accentLight,
                              fontWeight: 800,
                              letterSpacing: 4
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.solutionText,
                              fontSize: panelBodySize * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 400,
                              lineHeight: 1.6,
                              maxLines: 4
                            }
                          )
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    padding: `${16 * scale}px ${32 * scale}px`,
                    borderRadius: 24,
                    background: linearGradient(90, `${props.primaryColor}15`, `${props.accentColor}15`),
                    border: `2px solid ${props.accentColor}33`,
                    textAlign: "center",
                    opacity: fadeIn(frame, 90),
                    transform: slideIn(frame, "up", 90, 20)
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.resultText,
                      fontSize: resultTextSize * scale,
                      fontFamily: interFont,
                      color: COLORS.textSecondary,
                      fontWeight: 700,
                      textAlign: "center",
                      letterSpacing: 1
                    }
                  )
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 90], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "case-study-problem-solution-01",
  name: "Case Study Problem \u2192 Solution",
  category: "case-study",
  description: "Two-panel layout showing challenge vs solution with animated connector arrow",
  tags: ["problem", "solution", "challenge", "case-study"],
  component: CaseStudyProblemSolution01,
  schema: caseStudyProblemSolutionSchema,
  defaultProps: caseStudyProblemSolutionSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/case-study/CaseStudyProcess01.tsx















const caseStudyProcessSchema = lib.z.object({
  companyName: lib.z.string().default("CloudOps"),
  headline: lib.z.string().default("Our Implementation Process"),
  step1Number: lib.z.string().default("01"),
  step1Title: lib.z.string().default("Discovery & Audit"),
  step1Desc: lib.z.string().default("Deep-dive into existing infrastructure, identify bottlenecks, set KPIs"),
  step2Number: lib.z.string().default("02"),
  step2Title: lib.z.string().default("Architecture Design"),
  step2Desc: lib.z.string().default("Design scalable cloud-native architecture with failover redundancy"),
  step3Number: lib.z.string().default("03"),
  step3Title: lib.z.string().default("Phased Migration"),
  step3Desc: lib.z.string().default("Zero-downtime migration with rollback testing at each milestone"),
  step4Number: lib.z.string().default("04"),
  step4Title: lib.z.string().default("Optimize & Scale"),
  step4Desc: lib.z.string().default("Continuous monitoring, auto-scaling rules, and cost optimization"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const CaseStudyProcess01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const steps = [
    { num: props.step1Number, title: props.step1Title, desc: props.step1Desc },
    { num: props.step2Number, title: props.step2Title, desc: props.step2Desc },
    { num: props.step3Number, title: props.step3Title, desc: props.step3Desc },
    { num: props.step4Number, title: props.step4Title, desc: props.step4Desc }
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: "40%",
              left: "-10%",
              width: 500 * scale,
              height: 500 * scale,
              borderRadius: "50%",
              background: `${props.primaryColor}08`,
              filter: "blur(120px)"
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "150px 80px" : "60px 100px",
              gap: isPortrait ? 40 : 64
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { opacity: fadeIn(frame, 0), transform: slideIn(frame, "down", 0, 20) }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.companyName,
                  fontSize: isPortrait ? 40 : 36 * scale,
                  fontFamily: interFont,
                  color: COLORS.accent,
                  fontWeight: 600,
                  textTransform: "uppercase",
                  letterSpacing: 4
                }
              ) }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 92 : 112,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.1,
                  letterSpacing: -1,
                  style: {
                    opacity: fadeIn(frame, 8),
                    transform: slideIn(frame, "up", 8, 20)
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center",
                    gap: isPortrait ? 32 : 40
                  },
                  children: steps.map((step, i) => {
                    const delay = 20 + staggerDelay(i, 12);
                    const stepSpring = (0,esm.spring)({
                      frame: frame - delay,
                      fps,
                      config: { damping: 14, stiffness: 100, mass: 0.6 }
                    });
                    const lineProgress = (0,esm.spring)({
                      frame: frame - delay - 5,
                      fps,
                      config: { damping: 20, stiffness: 80, mass: 0.5 }
                    });
                    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(react.Fragment, { children: [
                      /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                        "div",
                        {
                          style: {
                            display: "flex",
                            alignItems: "flex-start",
                            gap: isPortrait ? 32 : 48,
                            opacity: fadeIn(frame, delay),
                            transform: `translateX(${(0,esm.interpolate)(stepSpring, [0, 1], [40, 0])}px)`
                          },
                          children: [
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              "div",
                              {
                                style: {
                                  width: 72 * scale,
                                  height: 72 * scale,
                                  borderRadius: 28 * scale,
                                  background: linearGradient(135, `${props.primaryColor}20`, `${props.accentColor}10`),
                                  border: `2px solid ${props.primaryColor}40`,
                                  display: "flex",
                                  alignItems: "center",
                                  justifyContent: "center",
                                  flexShrink: 0,
                                  transform: `scale(${stepSpring})`
                                },
                                children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                                  EditableText,
                                  {
                                    text: step.num,
                                    fontSize: 34 * scale,
                                    fontFamily: interFont,
                                    color: COLORS.accent,
                                    fontWeight: 900
                                  }
                                )
                              }
                            ),
                            /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column", gap: 8 * scale, paddingTop: 4 * scale }, children: [
                              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                                EditableText,
                                {
                                  text: step.title,
                                  fontSize: isPortrait ? 50 : 44 * scale,
                                  fontFamily: interFont,
                                  color: COLORS.textSecondary,
                                  fontWeight: 700
                                }
                              ),
                              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                                EditableText,
                                {
                                  text: step.desc,
                                  fontSize: isPortrait ? 40 : 36 * scale,
                                  fontFamily: interFont,
                                  color: COLORS.textSecondary,
                                  fontWeight: 400,
                                  lineHeight: 1.4,
                                  maxLines: 2
                                }
                              )
                            ] })
                          ]
                        }
                      ),
                      i < steps.length - 1 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
                        "div",
                        {
                          style: {
                            width: 2 * scale,
                            height: isPortrait ? 12 : 20,
                            marginLeft: 36 * scale,
                            background: `${props.primaryColor}30`,
                            borderRadius: 1 * scale,
                            transform: `scaleY(${lineProgress})`,
                            transformOrigin: "top"
                          }
                        }
                      )
                    ] }, i);
                  })
                }
              )
            ]
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 90], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6 * scale,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "case-study-process-01",
  name: "Case Study Process Steps",
  category: "case-study",
  description: "Numbered process flow with 4 steps, connector lines, and staggered spring entry",
  tags: ["process", "steps", "methodology", "case-study", "workflow"],
  component: CaseStudyProcess01,
  schema: caseStudyProcessSchema,
  defaultProps: caseStudyProcessSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/case-study/CaseStudyQuote01.tsx













const caseStudyQuoteSchema = lib.z.object({
  quote: lib.z.string().default(
    '"Working with this team transformed our entire business model. The results exceeded every projection we had."'
  ),
  authorName: lib.z.string().default("Sarah Chen"),
  authorTitle: lib.z.string().default("CEO, NexGen Technologies"),
  authorImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1573496359142-b8d87734a5a2?w=400"),
  companyLogoUrl: lib.z.string().default(""),
  metric: lib.z.string().default("5x ROI"),
  metricLabel: lib.z.string().default("Return on Investment"),
  primaryColor: lib.z.string().default(COLORS.accent),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const CaseStudyQuote01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const decorativeQuoteSize = isPortrait ? 156 : 176;
  const metricValueSize = 88 * scale;
  const quoteBodySize = isPortrait ? 64 : 76;
  const authorNameSize = isPortrait ? 52 : 50 * scale;
  const authorTitleSize = isPortrait ? 38 : 36 * scale;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: isPortrait ? 60 : 40,
              left: isPortrait ? 30 : 80,
              fontSize: decorativeQuoteSize,
              fontFamily: "Georgia, serif",
              color: `${props.primaryColor}15`,
              lineHeight: 1,
              opacity: fadeIn(frame, 0, 40)
            },
            children: '"'
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              left: 0,
              top: 0,
              bottom: 0,
              width: 6,
              background: GRADIENTS.bgMain,
              opacity: fadeIn(frame, 10)
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: isPortrait ? "column" : "row",
              alignItems: isPortrait ? "stretch" : "center",
              justifyContent: "center",
              width: "100%",
              height: "100%",
              padding: isPortrait ? "140px 80px" : "80px 120px",
              gap: isPortrait ? 72 : 120
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    gap: 48,
                    opacity: fadeIn(frame, 10),
                    transform: `scale(${scaleIn(frame, fps, 10)})`
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          width: isPortrait ? 140 : 180,
                          height: isPortrait ? 140 : 180,
                          borderRadius: "50%",
                          overflow: "hidden",
                          border: `3px solid ${props.primaryColor}`,
                          boxShadow: `0 0 40px ${props.primaryColor}33`
                        },
                        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          esm.Img,
                          {
                            src: props.authorImageUrl,
                            style: { width: "100%", height: "100%", objectFit: "cover" }
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "center",
                          padding: `${16 * scale}px ${28 * scale}px`,
                          borderRadius: 32,
                          background: `${props.primaryColor}15`,
                          border: `2px solid ${props.primaryColor}33`,
                          opacity: fadeIn(frame, 40)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.metric,
                              fontSize: metricValueSize,
                              fontFamily: interFont,
                              color: COLORS.accent,
                              fontWeight: 900
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.metricLabel,
                              fontSize: 32 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 500,
                              textTransform: "uppercase",
                              letterSpacing: 2
                            }
                          )
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    display: "flex",
                    flexDirection: "column",
                    gap: 48
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.quote,
                        fontSize: quoteBodySize,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: 400,
                        lineHeight: 1.5,
                        letterSpacing: 0,
                        style: {
                          fontStyle: "italic",
                          opacity: fadeIn(frame, 20),
                          transform: slideIn(frame, "right", 20, 40)
                        }
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          flexDirection: "column",
                          gap: 8,
                          opacity: fadeIn(frame, 50)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.authorName,
                              fontSize: authorNameSize,
                              fontFamily: interFont,
                              color: COLORS.accent,
                              fontWeight: 700
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.authorTitle,
                              fontSize: authorTitleSize,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 400
                            }
                          )
                        ]
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 90], [0, 100], {
                extrapolateRight: "clamp"
              })}% `,
              height: 6,
              background: COLORS.accent
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "case-study-quote-01",
  name: "Case Study Client Quote",
  category: "case-study",
  description: "Elegant testimonial with author photo, italic quote, and ROI metric badge",
  tags: ["quote", "testimonial", "client", "case-study", "social-proof"],
  component: CaseStudyQuote01,
  schema: caseStudyQuoteSchema,
  defaultProps: caseStudyQuoteSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/case-study/CaseStudyROI01.tsx













const caseStudyROISchema = lib.z.object({
  companyName: lib.z.string().default("LogiFlow"),
  headline: lib.z.string().default("Return on Investment"),
  investmentLabel: lib.z.string().default("Total Investment"),
  investmentValue: lib.z.string().default("$340K"),
  returnsLabel: lib.z.string().default("Annual Returns"),
  returnsValue: lib.z.string().default("$2.1M"),
  roiLabel: lib.z.string().default("ROI"),
  roiValue: lib.z.string().default("517%"),
  paybackLabel: lib.z.string().default("Payback Period"),
  paybackValue: lib.z.string().default("2.3 months"),
  savingsLabel: lib.z.string().default("Cost Savings"),
  savingsValue: lib.z.string().default("$1.76M/yr"),
  quote: lib.z.string().default(`"Best investment we've made in 10 years" \u2014 CTO, LogiFlow`),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const CaseStudyROI01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const roiValueSize = isPortrait ? 148 : 172;
  const headlineSize = isPortrait ? 78 : 102;
  const statValueSize = isPortrait ? 58 : 52 * scale;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: "30%",
              left: "50%",
              transform: "translateX(-50%)",
              width: 500,
              height: 500,
              borderRadius: "50%",
              background: `${props.primaryColor}08`,
              filter: "blur(120px)"
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 48 : 48
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { opacity: fadeIn(frame, 0), transform: slideIn(frame, "down", 0, 20) }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.companyName,
                  fontSize: isPortrait ? 36 : 30 * scale,
                  fontFamily: interFont,
                  color: COLORS.accent,
                  fontWeight: 600,
                  textTransform: "uppercase",
                  letterSpacing: 4
                }
              ) }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: headlineSize,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.1,
                  letterSpacing: -1,
                  style: { opacity: fadeIn(frame, 8), transform: slideIn(frame, "up", 8, 20) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    marginTop: isPortrait ? 8 : 16
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                    "div",
                    {
                      style: {
                        padding: `${28 * scale}px ${48 * scale}px`,
                        borderRadius: 48,
                        background: `${props.primaryColor}10`,
                        border: `2px solid ${props.primaryColor}30`,
                        display: "flex",
                        flexDirection: "column",
                        alignItems: "center",
                        gap: 12,
                        transform: `scale(${(0,esm.spring)({ frame: frame - 20, fps, config: { damping: 8, stiffness: 100, mass: 0.6 } })})`,
                        opacity: fadeIn(frame, 20),
                        boxShadow: `0 0 60px ${props.primaryColor}15`
                      },
                      children: [
                        /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: props.roiValue,
                            fontSize: roiValueSize,
                            fontFamily: interFont,
                            color: COLORS.accent,
                            fontWeight: 900,
                            letterSpacing: -2
                          }
                        ),
                        /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: props.roiLabel,
                            fontSize: 36 * scale,
                            fontFamily: interFont,
                            color: COLORS.textSecondary,
                            fontWeight: 600,
                            textTransform: "uppercase",
                            letterSpacing: 4
                          }
                        )
                      ]
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "grid",
                    gridTemplateColumns: isPortrait ? "1fr 1fr" : "repeat(4, 1fr)",
                    gap: isPortrait ? 20 : 32,
                    marginTop: isPortrait ? 0 : "auto"
                  },
                  children: [
                    { label: props.investmentLabel, value: props.investmentValue },
                    { label: props.returnsLabel, value: props.returnsValue },
                    { label: props.paybackLabel, value: props.paybackValue },
                    { label: props.savingsLabel, value: props.savingsValue }
                  ].map((stat, i) => {
                    const delay = 40 + staggerDelay(i, 8);
                    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          textAlign: "center",
                          padding: `${14 * scale}px`,
                          borderRadius: 24,
                          background: "rgba(255,255,255,0.03)",
                          border: "2px solid rgba(255,255,255,0.06)",
                          opacity: fadeIn(frame, delay),
                          transform: slideIn(frame, "up", delay, 15)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: stat.label,
                              fontSize: 28 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 500,
                              textTransform: "uppercase",
                              letterSpacing: 2
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: stat.value,
                              fontSize: statValueSize,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 700
                            }
                          )
                        ]
                      },
                      i
                    );
                  })
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.quote,
                  fontSize: isPortrait ? 44 : 40 * scale,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  textAlign: isPortrait ? "center" : "left",
                  style: { opacity: fadeIn(frame, 80), fontStyle: "italic" }
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "case-study-roi-01",
  name: "Case Study ROI",
  category: "case-study",
  description: "ROI showcase with giant percentage center card, 4 supporting stats, and testimonial quote",
  tags: ["ROI", "return", "investment", "case-study", "metrics"],
  component: CaseStudyROI01,
  schema: caseStudyROISchema,
  defaultProps: caseStudyROISchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/case-study/CaseStudyResults01.tsx













const caseStudyResultsSchema = lib.z.object({
  companyName: lib.z.string().default("FinanceHub"),
  headline: lib.z.string().default("Results That Speak for Themselves"),
  row1Icon: lib.z.string().default("\u{1F4C8}"),
  row1Label: lib.z.string().default("Revenue Growth"),
  row1Value: lib.z.string().default("+187%"),
  row2Icon: lib.z.string().default("\u{1F465}"),
  row2Label: lib.z.string().default("Customer Acquisition"),
  row2Value: lib.z.string().default("+12,400 users"),
  row3Icon: lib.z.string().default("\u26A1"),
  row3Label: lib.z.string().default("Processing Speed"),
  row3Value: lib.z.string().default("3x faster"),
  row4Icon: lib.z.string().default("\u{1F4B0}"),
  row4Label: lib.z.string().default("Cost Savings"),
  row4Value: lib.z.string().default("$4.2M annually"),
  row5Icon: lib.z.string().default("\u{1F3AF}"),
  row5Label: lib.z.string().default("Accuracy Rate"),
  row5Value: lib.z.string().default("99.8%"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const CaseStudyResults01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const rows = [
    { icon: props.row1Icon, label: props.row1Label, value: props.row1Value },
    { icon: props.row2Icon, label: props.row2Label, value: props.row2Value },
    { icon: props.row3Icon, label: props.row3Label, value: props.row3Value },
    { icon: props.row4Icon, label: props.row4Label, value: props.row4Value },
    { icon: props.row5Icon, label: props.row5Label, value: props.row5Value }
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: "-15%",
              right: "-15%",
              width: 700,
              height: 700,
              borderRadius: "50%",
              background: `${props.primaryColor}08`,
              filter: "blur(100px)"
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "120px 60px" : "60px 100px",
              gap: isPortrait ? 48 : 72
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    gap: 20,
                    opacity: fadeIn(frame, 0),
                    transform: slideIn(frame, "down", 0, 25)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.companyName,
                        fontSize: 36 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 600,
                        textTransform: "uppercase",
                        letterSpacing: 4
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.headline,
                        fontSize: isPortrait ? 84 : 112,
                        fontFamily: interFont,
                        color: COLORS.textPrimary,
                        fontWeight: 800,
                        lineHeight: 1.1,
                        letterSpacing: -1
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center",
                    gap: isPortrait ? 28 : 32
                  },
                  children: rows.map((row, i) => {
                    const delay = 20 + staggerDelay(i, 10);
                    const barWidth = (0,esm.spring)({
                      frame: frame - delay,
                      fps,
                      config: { damping: 15, stiffness: 80, mass: 0.6 }
                    });
                    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          alignItems: "center",
                          gap: isPortrait ? 24 : 40,
                          padding: `${14 * scale}px ${20 * scale}px`,
                          borderRadius: 28,
                          background: "rgba(255,255,255,0.03)",
                          border: "2px solid rgba(255,255,255,0.06)",
                          opacity: fadeIn(frame, delay),
                          transform: slideIn(frame, "left", delay, 30)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            "div",
                            {
                              style: {
                                fontSize: 56 * scale,
                                width: 44 * scale,
                                height: 44 * scale,
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                borderRadius: 20,
                                background: `${props.primaryColor}15`,
                                flexShrink: 0
                              },
                              children: row.icon
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { flex: 1 }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: row.label,
                              fontSize: isPortrait ? 46 : 40 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 500
                            }
                          ) }),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            "div",
                            {
                              style: {
                                flex: isPortrait ? 0 : 1,
                                height: 6,
                                borderRadius: 3,
                                background: "rgba(255,255,255,0.06)",
                                overflow: "hidden",
                                display: isPortrait ? "none" : "block"
                              },
                              children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                                "div",
                                {
                                  style: {
                                    width: `${barWidth * 100}%`,
                                    height: "100%",
                                    borderRadius: 3,
                                    background: GRADIENTS.bgMain
                                  }
                                }
                              )
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: row.value,
                              fontSize: isPortrait ? 50 : 44 * scale,
                              fontFamily: interFont,
                              color: COLORS.accentLight,
                              fontWeight: 700,
                              style: { flexShrink: 0 }
                            }
                          )
                        ]
                      },
                      i
                    );
                  })
                }
              )
            ]
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 90], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "case-study-results-01",
  name: "Case Study Results List",
  category: "case-study",
  description: "Stacked results rows with emoji icons, progress bars, and animated values",
  tags: ["results", "metrics", "list", "case-study", "outcomes"],
  component: CaseStudyResults01,
  schema: caseStudyResultsSchema,
  defaultProps: caseStudyResultsSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/case-study/CaseStudyStats01.tsx













const caseStudyStatsSchema = lib.z.object({
  companyName: lib.z.string().default("TechFlow Inc."),
  headline: lib.z.string().default("The Numbers That Tell The Story"),
  stat1Value: lib.z.string().default("2.4M"),
  stat1Label: lib.z.string().default("Users Acquired"),
  stat2Value: lib.z.string().default("98%"),
  stat2Label: lib.z.string().default("Customer Retention"),
  stat3Value: lib.z.string().default("$12M"),
  stat3Label: lib.z.string().default("Revenue Generated"),
  stat4Value: lib.z.string().default("45"),
  stat4Label: lib.z.string().default("Countries Reached"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const StatCard = ({ value, label, delay, color, frame, fps, scale }) => {
  const statValueSize = 96;
  const statLabelSize = 30;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        padding: 96 * scale,
        borderRadius: RADIUS.lg,
        background: COLORS.surface,
        border: `2px solid ${COLORS.border}`,
        backdropFilter: "blur(10px)",
        opacity: fadeIn(frame, delay),
        transform: `scale(${(0,esm.spring)({
          frame: frame - delay,
          fps,
          config: { damping: 12, stiffness: 150, mass: 0.5 }
        })})`,
        minWidth: 468 * scale
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          EditableText,
          {
            text: value,
            fontSize: statValueSize * scale,
            fontFamily: interFont,
            color,
            fontWeight: FONT.black,
            letterSpacing: FONT.tight_ls
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          EditableText,
          {
            text: label,
            fontSize: statLabelSize * scale,
            fontFamily: interFont,
            color: COLORS.textSecondary,
            fontWeight: FONT.medium,
            textTransform: "uppercase",
            letterSpacing: FONT.wide,
            textAlign: "center",
            style: { marginTop: 16 * scale }
          }
        )
      ]
    }
  );
};
const CaseStudyStats01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const stats = [
    { value: props.stat1Value, label: props.stat1Label },
    { value: props.stat2Value, label: props.stat2Label },
    { value: props.stat3Value, label: props.stat3Label },
    { value: props.stat4Value, label: props.stat4Label }
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                top: "-20%",
                right: "-10%",
                width: 1200 * scale,
                height: 1200 * scale,
                borderRadius: "50%",
                background: `${COLORS.accent}15`,
                filter: "blur(120px)"
              }
            }
          ),
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                bottom: "-20%",
                left: "-10%",
                width: 1e3 * scale,
                height: 1e3 * scale,
                borderRadius: "50%",
                background: `${COLORS.accent}10`,
                filter: "blur(120px)"
              }
            }
          )
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: isPortrait ? "flex-end" : "center",
              width: "100%",
              height: "100%",
              padding: pPad(isPortrait),
              gap: pGap(SPACING.xl, isPortrait)
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    gap: SPACING.sm,
                    opacity: fadeIn(frame, 0),
                    transform: slideIn(frame, "down", 0, 30)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.companyName,
                        fontSize: FONT.label,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: FONT.semibold,
                        textTransform: "uppercase",
                        letterSpacing: FONT.wide
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.headline,
                        fontSize: pSize(FONT.h1, isPortrait),
                        fontFamily: interFont,
                        color: COLORS.textPrimary,
                        fontWeight: FONT.black,
                        textAlign: "center",
                        lineHeight: 1.1,
                        letterSpacing: -1,
                        maxLines: 2
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "grid",
                    gridTemplateColumns: isPortrait ? "1fr 1fr" : "repeat(4, 1fr)",
                    gap: pGap(SPACING.md, isPortrait),
                    width: "100%",
                    maxWidth: isPortrait ? "100%" : 2400
                  },
                  children: stats.map((stat, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    StatCard,
                    {
                      value: stat.value,
                      label: stat.label,
                      delay: 20 + staggerDelay(i, 8),
                      color: i % 2 === 0 ? props.primaryColor : props.accentColor,
                      frame,
                      fps,
                      scale
                    },
                    i
                  ))
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 90], [0, 100], {
                extrapolateRight: "clamp"
              })}%`,
              height: 6 * scale,
              background: GRADIENTS.accentLine
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "case-study-stats-01",
  name: "Case Study Stats Dashboard",
  category: "case-study",
  description: "4-card stats dashboard with staggered spring animations and glassmorphism",
  tags: ["stats", "metrics", "dashboard", "case-study", "numbers"],
  component: CaseStudyStats01,
  schema: caseStudyStatsSchema,
  defaultProps: caseStudyStatsSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/case-study/CaseStudyTestimonialGrid01.tsx













const caseStudyTestimonialGridSchema = lib.z.object({
  headline: lib.z.string().default("What Our Clients Say"),
  quote1: lib.z.string().default('"Reduced our deployment time by 80%. Absolutely game-changing."'),
  quote1Author: lib.z.string().default("Sarah Chen, VP Engineering"),
  quote2: lib.z.string().default('"The ROI was visible within the first month. Incredible product."'),
  quote2Author: lib.z.string().default("James Wright, COO"),
  quote3: lib.z.string().default('"Best decision our team made all year. Support is outstanding."'),
  quote3Author: lib.z.string().default("Maria Lopez, CTO"),
  rating: lib.z.string().default("4.9 / 5.0"),
  reviewCount: lib.z.string().default("2,400+ reviews"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const CaseStudyTestimonialGrid01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  void shouldRenderBackgroundLayer;
  const quotes = [
    { text: props.quote1, author: props.quote1Author },
    { text: props.quote2, author: props.quote2Author },
    { text: props.quote3, author: props.quote3Author }
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "120px 60px" : "60px 100px",
              gap: isPortrait ? 32 : 48
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { opacity: fadeIn(frame, 0), transform: slideIn(frame, "down", 0, 20) }, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.headline,
                    fontSize: isPortrait ? 84 : 112,
                    fontFamily: interFont,
                    color: COLORS.textPrimary,
                    fontWeight: 800,
                    lineHeight: 1.1,
                    letterSpacing: -1
                  }
                ),
                /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 24 * scale, marginTop: 20 * scale }, children: [
                  /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: `\u2B50 ${props.rating}`,
                      fontSize: 48 * scale,
                      fontFamily: interFont,
                      color: COLORS.accent,
                      fontWeight: 700
                    }
                  ),
                  /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.reviewCount,
                      fontSize: 36 * scale,
                      fontFamily: interFont,
                      color: COLORS.textSecondary,
                      fontWeight: 400
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center",
                    gap: isPortrait ? 32 : 36
                  },
                  children: quotes.map((q, i) => {
                    const delay = 15 + staggerDelay(i, 12);
                    const cardSpring = (0,esm.spring)({
                      frame: frame - delay,
                      fps,
                      config: { damping: 14, stiffness: 100, mass: 0.6 }
                    });
                    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          padding: `${20 * scale}px ${24 * scale}px`,
                          borderRadius: 32 * scale,
                          background: "rgba(255,255,255,0.03)",
                          borderLeft: `3px solid ${props.primaryColor}`,
                          opacity: fadeIn(frame, delay),
                          transform: `translateX(${(0,esm.interpolate)(cardSpring, [0, 1], [40, 0])}px)`
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: q.text,
                              fontSize: isPortrait ? 44 : 48,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 400,
                              lineHeight: 1.5,
                              maxLines: 2
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: `\u2014 ${q.author}`,
                              fontSize: isPortrait ? 36 : 32 * scale,
                              fontFamily: interFont,
                              color: COLORS.accent,
                              fontWeight: 600,
                              style: { marginTop: 20 * scale }
                            }
                          )
                        ]
                      },
                      i
                    );
                  })
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6 * scale,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "case-study-testimonial-grid-01",
  name: "Testimonial Grid",
  category: "case-study",
  description: "3-quote testimonial grid with star rating, left accent border, and staggered slide-in",
  tags: ["testimonial", "quote", "client", "review", "social-proof"],
  component: CaseStudyTestimonialGrid01,
  schema: caseStudyTestimonialGridSchema,
  defaultProps: caseStudyTestimonialGridSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/case-study/CaseStudyTimeline01.tsx













const caseStudyTimelineSchema = lib.z.object({
  companyName: lib.z.string().default("CloudScale"),
  headline: lib.z.string().default("The Journey to 10x Growth"),
  step1Title: lib.z.string().default("Q1 2024"),
  step1Desc: lib.z.string().default("Identified key market opportunities and gaps"),
  step2Title: lib.z.string().default("Q2 2024"),
  step2Desc: lib.z.string().default("Launched new digital platform & onboarded 500 users"),
  step3Title: lib.z.string().default("Q3 2024"),
  step3Desc: lib.z.string().default("Scaled operations to 5 new markets"),
  step4Title: lib.z.string().default("Q4 2024"),
  step4Desc: lib.z.string().default("Achieved 10x revenue growth target"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const CaseStudyTimeline01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const steps = [
    { title: props.step1Title, desc: props.step1Desc },
    { title: props.step2Title, desc: props.step2Desc },
    { title: props.step3Title, desc: props.step3Desc },
    { title: props.step4Title, desc: props.step4Desc }
  ];
  const companyLabelSize = 30;
  const headlineSize = isPortrait ? 96 : 116;
  const timelineStepTitleSize = 56;
  const timelineStepBodySize = 30;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%)",
              width: 1600,
              height: 1600,
              borderRadius: "50%",
              background: `${COLORS.accent}08`,
              filter: "blur(160px)"
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: pPad(isPortrait),
              gap: pGap(SPACING.lg, isPortrait)
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    gap: SPACING.sm,
                    opacity: fadeIn(frame, 0),
                    transform: slideIn(frame, "down", 0, 30)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.companyName,
                        fontSize: companyLabelSize,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: FONT.semibold,
                        textTransform: "uppercase",
                        letterSpacing: FONT.wide
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.headline,
                        fontSize: headlineSize * scale,
                        fontFamily: interFont,
                        color: COLORS.textPrimary,
                        fontWeight: FONT.black,
                        lineHeight: 1.1,
                        letterSpacing: -1
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    display: "flex",
                    flexDirection: isPortrait ? "column" : "row",
                    alignItems: isPortrait ? "flex-start" : "center",
                    gap: isPortrait ? 80 : 0,
                    position: "relative"
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          position: "absolute",
                          ...isPortrait ? {
                            left: 20,
                            top: 0,
                            bottom: 0,
                            width: 2
                          } : {
                            top: "50%",
                            left: 0,
                            right: 0,
                            height: 2,
                            transform: "translateY(-50%)"
                          },
                          background: `${COLORS.accent}33`
                        },
                        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          "div",
                          {
                            style: {
                              ...isPortrait ? {
                                width: "100%",
                                height: `${(0,esm.interpolate)(frame, [15, 120], [0, 100], {
                                  extrapolateLeft: "clamp",
                                  extrapolateRight: "clamp"
                                })}% `
                              } : {
                                height: "100%",
                                width: `${(0,esm.interpolate)(frame, [15, 120], [0, 100], {
                                  extrapolateLeft: "clamp",
                                  extrapolateRight: "clamp"
                                })}% `
                              },
                              background: GRADIENTS.accentLine,
                              borderRadius: 2
                            }
                          }
                        )
                      }
                    ),
                    steps.map((step, i) => {
                      const delay = 20 + staggerDelay(i, 18);
                      const dotScale = (0,esm.spring)({
                        frame: frame - delay,
                        fps,
                        config: { damping: 10, stiffness: 200, mass: 0.3 }
                      });
                      return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                        "div",
                        {
                          style: {
                            flex: isPortrait ? void 0 : 1,
                            display: "flex",
                            flexDirection: isPortrait ? "row" : "column",
                            alignItems: isPortrait ? "flex-start" : "center",
                            gap: pGap(SPACING.sm, isPortrait),
                            opacity: fadeIn(frame, delay),
                            paddingLeft: isPortrait ? 0 : 0,
                            paddingTop: isPortrait ? 12 : 0
                          },
                          children: [
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              "div",
                              {
                                style: {
                                  width: 80 * scale,
                                  height: 80 * scale,
                                  borderRadius: "50%",
                                  background: COLORS.accent,
                                  display: "flex",
                                  alignItems: "center",
                                  justifyContent: isPortrait ? "flex-end" : "center",
                                  transform: `scale(${dotScale})`,
                                  boxShadow: `0 0 30px ${COLORS.glow}`,
                                  flexShrink: 0,
                                  zIndex: 2
                                },
                                children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                                  "span",
                                  {
                                    style: {
                                      color: "#fff",
                                      fontSize: FONT.label * scale,
                                      fontWeight: FONT.bold,
                                      fontFamily: interFont
                                    },
                                    children: i + 1
                                  }
                                )
                              }
                            ),
                            /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column", gap: SPACING.xs }, children: [
                              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                                EditableText,
                                {
                                  text: step.title,
                                  fontSize: timelineStepTitleSize * scale,
                                  fontFamily: interFont,
                                  color: COLORS.accent,
                                  fontWeight: FONT.bold
                                }
                              ),
                              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                                EditableText,
                                {
                                  text: step.desc,
                                  fontSize: timelineStepBodySize * scale,
                                  fontFamily: interFont,
                                  color: COLORS.textSecondary,
                                  fontWeight: FONT.regular,
                                  lineHeight: FONT.normal,
                                  maxLines: 2,
                                  style: { maxWidth: isPortrait ? "100%" : 400 }
                                }
                              )
                            ] })
                          ]
                        },
                        i
                      );
                    })
                  ]
                }
              )
            ]
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "case-study-timeline-01",
  name: "Case Study Timeline",
  category: "case-study",
  description: "Animated 4-step timeline with connecting line, numbered dots, and staggered reveals",
  tags: ["timeline", "process", "steps", "case-study", "journey"],
  component: CaseStudyTimeline01,
  schema: caseStudyTimelineSchema,
  defaultProps: caseStudyTimelineSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/data-visualization/DataVizBarChart01.tsx














const dataVizBarChartSchema = lib.z.object({
  title: lib.z.string().default("Monthly Revenue Growth"),
  subtitle: lib.z.string().default("Q4 2025 Performance by Region"),
  bar1Label: lib.z.string().default("North America"),
  bar1Value: lib.z.number().default(85),
  bar1Display: lib.z.string().default("$4.2M"),
  bar2Label: lib.z.string().default("Europe"),
  bar2Value: lib.z.number().default(62),
  bar2Display: lib.z.string().default("$3.1M"),
  bar3Label: lib.z.string().default("Asia Pacific"),
  bar3Value: lib.z.number().default(74),
  bar3Display: lib.z.string().default("$3.7M"),
  bar4Label: lib.z.string().default("Latin America"),
  bar4Value: lib.z.number().default(45),
  bar4Display: lib.z.string().default("$2.2M"),
  bar5Label: lib.z.string().default("Middle East"),
  bar5Value: lib.z.number().default(38),
  bar5Display: lib.z.string().default("$1.9M"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const DataVizBarChart01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const bars = [
    { label: props.bar1Label, value: props.bar1Value, display: props.bar1Display },
    { label: props.bar2Label, value: props.bar2Value, display: props.bar2Display },
    { label: props.bar3Label, value: props.bar3Value, display: props.bar3Display },
    { label: props.bar4Label, value: props.bar4Value, display: props.bar4Display },
    { label: props.bar5Label, value: props.bar5Value, display: props.bar5Display }
  ];
  const maxValue = Math.max(...bars.map((b) => b.value));
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundImage: `linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px)`,
              backgroundSize: "100% 60px",
              opacity: fadeIn(frame, 0, 20)
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 88 : 64
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { opacity: fadeIn(frame, 0), transform: slideIn(frame, "down", 0, 20) }, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.title,
                    fontSize: isPortrait ? 92 : 112,
                    fontFamily: interFont,
                    color: COLORS.textPrimary,
                    fontWeight: 800,
                    lineHeight: 1.1,
                    letterSpacing: -1
                  }
                ),
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.subtitle,
                    fontSize: isPortrait ? 44 : 52,
                    fontFamily: interFont,
                    color: COLORS.textSecondary,
                    fontWeight: 400,
                    style: { marginTop: 16 * scale }
                  }
                )
              ] }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center",
                    gap: isPortrait ? 60 : 44
                  },
                  children: bars.map((bar, i) => {
                    const delay = 15 + staggerDelay(i, 8);
                    const barGrow = (0,esm.spring)({
                      frame: frame - delay,
                      fps,
                      config: { damping: 15, stiffness: 80, mass: 0.8 }
                    });
                    const widthPct = bar.value / maxValue * 100;
                    const hue = (0,esm.interpolate)(i, [0, bars.length - 1], [0, 1]);
                    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          alignItems: "center",
                          gap: isPortrait ? 16 : 32,
                          opacity: fadeIn(frame, delay)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: isPortrait ? 360 : 300, flexShrink: 0 }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: bar.label,
                              fontSize: 32 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 500
                            }
                          ) }),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            "div",
                            {
                              style: {
                                flex: 1,
                                height: isPortrait ? 48 : 36,
                                borderRadius: 16 * scale,
                                background: "rgba(255,255,255,0.04)",
                                overflow: "hidden",
                                position: "relative"
                              },
                              children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                                "div",
                                {
                                  style: {
                                    width: `${widthPct * barGrow}%`,
                                    height: "100%",
                                    borderRadius: 16 * scale,
                                    background: linearGradient(
                                      90,
                                      (0,esm.interpolate)(hue, [0, 1], [0, 1]) > 0.5 ? props.accentColor : props.primaryColor,
                                      (0,esm.interpolate)(hue, [0, 1], [0, 1]) > 0.5 ? props.primaryColor : props.accentColor
                                    ),
                                    boxShadow: `0 0 20px ${props.primaryColor}33`
                                  }
                                }
                              )
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: isPortrait ? 200 : 170, flexShrink: 0, textAlign: "right" }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: bar.display,
                              fontSize: 40 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 700
                            }
                          ) })
                        ]
                      },
                      i
                    );
                  })
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6 * scale,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "data-viz-bar-chart-01",
  name: "Horizontal Bar Chart",
  category: "data-visualization",
  description: "Animated horizontal bar chart with 5 data bars, spring grow animation, and gradient fills",
  tags: ["chart", "bar", "data", "visualization", "metrics"],
  component: DataVizBarChart01,
  schema: dataVizBarChartSchema,
  defaultProps: dataVizBarChartSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/data-visualization/DataVizCounter01.tsx














const dataVizCounterSchema = lib.z.object({
  title: lib.z.string().default("Year in Review"),
  subtitle: lib.z.string().default("2025 Key Performance Metrics"),
  metric1Label: lib.z.string().default("Total Users"),
  metric1Value: lib.z.number().default(24e5),
  metric1Suffix: lib.z.string().default(""),
  metric1Prefix: lib.z.string().default(""),
  metric2Label: lib.z.string().default("Revenue"),
  metric2Value: lib.z.number().default(186e5),
  metric2Suffix: lib.z.string().default(""),
  metric2Prefix: lib.z.string().default("$"),
  metric3Label: lib.z.string().default("Countries"),
  metric3Value: lib.z.number().default(142),
  metric3Suffix: lib.z.string().default("+"),
  metric3Prefix: lib.z.string().default(""),
  metric4Label: lib.z.string().default("Uptime"),
  metric4Value: lib.z.number().default(99.97),
  metric4Suffix: lib.z.string().default("%"),
  metric4Prefix: lib.z.string().default(""),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
function formatNumber(n) {
  if (n >= 1e6) return (n / 1e6).toFixed(1) + "M";
  if (n >= 1e3) return (n / 1e3).toFixed(n >= 1e4 ? 0 : 1) + "K";
  if (n % 1 !== 0) return n.toFixed(2);
  return n.toLocaleString();
}
const DataVizCounter01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const metrics = [
    { label: props.metric1Label, value: props.metric1Value, prefix: props.metric1Prefix, suffix: props.metric1Suffix },
    { label: props.metric2Label, value: props.metric2Value, prefix: props.metric2Prefix, suffix: props.metric2Suffix },
    { label: props.metric3Label, value: props.metric3Value, prefix: props.metric3Prefix, suffix: props.metric3Suffix },
    { label: props.metric4Label, value: props.metric4Value, prefix: props.metric4Prefix, suffix: props.metric4Suffix }
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%)",
              width: "70%",
              height: "70%",
              borderRadius: "50%",
              background: `radial-gradient(ellipse, ${props.primaryColor}08, transparent 70%)`
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 40 : 64
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { opacity: fadeIn(frame, 0) }, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.title,
                    fontSize: isPortrait ? 92 : 112,
                    fontFamily: interFont,
                    color: COLORS.textPrimary,
                    fontWeight: 800,
                    lineHeight: 1.1,
                    letterSpacing: -1
                  }
                ),
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.subtitle,
                    fontSize: isPortrait ? 44 : 52,
                    fontFamily: interFont,
                    color: COLORS.textSecondary,
                    fontWeight: 400,
                    style: { marginTop: 16 * scale }
                  }
                )
              ] }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    display: "grid",
                    gridTemplateColumns: isPortrait ? "1fr" : "1fr 1fr",
                    gap: isPortrait ? 32 : 48,
                    alignContent: "center"
                  },
                  children: metrics.map((metric, i) => {
                    const delay = 15 + staggerDelay(i, 12);
                    const cardSpring = (0,esm.spring)({
                      frame: frame - delay,
                      fps,
                      config: { damping: 14, stiffness: 100, mass: 0.6 }
                    });
                    const counterProgress = (0,esm.interpolate)(frame, [delay, delay + 45], [0, 1], {
                      extrapolateLeft: "clamp",
                      extrapolateRight: "clamp"
                    });
                    const currentValue = metric.value * counterProgress;
                    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "center",
                          justifyContent: "center",
                          padding: `${28 * scale}px`,
                          borderRadius: 40 * scale,
                          background: "rgba(255,255,255,0.02)",
                          border: "2px solid rgba(255,255,255,0.05)",
                          gap: 16 * scale,
                          transform: `scale(${cardSpring})`,
                          opacity: fadeIn(frame, delay)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: metric.label,
                              fontSize: 32 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 500,
                              textTransform: "uppercase",
                              letterSpacing: 3
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                            "div",
                            {
                              style: {
                                fontSize: isPortrait ? 58 : 84,
                                fontFamily: interFont,
                                fontWeight: 700,
                                backgroundImage: linearGradient(135, props.primaryColor, props.accentColor),
                                WebkitBackgroundClip: "text",
                                WebkitTextFillColor: "transparent",
                                backgroundClip: "text"
                              },
                              children: [
                                metric.prefix,
                                formatNumber(currentValue),
                                metric.suffix
                              ]
                            }
                          )
                        ]
                      },
                      i
                    );
                  })
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 80], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6 * scale,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "data-viz-counter-01",
  name: "Animated Counter Cards",
  category: "data-visualization",
  description: "Four big animated counter cards with number roll-up, gradient text, and spring entry",
  tags: ["counter", "metrics", "numbers", "data", "KPI"],
  component: DataVizCounter01,
  schema: dataVizCounterSchema,
  defaultProps: dataVizCounterSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/data-visualization/DataVizDonut01.tsx













const dataVizDonutSchema = lib.z.object({
  title: lib.z.string().default("Revenue by Category"),
  subtitle: lib.z.string().default("FY 2025 Annual Breakdown"),
  centerLabel: lib.z.string().default("Total"),
  centerValue: lib.z.string().default("$12.4M"),
  seg1Label: lib.z.string().default("SaaS"),
  seg1Pct: lib.z.number().default(38),
  seg1Color: lib.z.string().default("#536DFE"),
  seg2Label: lib.z.string().default("Services"),
  seg2Pct: lib.z.number().default(25),
  seg2Color: lib.z.string().default("#FF4081"),
  seg3Label: lib.z.string().default("Hardware"),
  seg3Pct: lib.z.number().default(20),
  seg3Color: lib.z.string().default("#FFD600"),
  seg4Label: lib.z.string().default("Licensing"),
  seg4Pct: lib.z.number().default(17),
  seg4Color: lib.z.string().default("#00E5FF"),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const DataVizDonut01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const segments = [
    { label: props.seg1Label, pct: props.seg1Pct, color: props.seg1Color },
    { label: props.seg2Label, pct: props.seg2Pct, color: props.seg2Color },
    { label: props.seg3Label, pct: props.seg3Pct, color: props.seg3Color },
    { label: props.seg4Label, pct: props.seg4Pct, color: props.seg4Color }
  ];
  const total = segments.reduce((s, seg) => s + seg.pct, 0);
  const radius = isPortrait ? 200 : 140;
  const strokeWidth = isPortrait ? 40 : 36;
  const circumference = 2 * Math.PI * radius;
  const drawProgress = (0,esm.spring)({
    frame: frame - 15,
    fps,
    config: { damping: 20, stiffness: 50, mass: 1 }
  });
  let cumulativeOffset = 0;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 80 : 48
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { opacity: fadeIn(frame, 0) }, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.title,
                    fontSize: isPortrait ? 92 : 112,
                    fontFamily: interFont,
                    color: COLORS.textPrimary,
                    fontWeight: 800,
                    lineHeight: 1.1,
                    letterSpacing: -1
                  }
                ),
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.subtitle,
                    fontSize: isPortrait ? 44 : 52,
                    fontFamily: interFont,
                    color: COLORS.textSecondary,
                    fontWeight: 400,
                    style: { marginTop: 16 * scale }
                  }
                )
              ] }),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    display: "flex",
                    flexDirection: isPortrait ? "column" : "row",
                    alignItems: isPortrait ? "stretch" : "center",
                    justifyContent: "center",
                    gap: isPortrait ? 56 : 120
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { position: "relative" }, children: [
                      /* @__PURE__ */ (0,jsx_runtime.jsx)(
                        "svg",
                        {
                          width: (radius + strokeWidth) * 2,
                          height: (radius + strokeWidth) * 2,
                          viewBox: `0 0 ${(radius + strokeWidth) * 2} ${(radius + strokeWidth) * 2}`,
                          style: { transform: "rotate(-90deg)" },
                          children: segments.map((seg, i) => {
                            const segLength = seg.pct / total * circumference;
                            const offset = cumulativeOffset;
                            cumulativeOffset += segLength;
                            return /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              "circle",
                              {
                                cx: radius + strokeWidth,
                                cy: radius + strokeWidth,
                                r: radius,
                                fill: "none",
                                stroke: seg.color,
                                strokeWidth,
                                strokeDasharray: `${segLength * drawProgress} ${circumference}`,
                                strokeDashoffset: -offset * drawProgress,
                                strokeLinecap: "round",
                                style: { filter: `drop-shadow(0 0 8px ${seg.color}44)` }
                              },
                              i
                            );
                          })
                        }
                      ),
                      /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                        "div",
                        {
                          style: {
                            position: "absolute",
                            top: "50%",
                            left: "50%",
                            transform: "translate(-50%, -50%)",
                            display: "flex",
                            flexDirection: "column",
                            alignItems: "center",
                            gap: 4 * scale,
                            opacity: fadeIn(frame, 40)
                          },
                          children: [
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              EditableText,
                              {
                                text: props.centerLabel,
                                fontSize: 32 * scale,
                                fontFamily: interFont,
                                color: COLORS.textSecondary,
                                fontWeight: 500,
                                textTransform: "uppercase",
                                letterSpacing: 2
                              }
                            ),
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              EditableText,
                              {
                                text: props.centerValue,
                                fontSize: 84 * scale,
                                fontFamily: interFont,
                                color: COLORS.textSecondary,
                                fontWeight: 700
                              }
                            )
                          ]
                        }
                      )
                    ] }),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: isPortrait ? 20 : 28 }, children: segments.map((seg, i) => {
                      const delay = 45 + staggerDelay(i, 10);
                      return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                        "div",
                        {
                          style: {
                            display: "flex",
                            alignItems: "center",
                            gap: 24 * scale,
                            opacity: fadeIn(frame, delay)
                          },
                          children: [
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              "div",
                              {
                                style: {
                                  width: 14 * scale,
                                  height: 14 * scale,
                                  borderRadius: 4 * scale,
                                  background: seg.color,
                                  flexShrink: 0,
                                  boxShadow: `0 0 8px ${seg.color}44`
                                }
                              }
                            ),
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              EditableText,
                              {
                                text: seg.label,
                                fontSize: 36 * scale,
                                fontFamily: interFont,
                                color: COLORS.textSecondary,
                                fontWeight: 500
                              }
                            ),
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              EditableText,
                              {
                                text: `${seg.pct}%`,
                                fontSize: 36 * scale,
                                fontFamily: interFont,
                                color: seg.color,
                                fontWeight: 700
                              }
                            )
                          ]
                        },
                        i
                      );
                    }) })
                  ]
                }
              )
            ]
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "data-viz-donut-01",
  name: "Donut Chart Breakdown",
  category: "data-visualization",
  description: "Animated SVG donut chart with 4 segments, center total, and color legend",
  tags: ["chart", "donut", "pie", "data", "breakdown"],
  component: DataVizDonut01,
  schema: dataVizDonutSchema,
  defaultProps: dataVizDonutSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/listicle-ranking/ListicleRanking01.tsx














const listicleRankingSchema = lib.z.object({
  title: lib.z.string().default("Top 5 AI Companies to Watch in 2026"),
  item1Rank: lib.z.string().default("01"),
  item1Name: lib.z.string().default("OpenAI"),
  item1Desc: lib.z.string().default("GPT-5 launch, $100B+ valuation"),
  item2Rank: lib.z.string().default("02"),
  item2Name: lib.z.string().default("Anthropic"),
  item2Desc: lib.z.string().default("Claude 4, enterprise safety platform"),
  item3Rank: lib.z.string().default("03"),
  item3Name: lib.z.string().default("Google DeepMind"),
  item3Desc: lib.z.string().default("Gemini Ultra 2.0, AlphaFold 4"),
  item4Rank: lib.z.string().default("04"),
  item4Name: lib.z.string().default("xAI"),
  item4Desc: lib.z.string().default("Grok-3, real-time data integration"),
  item5Rank: lib.z.string().default("05"),
  item5Name: lib.z.string().default("Mistral AI"),
  item5Desc: lib.z.string().default("Open-weight leader, EU champion"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const ListicleRanking01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const items = [
    { rank: props.item1Rank, name: props.item1Name, desc: props.item1Desc },
    { rank: props.item2Rank, name: props.item2Name, desc: props.item2Desc },
    { rank: props.item3Rank, name: props.item3Name, desc: props.item3Desc },
    { rank: props.item4Rank, name: props.item4Name, desc: props.item4Desc },
    { rank: props.item5Rank, name: props.item5Name, desc: props.item5Desc }
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 32 : 48
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.title,
                  fontSize: isPortrait ? 92 : 112,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.1,
                  letterSpacing: -1,
                  maxLines: 2,
                  style: {
                    opacity: fadeIn(frame, 0),
                    transform: slideIn(frame, "down", 0, 25)
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center",
                    gap: isPortrait ? 16 : 28
                  },
                  children: items.map((item, i) => {
                    const delay = 12 + staggerDelay(i, 10);
                    const itemSpring = (0,esm.spring)({
                      frame: frame - delay,
                      fps,
                      config: { damping: 14, stiffness: 120, mass: 0.5 }
                    });
                    const intensity = (0,esm.interpolate)(i, [0, items.length - 1], [1, 0.4]);
                    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          alignItems: "center",
                          gap: isPortrait ? 24 : 32,
                          padding: `${14 * scale}px ${20 * scale}px`,
                          borderRadius: 28,
                          background: `rgba(255,255,255,${0.01 + intensity * 0.03})`,
                          border: `2px solid rgba(255,255,255,${0.04 + intensity * 0.04})`,
                          opacity: fadeIn(frame, delay),
                          transform: `translateX(${(0,esm.interpolate)(itemSpring, [0, 1], [50, 0])}px)`
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            "div",
                            {
                              style: {
                                width: 64 * scale,
                                height: 64 * scale,
                                borderRadius: 32,
                                background: i === 0 ? linearGradient(135, props.primaryColor, props.accentColor) : `${props.primaryColor}${Math.round(intensity * 30).toString(16).padStart(2, "0")}`,
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                flexShrink: 0,
                                boxShadow: i === 0 ? `0 0 20px ${props.primaryColor}44` : "none"
                              },
                              children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                                EditableText,
                                {
                                  text: item.rank,
                                  fontSize: 34 * scale,
                                  fontFamily: interFont,
                                  color: i === 0 ? "#ffffff" : props.primaryColor,
                                  fontWeight: 800
                                }
                              )
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { flex: 1, display: "flex", flexDirection: "column", gap: 4 }, children: [
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              EditableText,
                              {
                                text: item.name,
                                fontSize: 44 * scale,
                                fontFamily: interFont,
                                color: COLORS.textSecondary,
                                fontWeight: 700
                              }
                            ),
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              EditableText,
                              {
                                text: item.desc,
                                fontSize: 32 * scale,
                                fontFamily: interFont,
                                color: COLORS.textSecondary,
                                fontWeight: 400
                              }
                            )
                          ] })
                        ]
                      },
                      i
                    );
                  })
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 80], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "listicle-ranking-01",
  name: "Top 5 Ranking List",
  category: "listicle-ranking",
  description: "Ranked list with 5 items, gradient #1 badge, staggered slide-in entry",
  tags: ["list", "ranking", "top5", "listicle"],
  component: ListicleRanking01,
  schema: listicleRankingSchema,
  defaultProps: listicleRankingSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/logo-reveal/LogoRevealGlitch01.tsx












const logoRevealGlitchSchema = lib.z.object({
  brandName: lib.z.string().default("NEXUS"),
  tagline: lib.z.string().default("Redefine Everything"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const LogoRevealGlitch01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const brandTextSize = isPortrait ? 68 : 94;
  const taglineTextSize = isPortrait ? 34 : 44;
  const nameReveal = (0,esm.spring)({
    frame: frame - 15,
    fps,
    config: { damping: 10, stiffness: 100, mass: 0.7 }
  });
  const taglineOpacity = (0,esm.interpolate)(frame, [55, 75], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const isGlitchFrame = frame > 10 && frame < 15 || frame > 40 && frame < 43 || frame > 80 && frame < 83;
  const glitchX = isGlitchFrame ? Math.sin(frame * 37) * 8 : 0;
  const glitchY = isGlitchFrame ? Math.cos(frame * 29) * 4 : 0;
  const scanLineY = (0,esm.interpolate)(frame % 60, [0, 60], [0, 100]);
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: `${scanLineY}%`,
              left: 0,
              right: 0,
              height: 2,
              background: `${props.primaryColor}15`,
              filter: "blur(1px)"
            }
          }
        ),
        renderBackgroundLayers && isGlitchFrame && /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                top: "30%",
                left: 0,
                right: 0,
                height: 6,
                background: COLORS.accent,
                opacity: 0.3,
                transform: `translateX(${glitchX * 3}px)`
              }
            }
          ),
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                top: "62%",
                left: 0,
                right: 0,
                height: 2,
                background: COLORS.accentLight,
                opacity: 0.25,
                transform: `translateX(${-glitchX * 2}px)`
              }
            }
          )
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              alignItems: "center",
              justifyContent: "center",
              gap: 40
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { position: "relative" }, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "div",
                  {
                    style: {
                      position: "absolute",
                      top: 0,
                      left: 0,
                      fontSize: brandTextSize,
                      fontFamily: interFont,
                      fontWeight: 900,
                      letterSpacing: 14,
                      color: props.primaryColor,
                      opacity: isGlitchFrame ? 0.6 : 0,
                      transform: `translate(${glitchX}px, ${glitchY}px)`,
                      mixBlendMode: "screen"
                    },
                    children: props.brandName
                  }
                ),
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "div",
                  {
                    style: {
                      position: "absolute",
                      top: 0,
                      left: 0,
                      fontSize: brandTextSize,
                      fontFamily: interFont,
                      fontWeight: 900,
                      letterSpacing: 14,
                      color: props.accentColor,
                      opacity: isGlitchFrame ? 0.6 : 0,
                      transform: `translate(${-glitchX}px, ${-glitchY}px)`,
                      mixBlendMode: "screen"
                    },
                    children: props.brandName
                  }
                ),
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "div",
                  {
                    style: {
                      fontSize: brandTextSize,
                      fontFamily: interFont,
                      fontWeight: 900,
                      letterSpacing: 14,
                      color: "#ffffff",
                      opacity: nameReveal,
                      transform: `scale(${nameReveal})`
                    },
                    children: props.brandName
                  }
                )
              ] }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    width: (0,esm.interpolate)(nameReveal, [0, 1], [0, isPortrait ? 180 : 280]),
                    height: 2,
                    background: GRADIENTS.bgMain,
                    boxShadow: `0 0 12px ${props.primaryColor}44`
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.tagline,
                  fontSize: taglineTextSize,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  letterSpacing: 6,
                  textTransform: "uppercase",
                  textAlign: "center",
                  style: { opacity: taglineOpacity }
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "logo-reveal-glitch-01",
  name: "Glitch Logo Reveal",
  category: "logo-reveal",
  description: "Cyberpunk glitch logo reveal with RGB offset layers, scan lines, and spring animation",
  tags: ["logo", "glitch", "cyberpunk", "brand", "reveal"],
  component: LogoRevealGlitch01,
  schema: logoRevealGlitchSchema,
  defaultProps: logoRevealGlitchSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/logo-reveal/LogoRevealMinimal01.tsx













const logoRevealSchema = lib.z.object({
  brandName: lib.z.string().default("AURORA"),
  tagline: lib.z.string().default("Illuminate Your Future"),
  logoEmoji: lib.z.string().default("\u2726"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const LogoRevealMinimal01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const symbolScale = (0,esm.spring)({
    frame: frame - 10,
    fps,
    config: { damping: 8, stiffness: 80, mass: 0.8 }
  });
  const symbolRotation = (0,esm.interpolate)(frame, [10, 60], [180, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const nameReveal = (0,esm.spring)({
    frame: frame - 35,
    fps,
    config: { damping: 12, stiffness: 100, mass: 0.6 }
  });
  const taglineOpacity = (0,esm.interpolate)(frame, [60, 80], [0, 1], { extrapolateRight: "clamp", extrapolateLeft: "clamp" });
  const ringScale = (0,esm.spring)({
    frame: frame - 5,
    fps,
    config: { damping: 15, stiffness: 60, mass: 1 }
  });
  const glowPulse = (0,esm.interpolate)(
    Math.sin(frame * 0.06),
    [-1, 1],
    [0.5, 1]
  );
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%)",
              width: 600,
              height: 600,
              borderRadius: "50%",
              background: `${props.primaryColor}08`,
              filter: "blur(120px)",
              opacity: glowPulse
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              alignItems: "center",
              justifyContent: "center",
              gap: 48
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { position: "relative" }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    width: 176 * scale,
                    height: 176 * scale,
                    borderRadius: "50%",
                    border: `2px solid ${props.primaryColor}30`,
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    transform: `scale(${ringScale})`,
                    boxShadow: `0 0 60px ${props.primaryColor}15`
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        fontSize: 140 * scale,
                        transform: `scale(${symbolScale}) rotate(${symbolRotation}deg)`,
                        filter: `drop-shadow(0 0 20px ${props.primaryColor}66)`
                      },
                      children: props.logoEmoji
                    }
                  )
                }
              ) }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    overflow: "hidden"
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        transform: `translateY(${(0,esm.interpolate)(nameReveal, [0, 1], [60, 0])}px)`,
                        opacity: nameReveal
                      },
                      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                        "div",
                        {
                          style: {
                            fontSize: isPortrait ? 88 : 128,
                            fontFamily: interFont,
                            fontWeight: 900,
                            letterSpacing: isPortrait ? 10 : 14,
                            textAlign: "center",
                            backgroundImage: linearGradient(135, props.primaryColor, props.accentColor),
                            WebkitBackgroundClip: "text",
                            WebkitTextFillColor: "transparent",
                            backgroundClip: "text"
                          },
                          children: props.brandName
                        }
                      )
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.tagline,
                  fontSize: isPortrait ? 36 : 44,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  textAlign: "center",
                  letterSpacing: 3,
                  style: { opacity: taglineOpacity }
                }
              )
            ]
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "logo-reveal-minimal-01",
  name: "Minimal Logo Reveal",
  category: "logo-reveal",
  description: "Clean logo reveal with rotating symbol, ring animation, gradient name, and tagline fade-in",
  tags: ["logo", "reveal", "brand", "intro", "minimal"],
  component: LogoRevealMinimal01,
  schema: logoRevealSchema,
  defaultProps: logoRevealSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/lower-thirds/LowerThirds01.tsx












const lowerThirdsSchema = lib.z.object({
  name: lib.z.string().default("Sarah Chen"),
  title: lib.z.string().default("VP of Engineering, NovaTech"),
  accentEmoji: lib.z.string().default(""),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary)
});
const LowerThirds01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const barReveal = (0,esm.spring)({
    frame: frame - 5,
    fps,
    config: { damping: 14, stiffness: 100, mass: 0.6 }
  });
  const textReveal = (0,esm.spring)({
    frame: frame - 15,
    fps,
    config: { damping: 12, stiffness: 120, mass: 0.5 }
  });
  const exitOpacity = (0,esm.interpolate)(frame, [120, 140], [1, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: isPortrait ? 120 : 60,
              left: isPortrait ? 80 : 80,
              right: isPortrait ? 80 : "auto",
              opacity: exitOpacity
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    width: (0,esm.interpolate)(barReveal, [0, 1], [0, isPortrait ? 260 : 360]),
                    height: 6 * scale,
                    borderRadius: 2 * scale,
                    background: GRADIENTS.bgMain,
                    marginBottom: 24 * scale,
                    boxShadow: `0 0 12px ${props.primaryColor}44`
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "inline-flex",
                    flexDirection: "column",
                    padding: `${14 * scale}px ${24 * scale}px`,
                    borderRadius: 24 * scale,
                    background: "rgba(0,0,0,0.7)",
                    backdropFilter: "blur(20px)",
                    border: `2px solid ${props.primaryColor}30`,
                    gap: 8 * scale,
                    transform: `translateY(${(0,esm.interpolate)(textReveal, [0, 1], [20, 0])}px)`,
                    opacity: textReveal
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 16 * scale }, children: [
                      props.accentEmoji && /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 48 * scale }, children: props.accentEmoji }),
                      /* @__PURE__ */ (0,jsx_runtime.jsx)(
                        EditableText,
                        {
                          text: props.name,
                          fontSize: isPortrait ? 72 : 64 * scale,
                          fontFamily: interFont,
                          color: props.textColor,
                          fontWeight: 700
                        }
                      )
                    ] }),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.title,
                        fontSize: isPortrait ? 40 : 36 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 500
                      }
                    )
                  ]
                }
              )
            ]
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "lower-thirds-01",
  name: "Lower Third \u2014 Name Card",
  category: "lower-thirds",
  description: "Clean lower-third name card with gradient accent bar, glass background, and exit fade",
  tags: ["lower-third", "name", "title", "overlay", "interview"],
  component: LowerThirds01,
  schema: lowerThirdsSchema,
  defaultProps: lowerThirdsSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/lower-thirds/LowerThirdsTopic01.tsx












const lowerThirdsTopicSchema = lib.z.object({
  topicLabel: lib.z.string().default("CHAPTER 3"),
  topicTitle: lib.z.string().default("Scaling Infrastructure"),
  topicSubtitle: lib.z.string().default("From 10K to 10M users"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const LowerThirdsTopic01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const barWidth = (0,esm.spring)({
    frame: frame - 3,
    fps,
    config: { damping: 16, stiffness: 80, mass: 0.5 }
  });
  const contentReveal = (0,esm.spring)({
    frame: frame - 12,
    fps,
    config: { damping: 12, stiffness: 120, mass: 0.5 }
  });
  const exitOpacity = (0,esm.interpolate)(frame, [110, 130], [1, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: isPortrait ? 130 : 80,
              left: isPortrait ? 80 : 80,
              right: isPortrait ? 80 : "auto",
              opacity: exitOpacity
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: 24 * scale,
                    marginBottom: 20 * scale
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          width: (0,esm.interpolate)(barWidth, [0, 1], [0, 48]),
                          height: 8 * scale,
                          borderRadius: 2 * scale,
                          background: GRADIENTS.bgMain,
                          boxShadow: `0 0 12px ${props.primaryColor}44`
                        }
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.topicLabel,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 800,
                        letterSpacing: 3,
                        style: { opacity: contentReveal }
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    transform: `translateY(${(0,esm.interpolate)(contentReveal, [0, 1], [15, 0])}px)`,
                    opacity: contentReveal
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.topicTitle,
                      fontSize: isPortrait ? 76 : 84,
                      fontFamily: interFont,
                      color: COLORS.textPrimary,
                      fontWeight: 800,
                      letterSpacing: -1
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.topicSubtitle,
                  fontSize: isPortrait ? 44 : 52,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  style: {
                    marginTop: 8 * scale,
                    opacity: (0,esm.interpolate)(contentReveal, [0.3, 1], [0, 1], {
                      extrapolateLeft: "clamp",
                      extrapolateRight: "clamp"
                    })
                  }
                }
              )
            ]
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "lower-thirds-topic-01",
  name: "Lower Third \u2014 Topic Card",
  category: "lower-thirds",
  description: "Chapter/topic card overlay with accent bar, label, title, and subtitle with exit fade",
  tags: ["lower-third", "topic", "chapter", "overlay", "presentation"],
  component: LowerThirdsTopic01,
  schema: lowerThirdsTopicSchema,
  defaultProps: lowerThirdsTopicSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/social-hooks/ArticleHighlight01.tsx











const articleHighlightSchema = lib.z.object({
  screenshotUrl: lib.z.string().default("https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=1200"),
  highlightText1: lib.z.string().default("Key finding #1"),
  highlightText2: lib.z.string().default("Important stat here"),
  callout1: lib.z.string().default("This proves the point"),
  callout2: lib.z.string().default("Look at this number"),
  highlightColor: lib.z.string().default("#FFE135"),
  arrowColor: lib.z.string().default("#FF6B35"),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const ArticleHighlight01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  void shouldRenderBackgroundLayer(backgroundControls);
  const screenshotSpring = (0,esm.spring)({
    frame,
    fps,
    config: { damping: 14, stiffness: 100, mass: 1 }
  });
  const screenshotScale = (0,esm.interpolate)(screenshotSpring, [0, 1], [1.1, 1]);
  const highlight1Width = (0,esm.interpolate)(frame, [24, 72], [0, 100], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const arrow1Spring = (0,esm.spring)({
    frame: frame - 72,
    fps,
    config: { damping: 12, stiffness: 140, mass: 0.6 }
  });
  const arrow1StrokeDash = (0,esm.interpolate)(frame, [72, 100], [100, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const highlight2Width = (0,esm.interpolate)(frame, [120, 180], [0, 100], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const arrow2Spring = (0,esm.spring)({
    frame: frame - 180,
    fps,
    config: { damping: 12, stiffness: 140, mass: 0.6 }
  });
  const arrow2StrokeDash = (0,esm.interpolate)(frame, [180, 210], [100, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const driftX = (0,esm.interpolate)(frame, [240, 390], [0, 15 * s], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const driftY = (0,esm.interpolate)(frame, [240, 390], [0, 8 * s], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const headingSpring = (0,esm.spring)({
    frame: frame - 8,
    fps,
    config: { damping: 15, stiffness: 120, mass: 0.9 }
  });
  const headingY = (0,esm.interpolate)(headingSpring, [0, 1], [28 * s, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const headingOpacity = (0,esm.interpolate)(frame, [8, 32], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const screenshotSize = isPortrait ? { width: "90%", height: "auto" } : { width: "60%", height: "auto" };
  const highlightHeadlineSize = (isPortrait ? 56 : 68) * s;
  const highlightSublineSize = (isPortrait ? 34 : 40) * s;
  const calloutTextSize = (isPortrait ? 28 : 34) * s;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: isPortrait ? "center" : "flex-start",
              alignItems: "center",
              padding: isPortrait ? `${112 * s}px ${36 * s}px ${96 * s}px` : `0 ${72 * s}px`,
              transform: `scale(${screenshotScale}) translate(${driftX}px, ${driftY}px)`
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { position: "relative" }, children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                esm.Img,
                {
                  src: props.screenshotUrl,
                  style: {
                    ...screenshotSize,
                    borderRadius: 16 * s,
                    boxShadow: `0 ${20 * s}px ${60 * s}px rgba(0,0,0,0.5)`
                  }
                }
              ),
              frame >= 24 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    position: "absolute",
                    top: isPortrait ? "25%" : "30%",
                    left: "5%",
                    width: `${highlight1Width * 0.6}%`,
                    height: isPortrait ? 32 : 40,
                    background: `${props.highlightColor}88`,
                    borderRadius: 4
                  }
                }
              ),
              frame >= 120 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    position: "absolute",
                    top: isPortrait ? "55%" : "60%",
                    left: "5%",
                    width: `${highlight2Width * 0.5}%`,
                    height: isPortrait ? 32 : 40,
                    background: `${props.highlightColor}88`,
                    borderRadius: 4
                  }
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "absolute",
              top: isPortrait ? `${6 + driftY * 0.02}%` : "8%",
              right: isPortrait ? "6%" : "7%",
              maxWidth: isPortrait ? "88%" : "34%",
              opacity: headingOpacity,
              transform: `translateY(${headingY}px)`,
              textAlign: isPortrait ? "left" : "right"
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.highlightText1,
                  fontSize: highlightHeadlineSize,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.14
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { marginTop: 10 * s }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.highlightText2,
                  fontSize: highlightSublineSize,
                  fontFamily: interFont,
                  color: props.highlightColor,
                  fontWeight: 700,
                  lineHeight: 1.24
                }
              ) })
            ]
          }
        ),
        frame >= 72 && /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "absolute",
              top: isPortrait ? "35%" : "25%",
              right: isPortrait ? "10%" : "25%",
              opacity: arrow1Spring,
              transform: `scale(${arrow1Spring})`
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { width: "80", height: "60", viewBox: "0 0 80 60", children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "path",
                  {
                    d: "M 70 50 Q 40 30 10 10",
                    fill: "none",
                    stroke: props.arrowColor,
                    strokeWidth: "4",
                    strokeLinecap: "round",
                    strokeDasharray: "100",
                    strokeDashoffset: arrow1StrokeDash
                  }
                ),
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "polygon",
                  {
                    points: "0,15 15,10 10,25",
                    fill: props.arrowColor,
                    style: { opacity: frame >= 100 ? 1 : 0 }
                  }
                )
              ] }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    background: COLORS.surface,
                    border: `2px solid ${props.arrowColor}`,
                    borderRadius: 12 * s,
                    padding: `${12 * s}px ${20 * s}px`,
                    marginTop: -10 * s
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.callout1,
                      fontSize: calloutTextSize,
                      fontFamily: interFont,
                      color: COLORS.textPrimary,
                      fontWeight: 600
                    }
                  )
                }
              )
            ]
          }
        ),
        frame >= 180 && /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: isPortrait ? "25%" : "20%",
              right: isPortrait ? "10%" : "20%",
              opacity: arrow2Spring,
              transform: `scale(${arrow2Spring})`
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)("svg", { width: "80", height: "60", viewBox: "0 0 80 60", children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "path",
                  {
                    d: "M 70 10 Q 40 30 10 50",
                    fill: "none",
                    stroke: props.arrowColor,
                    strokeWidth: "4",
                    strokeLinecap: "round",
                    strokeDasharray: "100",
                    strokeDashoffset: arrow2StrokeDash
                  }
                ),
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "polygon",
                  {
                    points: "0,45 15,50 10,35",
                    fill: props.arrowColor,
                    style: { opacity: frame >= 210 ? 1 : 0 }
                  }
                )
              ] }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    background: COLORS.surface,
                    border: `2px solid ${props.arrowColor}`,
                    borderRadius: 12,
                    padding: "12px 20px"
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.callout2,
                      fontSize: calloutTextSize,
                      fontFamily: interFont,
                      color: COLORS.textPrimary,
                      fontWeight: 600
                    }
                  )
                }
              )
            ]
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "article-highlight-01",
  name: "Article Screenshot Highlight",
  category: "social-hooks",
  description: "Screenshot with animated highlight bars and arrow callouts for proof segments.",
  tags: ["screenshot", "highlight", "proof", "article", "callout", "arrow"],
  component: ArticleHighlight01,
  schema: articleHighlightSchema,
  defaultProps: articleHighlightSchema.parse({}),
  durationInFrames: 390,
  // 13s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/AutoWhoosh01.tsx












const autoWhooshSchema = lib.z.object({
  scene1Url: lib.z.string().default("https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=1920"),
  scene2Url: lib.z.string().default("https://images.unsplash.com/photo-1553877522-43269d4ea984?w=1920"),
  scene3Url: lib.z.string().default("https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=1920"),
  ctaText: lib.z.string().default("Follow for more"),
  transitionColor: lib.z.string().default("#00D4FF"),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const AutoWhoosh01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const scene1Zoom = (0,esm.interpolate)(frame, [0, 110], [1, 1.05], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const scene1Opacity = frame < 125 ? 1 : 0;
  const trans1Progress = (0,esm.interpolate)(frame, [110, 140], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const trans1X = (0,esm.interpolate)(trans1Progress, [0, 0.5, 1], [100, 0, -100]);
  const trans1Opacity = (0,esm.interpolate)(trans1Progress, [0, 0.3, 0.7, 1], [0, 1, 1, 0]);
  const scene2Zoom = (0,esm.interpolate)(frame, [140, 250], [1, 1.04], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const scene2Opacity = frame >= 125 && frame < 265 ? 1 : 0;
  const trans2Progress = (0,esm.interpolate)(frame, [250, 280], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const trans2X = (0,esm.interpolate)(trans2Progress, [0, 0.5, 1], [100, 0, -100]);
  const trans2Opacity = (0,esm.interpolate)(trans2Progress, [0, 0.3, 0.7, 1], [0, 1, 1, 0]);
  const scene3Zoom = (0,esm.interpolate)(frame, [280, 360], [1, 1.03], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const scene3Opacity = frame >= 265 ? 1 : 0;
  const ctaOpacity = fadeIn(frame - 300, 20);
  const ctaY = (0,esm.interpolate)(frame, [300, 330], [40 * s, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.out(esm.Easing.back(1.5))
  });
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        scene1Opacity > 0 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              transform: `scale(${scene1Zoom})`,
              opacity: scene1Opacity
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              esm.Img,
              {
                src: props.scene1Url,
                style: {
                  width: "100%",
                  height: "100%",
                  objectFit: "cover"
                }
              }
            )
          }
        ),
        scene2Opacity > 0 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              transform: `scale(${scene2Zoom})`,
              opacity: scene2Opacity
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              esm.Img,
              {
                src: props.scene2Url,
                style: {
                  width: "100%",
                  height: "100%",
                  objectFit: "cover"
                }
              }
            )
          }
        ),
        scene3Opacity > 0 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              transform: `scale(${scene3Zoom})`,
              opacity: scene3Opacity
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              esm.Img,
              {
                src: props.scene3Url,
                style: {
                  width: "100%",
                  height: "100%",
                  objectFit: "cover"
                }
              }
            )
          }
        ),
        renderBackgroundLayers && trans1Opacity > 0 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `linear-gradient(90deg, transparent, ${props.transitionColor}ee, ${props.transitionColor}, ${props.transitionColor}ee, transparent)`,
              transform: `translateX(${trans1X}%)`,
              opacity: trans1Opacity
            }
          }
        ),
        renderBackgroundLayers && trans2Opacity > 0 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `linear-gradient(90deg, transparent, ${props.transitionColor}ee, ${props.transitionColor}, ${props.transitionColor}ee, transparent)`,
              transform: `translateX(${trans2X}%)`,
              opacity: trans2Opacity
            }
          }
        ),
        frame >= 300 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: "flex-end",
              paddingBottom: (isPortrait ? 136 : 92) * s,
              opacity: ctaOpacity,
              transform: `translateY(${ctaY}px)`
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "div",
              {
                style: {
                  background: COLORS.surface,
                  border: `${2 * s}px solid ${props.transitionColor}`,
                  padding: isPortrait ? `${16 * s}px ${40 * s}px` : `${20 * s}px ${48 * s}px`,
                  borderRadius: 100 * s,
                  boxShadow: `0 ${8 * s}px ${32 * s}px ${props.transitionColor}44`
                },
                children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.ctaText,
                    fontSize: (isPortrait ? 32 : 40) * s,
                    fontFamily: interFont,
                    color: props.transitionColor,
                    fontWeight: 700
                  }
                )
              }
            )
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "auto-whoosh-01",
  name: "Auto-Whoosh Scene Cuts",
  category: "social-hooks",
  description: "Drop 3 clips with automatic whoosh transitions and CTA ending.",
  tags: ["whoosh", "transition", "cuts", "auto", "b-roll", "scenes"],
  component: AutoWhoosh01,
  schema: autoWhooshSchema,
  defaultProps: autoWhooshSchema.parse({}),
  durationInFrames: 360,
  // 12s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/BilingualOutro01.tsx












const bilingualOutroSchema = lib.z.object({
  presenterImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=800"),
  line1: lib.z.string().default("\u0915\u094D\u092F\u093E \u0938\u091A \u092E\u0947\u0902"),
  keywordLine: lib.z.string().default("PERSONALITY"),
  amountLine: lib.z.string().default("\u20B947 LAKH"),
  ctaText: lib.z.string().default("Follow for part 2"),
  keywordColor: lib.z.string().default("#FFE135"),
  highlightColor: lib.z.string().default("#00E676"),
  backgroundColor: lib.z.string().default(COLORS.bg),
  showGrain: lib.z.boolean().default(true)
});
const BilingualOutro01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const dimOpacity = (0,esm.interpolate)(frame, [0, 30], [0, 0.55], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const presenterOpacity = fadeIn(frame, 30);
  const line1X = (0,esm.interpolate)(frame, [30, 70], [-200 * s, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.out(esm.Easing.cubic)
  });
  const line1Opacity = fadeIn(frame - 30, 20);
  const keywordSpring = (0,esm.spring)({
    frame: frame - 50,
    fps,
    config: { damping: 10, stiffness: 180, mass: 0.6 }
  });
  const keywordScale = (0,esm.interpolate)(keywordSpring, [0, 1], [1.3, 1]);
  const highlightScaleX = (0,esm.interpolate)(frame, [80, 120], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const ctaOpacity = fadeIn(frame - 250, 30);
  const ctaBounce = (0,esm.spring)({
    frame: frame - 280,
    fps,
    config: { damping: 12, stiffness: 100, mass: 0.8 }
  });
  const presenterHeight = (isPortrait ? 800 : 600) * s;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: "#000000",
              opacity: dimOpacity
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: isPortrait ? "center" : "flex-end",
              alignItems: "flex-end",
              opacity: presenterOpacity
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              esm.Img,
              {
                src: props.presenterImageUrl,
                style: {
                  height: presenterHeight,
                  width: "auto",
                  objectFit: "contain",
                  filter: `drop-shadow(0 ${20 * s}px ${40 * s}px rgba(0,0,0,0.5))`
                }
              }
            )
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              flexDirection: "column",
              justifyContent: isPortrait ? "flex-start" : "center",
              alignItems: isPortrait ? "center" : "flex-start",
              padding: isPortrait ? `${136 * s}px ${56 * s}px` : `0 ${92 * s}px`,
              gap: 24 * s
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    transform: `translateX(${line1X}px)`,
                    opacity: line1Opacity
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.line1,
                      fontSize: (isPortrait ? 56 : 64) * s,
                      fontFamily: interFont,
                      color: COLORS.textSecondary,
                      fontWeight: 600
                    }
                  )
                }
              ),
              frame >= 50 && /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    position: "relative",
                    transform: `scale(${keywordScale})`
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.keywordLine,
                        fontSize: (isPortrait ? 96 : 120) * s,
                        fontFamily: interFont,
                        color: "#000000",
                        fontWeight: 900,
                        style: {
                          position: "absolute",
                          left: 4 * s,
                          top: 4 * s,
                          opacity: 0.6
                        }
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.keywordLine,
                        fontSize: (isPortrait ? 96 : 120) * s,
                        fontFamily: interFont,
                        color: props.keywordColor,
                        fontWeight: 900,
                        style: {
                          textShadow: `0 0 ${40 * s}px ${props.keywordColor}66`
                        }
                      }
                    )
                  ]
                }
              ),
              frame >= 80 && /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { position: "relative", display: "inline-block" }, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "div",
                  {
                    style: {
                      position: "absolute",
                      left: -16 * s,
                      right: -16 * s,
                      top: "50%",
                      height: "70%",
                      transform: `translateY(-50%) scaleX(${highlightScaleX})`,
                      transformOrigin: "left",
                      background: props.highlightColor,
                      borderRadius: 8 * s,
                      zIndex: 0
                    }
                  }
                ),
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.amountLine,
                    fontSize: (isPortrait ? 80 : 96) * s,
                    fontFamily: interFont,
                    color: "#FFFFFF",
                    fontWeight: 900,
                    style: { position: "relative", zIndex: 1 }
                  }
                )
              ] })
            ]
          }
        ),
        frame >= 250 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: "flex-end",
              paddingBottom: (isPortrait ? 150 : 80) * s,
              opacity: ctaOpacity
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsxs)(
              "div",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: 12 * s,
                  background: COLORS.surface,
                  border: `${2 * s}px solid ${COLORS.border}`,
                  padding: `${12 * s}px ${28 * s}px`,
                  borderRadius: 100 * s,
                  transform: `scale(${ctaBounce})`
                },
                children: [
                  /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 24 * s }, children: "\u{1F446}" }),
                  /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.ctaText,
                      fontSize: (isPortrait ? 28 : 32) * s,
                      fontFamily: interFont,
                      color: COLORS.textPrimary,
                      fontWeight: 600
                    }
                  )
                ]
              }
            )
          }
        ),
        renderBackgroundLayers && props.showGrain && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' /%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E")`,
              opacity: 0.05,
              mixBlendMode: "overlay"
            }
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: "radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.5) 100%)"
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "bilingual-outro-01",
  name: "Bilingual Outro Question Card",
  category: "social-hooks",
  description: "End card with provocative question, bilingual text, and currency highlight bar.",
  tags: ["outro", "bilingual", "question", "currency", "highlight", "cta"],
  component: BilingualOutro01,
  schema: bilingualOutroSchema,
  defaultProps: bilingualOutroSchema.parse({}),
  durationInFrames: 360,
  // 12s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/CensorStickers01.tsx











const censorStickersSchema = lib.z.object({
  backgroundImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1557804506-669a67965ba0?w=1920"),
  stickerText: lib.z.string().default("???"),
  stickerEmoji: lib.z.string().default("\u{1F92B}"),
  sticker1X: lib.z.number().default(0.3),
  sticker1Y: lib.z.number().default(0.35),
  sticker2X: lib.z.number().default(0.7),
  sticker2Y: lib.z.number().default(0.4),
  sticker3X: lib.z.number().default(0.5),
  sticker3Y: lib.z.number().default(0.55),
  primaryColor: lib.z.string().default(COLORS.accent),
  backgroundColor: lib.z.string().default(COLORS.bg),
  showScanlines: lib.z.boolean().default(true)
});
const CensorStickers01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const stickers = [
    { x: props.sticker1X, y: props.sticker1Y, delay: 30 },
    { x: props.sticker2X, y: props.sticker2Y, delay: 36 },
    { x: props.sticker3X, y: props.sticker3Y, delay: 42 }
  ];
  const stickerSize = (isPortrait ? 140 : 180) * s;
  const stickerEmojiSize = (isPortrait ? 56 : 74) * s;
  const stickerTextSize = (isPortrait ? 24 : 34) * s;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Img,
          {
            src: props.backgroundImageUrl,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              filter: "brightness(0.7)"
            }
          }
        ) }),
        renderBackgroundLayers && props.showScanlines && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              backgroundImage: `repeating-linear-gradient(
                            0deg,
                            transparent,
                            transparent 2px,
                            rgba(0,0,0,0.08) 2px,
                            rgba(0,0,0,0.08) 4px
                        )`
            }
          }
        ),
        stickers.map((sticker, i) => {
          const entryY = (0,esm.interpolate)(frame, [sticker.delay, sticker.delay + 12], [300 * s, 0], {
            extrapolateLeft: "clamp",
            extrapolateRight: "clamp",
            easing: esm.Easing.out(esm.Easing.back(1.6))
          });
          const entryScale = (0,esm.interpolate)(frame, [sticker.delay, sticker.delay + 12], [0.5, 1], {
            extrapolateLeft: "clamp",
            extrapolateRight: "clamp",
            easing: esm.Easing.out(esm.Easing.back(1.6))
          });
          const entryBlur = (0,esm.interpolate)(frame, [sticker.delay, sticker.delay + 8], [6 * s, 0], {
            extrapolateLeft: "clamp",
            extrapolateRight: "clamp"
          });
          const entryOpacity = (0,esm.interpolate)(frame, [sticker.delay, sticker.delay + 6], [0, 1], {
            extrapolateLeft: "clamp",
            extrapolateRight: "clamp"
          });
          const bounceY = (0,esm.interpolate)(frame, [sticker.delay + 12, sticker.delay + 18, sticker.delay + 25], [0, -15 * s, 0], {
            extrapolateLeft: "clamp",
            extrapolateRight: "clamp"
          });
          const jitterX = frame >= 55 && frame < 240 ? ((0,esm.random)(`jx${i}${Math.floor(frame / 3)}`) - 0.5) * 2 : 0;
          const jitterY = frame >= 55 && frame < 240 ? ((0,esm.random)(`jy${i}${Math.floor(frame / 3)}`) - 0.5) * 2 : 0;
          const jitterRotate = frame >= 55 && frame < 240 ? ((0,esm.random)(`jr${i}${Math.floor(frame / 4)}`) - 0.5) * 2 : 0;
          const exitRotate = (0,esm.interpolate)(frame, [240, 280], [0, 45], {
            extrapolateLeft: "clamp",
            extrapolateRight: "clamp",
            easing: esm.Easing.in(esm.Easing.cubic)
          });
          const exitX = (0,esm.interpolate)(frame, [240, 300], [0, 200 * s * (i % 2 === 0 ? 1 : -1)], {
            extrapolateLeft: "clamp",
            extrapolateRight: "clamp"
          });
          const exitOpacity = (0,esm.interpolate)(frame, [260, 300], [1, 0], {
            extrapolateLeft: "clamp",
            extrapolateRight: "clamp"
          });
          const isVisible = frame >= sticker.delay;
          return isVisible ? /* @__PURE__ */ (0,jsx_runtime.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                left: `${sticker.x * 100}%`,
                top: `${sticker.y * 100}%`,
                transform: `
                                translate(-50%, -50%)
                                translateY(${entryY + bounceY + jitterY}px)
                                translateX(${jitterX + exitX}px)
                                scale(${entryScale})
                                rotate(${jitterRotate + exitRotate}deg)
                            `,
                filter: `blur(${entryBlur}px)`,
                opacity: entryOpacity * exitOpacity
              },
              children: /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    width: stickerSize,
                    height: stickerSize,
                    borderRadius: "50%",
                    background: `linear-gradient(135deg, ${props.primaryColor}, ${props.primaryColor}cc)`,
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    justifyContent: "center",
                    boxShadow: `0 ${8 * s}px ${32 * s}px ${props.primaryColor}66`,
                    border: `${4 * s}px solid rgba(255,255,255,0.3)`
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: stickerEmojiSize }, children: props.stickerEmoji }),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.stickerText,
                        fontSize: stickerTextSize,
                        fontFamily: interFont,
                        color: "#FFFFFF",
                        fontWeight: 800
                      }
                    )
                  ]
                }
              )
            },
            i
          ) : null;
        })
      ]
    }
  );
};
registerTemplate({
  id: "censor-stickers-01",
  name: "Censor Stickers Face Cover",
  category: "social-hooks",
  description: "Branded circular stickers fly in to cover faces with motion blur and stick effect.",
  tags: ["censor", "sticker", "privacy", "face-cover", "gag", "secret"],
  component: CensorStickers01,
  schema: censorStickersSchema,
  defaultProps: censorStickersSchema.parse({}),
  durationInFrames: 300,
  // 10s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/CollagePiP01.tsx












const collagePiPSchema = lib.z.object({
  backgroundImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=1920"),
  card1Url: lib.z.string().default("https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=600"),
  card2Url: lib.z.string().default("https://images.unsplash.com/photo-1553877522-43269d4ea984?w=600"),
  card3Url: lib.z.string().default("https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=600"),
  card4Url: lib.z.string().default("https://images.unsplash.com/photo-1557804506-669a67965ba0?w=600"),
  card5Url: lib.z.string().default("https://images.unsplash.com/photo-1559136555-9303baea8ebd?w=600"),
  pipImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1573496359142-b8d87734a5a2?w=400"),
  subtitle1: lib.z.string().default("Multiple factors"),
  subtitle2: lib.z.string().default("lead to success"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accent),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const CollagePiP01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const cardUrls = [props.card1Url, props.card2Url, props.card3Url, props.card4Url, props.card5Url];
  const cardRotations = [-12, 8, -6, 10, -8];
  const cardOffsets = isPortrait ? [{ x: -120 * s, y: -200 * s }, { x: 100 * s, y: -150 * s }, { x: -80 * s, y: 50 * s }, { x: 120 * s, y: 100 * s }, { x: 0 * s, y: 250 * s }] : [{ x: -300 * s, y: -100 * s }, { x: -150 * s, y: 50 * s }, { x: 0, y: -80 * s }, { x: 150 * s, y: 60 * s }, { x: 300 * s, y: -40 * s }];
  const bgScale = (0,esm.interpolate)(frame, [0, 20], [1.2, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const getCardSpring = (index) => (0,esm.spring)({
    frame: frame - (12 + index * 12),
    fps,
    config: { damping: 14, stiffness: 100, mass: 0.8 }
  });
  const pipSpring = (0,esm.spring)({
    frame: frame - 60,
    fps,
    config: { damping: 12, stiffness: 120, mass: 1 }
  });
  const pipY = (0,esm.interpolate)(pipSpring, [0, 1], [200 * s, 0]);
  const pipScale = (0,esm.interpolate)(pipSpring, [0, 1], [0.6, 1]);
  const ringProgress = (0,esm.interpolate)(frame, [60, 105], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const getFloat = (index) => Math.sin((frame - 105 + index * 20) * 0.05) * (4 * s);
  const pipBreath = 1 + Math.sin((frame - 105) * 0.03) * 0.02;
  const subtitleOpacity = fadeIn(frame - 360, 30);
  const subtitleY = (0,esm.interpolate)(frame, [360, 390], [30 * s, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const flashOpacity = (0,esm.interpolate)(frame, [420, 430, 440, 450], [0, 0.8, 0.3, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const pipSize = (isPortrait ? 160 : 200) * s;
  const cardSize = isPortrait ? { w: 180 * s, h: 240 * s } : { w: 220 * s, h: 300 * s };
  const subtitlePrimarySize = (isPortrait ? 58 : 68) * s;
  const subtitleSecondarySize = (isPortrait ? 30 : 34) * s;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { transform: `scale(${bgScale})` }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Img,
          {
            src: props.backgroundImageUrl,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              filter: "brightness(0.4) blur(2px)"
            }
          }
        ) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: "center"
            },
            children: cardUrls.map((url, i) => {
              const cardSpring = getCardSpring(i);
              const float = frame >= 105 && frame < 360 ? getFloat(i) : 0;
              return /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    position: "absolute",
                    transform: `
                                    translate(${cardOffsets[i].x}px, ${cardOffsets[i].y + float}px)
                                    rotate(${(0,esm.interpolate)(cardSpring, [0, 1], [cardRotations[i] * 2, cardRotations[i]])}deg)
                                    scale(${(0,esm.interpolate)(cardSpring, [0, 1], [0.6, 1])})
                                `,
                    opacity: cardSpring
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    esm.Img,
                    {
                      src: url,
                      style: {
                        width: cardSize.w,
                        height: cardSize.h,
                        objectFit: "cover",
                        borderRadius: 16 * s,
                        boxShadow: `0 ${12 * s}px ${40 * s}px rgba(0,0,0,0.5)`,
                        border: `${3 * s}px solid ${COLORS.surface}`
                      }
                    }
                  )
                },
                i
              );
            })
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: isPortrait ? "flex-end" : "flex-end",
              padding: isPortrait ? "0 0 300px" : "0 0 120px"
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsxs)(
              "div",
              {
                style: {
                  position: "relative",
                  transform: `translateY(${pipY}px) scale(${pipScale * (frame >= 105 ? pipBreath : 1)})`
                },
                children: [
                  /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "svg",
                    {
                      width: pipSize + 20 * s,
                      height: pipSize + 20 * s,
                      style: {
                        position: "absolute",
                        top: -10 * s,
                        left: -10 * s
                      },
                      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                        "circle",
                        {
                          cx: (pipSize + 20 * s) / 2,
                          cy: (pipSize + 20 * s) / 2,
                          r: pipSize / 2 + 5 * s,
                          fill: "none",
                          stroke: props.primaryColor,
                          strokeWidth: 4 * s,
                          strokeDasharray: Math.PI * (pipSize + 10 * s),
                          strokeDashoffset: Math.PI * (pipSize + 10 * s) * (1 - ringProgress),
                          strokeLinecap: "round"
                        }
                      )
                    }
                  ),
                  /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    esm.Img,
                    {
                      src: props.pipImageUrl,
                      style: {
                        width: pipSize,
                        height: pipSize,
                        objectFit: "cover",
                        borderRadius: "50%",
                        boxShadow: `0 ${8 * s}px ${32 * s}px ${props.primaryColor}44`
                      }
                    }
                  )
                ]
              }
            )
          }
        ),
        frame >= 360 && /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              flexDirection: "column",
              justifyContent: "flex-end",
              alignItems: "center",
              padding: isPortrait ? "0 60px 120px" : "0 100px 60px",
              opacity: subtitleOpacity,
              transform: `translateY(${subtitleY}px)`
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subtitle1,
                  fontSize: subtitlePrimarySize,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 700
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subtitle2,
                  fontSize: subtitleSecondarySize,
                  fontFamily: interFont,
                  color: props.primaryColor,
                  fontWeight: 700
                }
              )
            ]
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `linear-gradient(135deg, ${props.primaryColor}, #ffffff)`,
              opacity: flashOpacity,
              mixBlendMode: "screen"
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "collage-pip-01",
  name: "Collage + Circular PiP",
  category: "social-hooks",
  description: "Background subject with fanned mini-cards and circular presenter PiP for multi-factor explanations.",
  tags: ["collage", "pip", "cards", "presenter", "factors", "explainer"],
  component: CollagePiP01,
  schema: collagePiPSchema,
  defaultProps: collagePiPSchema.parse({}),
  durationInFrames: 450,
  // 15s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/CutoutHook01.tsx












const cutoutHookSchema = lib.z.object({
  presenterImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=800"),
  backgroundVideoUrl: lib.z.string().default("https://images.unsplash.com/photo-1557804506-669a67965ba0?w=1920"),
  headline: lib.z.string().default("3 SECRETS TO VIRAL CONTENT"),
  captionText: lib.z.string().default("Watch till the end for the biggest tip"),
  icon1Emoji: lib.z.string().default("\u{1F4F1}"),
  icon2Emoji: lib.z.string().default("\u{1F3AC}"),
  icon3Emoji: lib.z.string().default("\u{1F680}"),
  icon1Label: lib.z.string().default("TikTok"),
  icon2Label: lib.z.string().default("YouTube"),
  icon3Label: lib.z.string().default("Instagram"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accent),
  backgroundColor: lib.z.string().default(COLORS.bg),
  showGrain: lib.z.boolean().default(true),
  showVignette: lib.z.boolean().default(true)
});
const CutoutHook01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const presenterSpring = (0,esm.spring)({
    frame,
    fps,
    config: { damping: 16, stiffness: 140, mass: 1 }
  });
  const presenterScale = (0,esm.interpolate)(presenterSpring, [0, 1], [1.25, 1]);
  const presenterY = (0,esm.interpolate)(frame, [18, 28], [0, 200 * s], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.in(esm.Easing.cubic)
  });
  const presenterBlur = (0,esm.interpolate)(frame, [18, 28], [0, 8 * s], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const presenterOpacity = (0,esm.interpolate)(frame, [18, 28], [1, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const glowOpacity = (0,esm.interpolate)(frame, [8, 22], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const icon1Spring = (0,esm.spring)({
    frame: frame - 28,
    fps,
    config: { damping: 14, stiffness: 120, mass: 0.8 }
  });
  const icon2Spring = (0,esm.spring)({
    frame: frame - 36,
    fps,
    config: { damping: 14, stiffness: 120, mass: 0.8 }
  });
  const icon3Spring = (0,esm.spring)({
    frame: frame - 44,
    fps,
    config: { damping: 14, stiffness: 120, mass: 0.8 }
  });
  const captionWipe = (0,esm.interpolate)(frame, [70, 90], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const keywordPunchFrame = Math.floor((frame - 70) / 45) * 45 + 70;
  const keywordScale = frame >= 70 ? (0,esm.spring)({
    frame: frame - keywordPunchFrame,
    fps,
    config: { damping: 12, stiffness: 200, mass: 0.5 }
  }) : 0;
  const bgZoom = (0,esm.interpolate)(frame, [210, 320], [1.03, 1.06], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const flashOpacity = (0,esm.interpolate)(frame, [320, 328, 340, 360], [0, 0.9, 0.4, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const reentrySpring = (0,esm.spring)({
    frame: frame - 340,
    fps,
    config: { damping: 14, stiffness: 100, mass: 1 }
  });
  const reentryScale = frame >= 340 ? (0,esm.interpolate)(reentrySpring, [0, 1], [0.8, 1]) : 0;
  const reentryOpacity = frame >= 340 ? (0,esm.interpolate)(reentrySpring, [0, 1], [0, 1]) : 0;
  const iconSize = (isPortrait ? 100 : 120) * s;
  const presenterSize = isPortrait ? { width: 500 * s, height: 700 * s } : { width: 600 * s, height: 850 * s };
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              transform: `scale(${bgZoom})`
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              esm.Img,
              {
                src: props.backgroundVideoUrl,
                style: {
                  width: "100%",
                  height: "100%",
                  objectFit: "cover",
                  filter: "brightness(0.4) contrast(1.1) saturate(1.12)"
                }
              }
            )
          }
        ),
        renderBackgroundLayers && props.showVignette && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: "radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.7) 100%)"
            }
          }
        ),
        renderBackgroundLayers && props.showGrain && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' /%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E")`,
              opacity: 0.08,
              mixBlendMode: "overlay"
            }
          }
        ),
        frame < 28 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: isPortrait ? "center" : "flex-end",
              paddingBottom: isPortrait ? 0 : 100 * s
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsxs)(
              "div",
              {
                style: {
                  position: "relative",
                  transform: `scale(${presenterScale}) translateY(${presenterY}px)`,
                  filter: `blur(${presenterBlur}px)`,
                  opacity: presenterOpacity
                },
                children: [
                  /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        position: "absolute",
                        inset: -8 * s,
                        borderRadius: 24 * s,
                        boxShadow: `0 0 ${60 * s}px ${props.primaryColor}`,
                        opacity: glowOpacity
                      }
                    }
                  ),
                  /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    esm.Img,
                    {
                      src: props.presenterImageUrl,
                      style: {
                        ...presenterSize,
                        objectFit: "cover",
                        borderRadius: 20 * s,
                        boxShadow: `0 ${20 * s}px ${60 * s}px rgba(0,0,0,0.5)`
                      }
                    }
                  )
                ]
              }
            )
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Sequence, { from: 28, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              flexDirection: isPortrait ? "column" : "row",
              justifyContent: "center",
              alignItems: "center",
              gap: (isPortrait ? 32 : 64) * s,
              paddingTop: (isPortrait ? 140 : 72) * s
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    gap: 12 * s,
                    transform: `translateX(${(0,esm.interpolate)(icon1Spring, [0, 1], [-100 * s, 0])}px) scale(${(0,esm.interpolate)(icon1Spring, [0, 1], [0.8, 1])})`,
                    opacity: icon1Spring
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          width: iconSize,
                          height: iconSize,
                          borderRadius: iconSize / 4,
                          background: `${props.primaryColor}20`,
                          border: `3px solid ${props.primaryColor}`,
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          fontSize: iconSize * 0.5
                        },
                        children: props.icon1Emoji
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.icon1Label,
                        fontSize: (isPortrait ? 28 : 32) * s,
                        fontFamily: interFont,
                        color: COLORS.textPrimary,
                        fontWeight: 600
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    gap: 12 * s,
                    transform: `translateY(${(0,esm.interpolate)(icon2Spring, [0, 1], [-80 * s, 0])}px) scale(${(0,esm.interpolate)(icon2Spring, [0, 1], [0.7, 1])})`,
                    opacity: icon2Spring
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          width: iconSize,
                          height: iconSize,
                          borderRadius: iconSize / 4,
                          background: `${props.accentColor}20`,
                          border: `${3 * s}px solid ${props.accentColor}`,
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          fontSize: iconSize * 0.5
                        },
                        children: props.icon2Emoji
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.icon2Label,
                        fontSize: (isPortrait ? 28 : 32) * s,
                        fontFamily: interFont,
                        color: COLORS.textPrimary,
                        fontWeight: 600
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    gap: 12 * s,
                    transform: `translateX(${(0,esm.interpolate)(icon3Spring, [0, 1], [100 * s, 0])}px) scale(${(0,esm.interpolate)(icon3Spring, [0, 1], [0.8, 1])})`,
                    opacity: icon3Spring
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          width: iconSize,
                          height: iconSize,
                          borderRadius: iconSize / 4,
                          background: `${props.primaryColor}20`,
                          border: `3px solid ${props.primaryColor}`,
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          fontSize: iconSize * 0.5
                        },
                        children: props.icon3Emoji
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.icon3Label,
                        fontSize: (isPortrait ? 28 : 32) * s,
                        fontFamily: interFont,
                        color: COLORS.textPrimary,
                        fontWeight: 600
                      }
                    )
                  ]
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Sequence, { from: 70, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              flexDirection: "column",
              justifyContent: isPortrait ? "flex-end" : "center",
              alignItems: "center",
              padding: isPortrait ? `0 ${56 * s}px ${150 * s}px` : `0 ${112 * s}px`
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    transform: `scaleX(${captionWipe})`,
                    transformOrigin: "left",
                    background: `linear-gradient(135deg, ${props.primaryColor}, ${props.accentColor})`,
                    padding: isPortrait ? `${24 * s}px ${48 * s}px` : `${32 * s}px ${64 * s}px`,
                    borderRadius: 16 * s
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.headline,
                      fontSize: (isPortrait ? 56 : 72) * s,
                      fontFamily: interFont,
                      color: "#FFFFFF",
                      fontWeight: 900,
                      textAlign: "center",
                      style: {
                        transform: `scale(${1 + keywordScale * 0.06})`,
                        textShadow: "0 4px 20px rgba(0,0,0,0.3)"
                      }
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { marginTop: 24 * s, opacity: fadeIn(frame - 70, 20) }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.captionText,
                  fontSize: (isPortrait ? 32 : 40) * s,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 500,
                  textAlign: "center",
                  style: {
                    ...isPortrait ? {} : { textAlign: "left" }
                  }
                }
              ) })
            ]
          }
        ) }),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `linear-gradient(135deg, ${props.primaryColor}ee, ${props.accentColor}ee, #ffffff)`,
              opacity: flashOpacity,
              mixBlendMode: "screen"
            }
          }
        ),
        frame >= 340 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: "center"
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "div",
              {
                style: {
                  transform: `scale(${reentryScale})`,
                  opacity: reentryOpacity
                },
                children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  esm.Img,
                  {
                    src: props.presenterImageUrl,
                    style: {
                      width: presenterSize.width * 0.8,
                      height: presenterSize.height * 0.8,
                      objectFit: "cover",
                      borderRadius: 20 * s,
                      boxShadow: `0 0 ${80 * s}px ${props.primaryColor}`
                    }
                  }
                )
              }
            )
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "cutout-hook-01",
  name: "Cut-out Hook with Social Proof",
  category: "social-hooks",
  description: "Short-form hook opener with presenter cut-out, platform icons, and value tag. Perfect for explainer intros.",
  tags: ["hook", "presenter", "social-proof", "icons", "intro", "explainer"],
  component: CutoutHook01,
  schema: cutoutHookSchema,
  defaultProps: cutoutHookSchema.parse({}),
  durationInFrames: 360,
  // 12s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/HeadlineCard01.tsx











const headlineCardSchema = lib.z.object({
  presenterImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=800"),
  backgroundImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1557804506-669a67965ba0?w=1920"),
  titleLine1: lib.z.string().default("PERSONALITY"),
  titleLine2: lib.z.string().default("MATTERS MORE"),
  titleLine3: lib.z.string().default("THAN MONEY"),
  titleColor: lib.z.string().default("#F21A1D"),
  shadowColor: lib.z.string().default("#000000"),
  backgroundColor: lib.z.string().default(COLORS.bg),
  showGrain: lib.z.boolean().default(true)
});
const HeadlineCard01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const bgZoom = (0,esm.interpolate)(frame, [0, 18], [1, 1.03], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const presenterSpring = (0,esm.spring)({
    frame: frame - 10,
    fps,
    config: { damping: 18, stiffness: 120, mass: 1 }
  });
  const presenterY = (0,esm.interpolate)(presenterSpring, [0, 1], [140 * s, 0]);
  const fullTitle = `${props.titleLine1} ${props.titleLine2} ${props.titleLine3}`;
  const charsPerChunk = 4;
  const typingStartFrame = 28;
  const typingFramesPerChunk = 4;
  const getVisibleChars = () => {
    if (frame < typingStartFrame) return 0;
    const elapsed = frame - typingStartFrame;
    const chunks = Math.floor(elapsed / typingFramesPerChunk);
    return Math.min(chunks * charsPerChunk, fullTitle.length);
  };
  const visibleChars = getVisibleChars();
  const visibleTitle = fullTitle.substring(0, visibleChars);
  const snapPunch = (0,esm.spring)({
    frame: frame - 56,
    fps,
    config: { damping: 8, stiffness: 300, mass: 0.5 }
  });
  const titleScale = frame >= 56 ? (0,esm.interpolate)(snapPunch, [0, 1], [1.06, 1]) : 1;
  const presenterBob = Math.sin((frame - 60) * 0.07) * (6 * s);
  const exitY = (0,esm.interpolate)(frame, [240, 280], [0, -150 * s], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.in(esm.Easing.cubic)
  });
  const exitOpacity = (0,esm.interpolate)(frame, [240, 280], [1, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const flashOpacity = (0,esm.interpolate)(frame, [280, 290, 300, 315], [0, 0.8, 0.3, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const presenterHeight = (isPortrait ? 900 : 700) * s;
  const titleFontSize = (isPortrait ? 62 : 132) * s;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              transform: `scale(${bgZoom})`
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              esm.Img,
              {
                src: props.backgroundImageUrl,
                style: {
                  width: "100%",
                  height: "100%",
                  objectFit: "cover",
                  filter: "brightness(0.3) contrast(1.2)"
                }
              }
            )
          }
        ),
        renderBackgroundLayers && props.showGrain && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' /%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E")`,
              opacity: 0.06,
              mixBlendMode: "overlay"
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              flexDirection: "column",
              justifyContent: "flex-start",
              alignItems: isPortrait ? "center" : "flex-start",
              padding: isPortrait ? `${120 * s}px ${60 * s}px` : `${100 * s}px ${120 * s}px`,
              transform: `translateY(${exitY}px)`,
              opacity: exitOpacity
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { position: "relative" }, children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: visibleTitle || " ",
                  fontSize: titleFontSize,
                  fontFamily: interFont,
                  color: props.shadowColor,
                  fontWeight: 900,
                  lineHeight: 1.1,
                  textAlign: isPortrait ? "center" : "left",
                  style: {
                    position: "absolute",
                    left: 6 * s,
                    top: 6 * s,
                    opacity: 0.7,
                    transform: `scale(${titleScale})`,
                    transformOrigin: isPortrait ? "center top" : "left top",
                    maxWidth: isPortrait ? "100%" : "70%"
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: visibleTitle || " ",
                  fontSize: titleFontSize,
                  fontFamily: interFont,
                  color: props.titleColor,
                  fontWeight: 900,
                  lineHeight: 1.1,
                  textAlign: isPortrait ? "center" : "left",
                  style: {
                    transform: `scale(${titleScale})`,
                    transformOrigin: isPortrait ? "center top" : "left top",
                    textShadow: `0 0 ${40 * s}px ${props.titleColor}66`,
                    maxWidth: isPortrait ? "100%" : "70%"
                  }
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: isPortrait ? "center" : "flex-end",
              alignItems: "flex-end",
              padding: isPortrait ? "0 0 0 0" : `0 ${100 * s}px 0 0`
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "div",
              {
                style: {
                  transform: `translateY(${presenterY + (frame >= 60 && frame < 240 ? presenterBob : 0)}px)`
                },
                children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  esm.Img,
                  {
                    src: props.presenterImageUrl,
                    style: {
                      height: presenterHeight,
                      width: "auto",
                      objectFit: "contain",
                      filter: `drop-shadow(0 ${20 * s}px ${40 * s}px rgba(0,0,0,0.5))`
                    }
                  }
                )
              }
            )
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `linear-gradient(135deg, #ffffff, ${props.titleColor}88)`,
              opacity: flashOpacity,
              mixBlendMode: "screen"
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "headline-card-01",
  name: "Big Red Title Build",
  category: "social-hooks",
  description: "Define-the-topic card with background image, presenter, and kinetic all-caps title build.",
  tags: ["headline", "title", "presenter", "kinetic", "topic", "intro"],
  component: HeadlineCard01,
  schema: headlineCardSchema,
  defaultProps: headlineCardSchema.parse({}),
  durationInFrames: 315,
  // 10.5s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/LightLeakSmash01.tsx











const lightLeakSmashSchema = lib.z.object({
  clip1Url: lib.z.string().default("https://images.unsplash.com/photo-1557804506-669a67965ba0?w=1920"),
  clip2Url: lib.z.string().default("https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=1920"),
  clip3Url: lib.z.string().default("https://images.unsplash.com/photo-1553877522-43269d4ea984?w=1920"),
  ctaText: lib.z.string().default("Follow for more"),
  leakColor1: lib.z.string().default("#FF6B35"),
  leakColor2: lib.z.string().default("#FFD93D"),
  backgroundColor: lib.z.string().default(COLORS.bg),
  showScanlines: lib.z.boolean().default(true),
  showGrain: lib.z.boolean().default(true)
});
const LightLeakSmash01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const clip1Zoom = (0,esm.interpolate)(frame, [0, 12], [1, 1.04], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const clip1Opacity = frame < 120 ? 1 : 0;
  const leak1Opacity = (0,esm.interpolate)(frame, [120, 126, 128, 145], [0, 0.9, 1, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const wash1Opacity = (0,esm.interpolate)(frame, [126, 128, 132], [0, 0.6, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const clip2Scale = (0,esm.interpolate)(frame, [145, 155], [1.08, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.out(esm.Easing.quad)
  });
  const clip2Opacity = frame >= 128 && frame < 255 ? 1 : 0;
  const leak2Opacity = (0,esm.interpolate)(frame, [255, 261, 263, 280], [0, 0.9, 1, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const wash2Opacity = (0,esm.interpolate)(frame, [261, 263, 267], [0, 0.6, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const clip3Scale = (0,esm.interpolate)(frame, [280, 290], [1.06, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.out(esm.Easing.quad)
  });
  const clip3Opacity = frame >= 263 ? 1 : 0;
  const ctaY = (0,esm.interpolate)(frame, [300, 315], [50 * s, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.out(esm.Easing.back(1.5))
  });
  const ctaOpacity = (0,esm.interpolate)(frame, [300, 315], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        clip1Opacity > 0 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              transform: `scale(${clip1Zoom})`,
              opacity: clip1Opacity
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              esm.Img,
              {
                src: props.clip1Url,
                style: {
                  width: "100%",
                  height: "100%",
                  objectFit: "cover"
                }
              }
            )
          }
        ),
        clip2Opacity > 0 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              transform: `scale(${clip2Scale})`,
              opacity: clip2Opacity
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              esm.Img,
              {
                src: props.clip2Url,
                style: {
                  width: "100%",
                  height: "100%",
                  objectFit: "cover"
                }
              }
            )
          }
        ),
        clip3Opacity > 0 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              transform: `scale(${clip3Scale})`,
              opacity: clip3Opacity
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              esm.Img,
              {
                src: props.clip3Url,
                style: {
                  width: "100%",
                  height: "100%",
                  objectFit: "cover"
                }
              }
            )
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `linear-gradient(135deg, ${props.leakColor1}ee, ${props.leakColor2}ee, transparent)`,
              opacity: leak1Opacity,
              mixBlendMode: "screen"
            }
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: "#ffffff",
              opacity: wash1Opacity
            }
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `linear-gradient(-45deg, ${props.leakColor2}ee, ${props.leakColor1}ee, transparent)`,
              opacity: leak2Opacity,
              mixBlendMode: "screen"
            }
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: "#ffffff",
              opacity: wash2Opacity
            }
          }
        ),
        renderBackgroundLayers && props.showScanlines && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `repeating-linear-gradient(
                            0deg,
                            transparent,
                            transparent 2px,
                            rgba(0,0,0,0.1) 2px,
                            rgba(0,0,0,0.1) 4px
                        )`,
              opacity: 0.06
            }
          }
        ),
        renderBackgroundLayers && props.showGrain && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' /%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E")`,
              opacity: 0.07,
              mixBlendMode: "overlay"
            }
          }
        ),
        frame >= 300 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: "flex-end",
              paddingBottom: isPortrait ? 136 : 92
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "div",
              {
                style: {
                  transform: `translateY(${ctaY}px)`,
                  opacity: ctaOpacity,
                  background: `linear-gradient(135deg, ${props.leakColor1}, ${props.leakColor2})`,
                  padding: isPortrait ? `${20 * s}px ${48 * s}px` : `${24 * s}px ${56 * s}px`,
                  borderRadius: 100 * s,
                  boxShadow: `0 ${8 * s}px ${32 * s}px ${props.leakColor1}66`
                },
                children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.ctaText,
                    fontSize: (isPortrait ? 36 : 44) * s,
                    fontFamily: interFont,
                    color: "#FFFFFF",
                    fontWeight: 700
                  }
                )
              }
            )
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "light-leak-smash-01",
  name: "Light-Leak Smash Transitions",
  category: "social-hooks",
  description: "Transition playground with 3 clips and 2 flashy light-leak cuts.",
  tags: ["transition", "light-leak", "flash", "cut", "b-roll"],
  component: LightLeakSmash01,
  schema: lightLeakSmashSchema,
  defaultProps: lightLeakSmashSchema.parse({}),
  durationInFrames: 330,
  // 11s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/MoneyRain01.tsx












const moneyRainSchema = lib.z.object({
  backgroundImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1486406146926-c627a92ad1ab?w=1920"),
  bigNumber: lib.z.string().default("$47M"),
  perYearText: lib.z.string().default("per year"),
  primaryColor: lib.z.string().default(COLORS.accent),
  burstColor: lib.z.string().default("#FFD700"),
  backgroundColor: lib.z.string().default(COLORS.bg),
  showVignette: lib.z.boolean().default(true),
  moneyCount: lib.z.number().default(30)
});
const MoneyRain01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const bgZoom = (0,esm.interpolate)(frame, [0, 45], [1, 1.03], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const burstOpacity = (0,esm.interpolate)(frame, [45, 52, 62], [0, 0.8, 0.3], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const burstScale = (0,esm.interpolate)(frame, [45, 62], [0.6, 1.1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.out(esm.Easing.quad)
  });
  const numberSpring = (0,esm.spring)({
    frame: frame - 54,
    fps,
    config: { damping: 12, stiffness: 180, mass: 0.8 }
  });
  const numberScale = (0,esm.interpolate)(numberSpring, [0, 1], [1.4, 1]);
  const numberY = (0,esm.interpolate)(numberSpring, [0, 1], [50 * s, 0]);
  const perYearOpacity = fadeIn(frame - 80, 12);
  const moneyParticles = Array.from({ length: props.moneyCount }, (_, i) => ({
    x: (0,esm.random)(`mx${i}`) * 100,
    delay: (0,esm.random)(`md${i}`) * 60,
    speed: 0.8 + (0,esm.random)(`ms${i}`) * 0.6,
    rotation: (0,esm.random)(`mr${i}`) * 360,
    rotSpeed: ((0,esm.random)(`mrs${i}`) - 0.5) * 4,
    size: 0.6 + (0,esm.random)(`msz${i}`) * 0.5
  }));
  const outroZoom = (0,esm.interpolate)(frame, [300, 360], [1, 1.08], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const outroVignette = (0,esm.interpolate)(frame, [300, 360], [0.7, 0.9], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const bigNumberSize = (isPortrait ? 150 : 176) * s;
  const perYearSize = (isPortrait ? 44 : 52) * s;
  const headlinePadding = isPortrait ? `${156 * s}px ${54 * s}px` : `0 ${112 * s}px`;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              transform: `scale(${bgZoom * outroZoom})`
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              esm.Img,
              {
                src: props.backgroundImageUrl,
                style: {
                  width: "100%",
                  height: "100%",
                  objectFit: "cover",
                  filter: "brightness(0.4) contrast(1.1)"
                }
              }
            )
          }
        ),
        renderBackgroundLayers && frame >= 45 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: "center"
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "div",
              {
                style: {
                  width: (isPortrait ? 600 : 800) * s,
                  height: (isPortrait ? 600 : 800) * s,
                  borderRadius: "50%",
                  background: `radial-gradient(circle, ${props.burstColor}88, ${props.primaryColor}44, transparent)`,
                  transform: `scale(${burstScale})`,
                  opacity: burstOpacity,
                  filter: `blur(${40 * s}px)`
                }
              }
            )
          }
        ),
        frame >= 62 && renderBackgroundLayers && moneyParticles.map((p, i) => {
          const particleFrame = frame - 62 - p.delay;
          if (particleFrame < 0) return null;
          const y = particleFrame * p.speed * 8 * s % ((isPortrait ? 2e3 : 1200) * s);
          const rotation = p.rotation + particleFrame * p.rotSpeed;
          const opacity = (0,esm.interpolate)(y, [0, 100, 1e3, 1100], [0, 1, 1, 0]);
          return /* @__PURE__ */ (0,jsx_runtime.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                left: `${p.x}%`,
                top: y - 100 * s,
                transform: `rotate(${rotation}deg) scale(${p.size})`,
                opacity: opacity * 0.8,
                fontSize: (isPortrait ? 48 : 56) * s
              },
              children: "\u{1F4B5}"
            },
            i
          );
        }),
        frame >= 54 && /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              flexDirection: "column",
              justifyContent: isPortrait ? "flex-start" : "center",
              alignItems: isPortrait ? "center" : "flex-start",
              padding: headlinePadding
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    transform: `scale(${numberScale}) translateY(${numberY}px)`
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.bigNumber,
                      fontSize: bigNumberSize,
                      fontFamily: interFont,
                      color: props.primaryColor,
                      fontWeight: 900,
                      style: {
                        textShadow: `0 0 ${80 * s}px ${props.primaryColor}88, 0 ${8 * s}px ${32 * s}px rgba(0,0,0,0.5)`
                      }
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    opacity: perYearOpacity,
                    marginTop: (isPortrait ? 20 : 16) * s,
                    textAlign: isPortrait ? "center" : "left"
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.perYearText,
                      fontSize: perYearSize,
                      fontFamily: interFont,
                      color: COLORS.textSecondary,
                      fontWeight: 600
                    }
                  )
                }
              )
            ]
          }
        ),
        renderBackgroundLayers && props.showVignette && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `radial-gradient(ellipse at center, transparent 30%, rgba(0,0,0,${outroVignette}) 100%)`
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "money-rain-01",
  name: "Money Rain Number Impact",
  category: "social-hooks",
  description: "Big green revenue number with burst cloud and continuous money rain particles.",
  tags: ["money", "revenue", "impact", "number", "rain", "profit"],
  component: MoneyRain01,
  schema: moneyRainSchema,
  defaultProps: moneyRainSchema.parse({}),
  durationInFrames: 360,
  // 12s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/PhoneCameo01.tsx












const phoneCameoSchema = lib.z.object({
  phoneVideoUrl: lib.z.string().default("https://images.unsplash.com/photo-1611162617474-5b21e879e113?w=800"),
  logoUrl: lib.z.string().default(""),
  title: lib.z.string().default("Creator spotlight"),
  subtitle: lib.z.string().default("@username"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accent),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const PhoneCameo01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const phoneSpring = (0,esm.spring)({
    frame,
    fps,
    config: { damping: 14, stiffness: 100, mass: 1 }
  });
  const phoneScale = (0,esm.interpolate)(phoneSpring, [0, 1], [0.85, 1]);
  const shadowOpacity = (0,esm.interpolate)(frame, [0, 18], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const logoSpring = (0,esm.spring)({
    frame: frame - 18,
    fps,
    config: { damping: 12, stiffness: 120, mass: 0.8 }
  });
  const logoY = (0,esm.interpolate)(logoSpring, [0, 1], [60 * s, 0]);
  const underlineWidth = (0,esm.interpolate)(frame, [48, 70], [0, 100], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const clipZoom = (0,esm.interpolate)(frame, [70, 260], [1, 1.03], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const flashOpacity = (0,esm.interpolate)(frame, [260, 275, 290, 315], [0, 0.8, 0.3, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const exitScale = (0,esm.interpolate)(frame, [260, 315], [1, 0.9], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const phoneSize = isPortrait ? { width: 400 * s, height: 720 * s } : { width: 480 * s, height: 860 * s };
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: isPortrait ? "center" : "flex-start",
              alignItems: "center",
              padding: isPortrait ? `${136 * s}px 0` : `0 ${112 * s}px`,
              transform: `scale(${phoneScale * exitScale})`
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "div",
              {
                style: {
                  position: "relative",
                  width: phoneSize.width,
                  height: phoneSize.height,
                  borderRadius: 48 * s,
                  overflow: "hidden",
                  boxShadow: `0 ${30 * s}px ${80 * s}px rgba(0,0,0,${shadowOpacity * 0.45})`,
                  border: `${4 * s}px solid ${COLORS.surface}`
                },
                children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { transform: `scale(${clipZoom})`, width: "100%", height: "100%" }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  esm.Img,
                  {
                    src: props.phoneVideoUrl,
                    style: {
                      width: "100%",
                      height: "100%",
                      objectFit: "cover"
                    }
                  }
                ) })
              }
            )
          }
        ),
        props.logoUrl && frame >= 18 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: (isPortrait ? 160 : 80) * s,
              left: (isPortrait ? 60 : 80) * s,
              transform: `translateY(${logoY}px)`,
              opacity: logoSpring
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              esm.Img,
              {
                src: props.logoUrl,
                style: {
                  width: (isPortrait ? 80 : 100) * s,
                  height: (isPortrait ? 80 : 100) * s,
                  objectFit: "contain"
                }
              }
            )
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              flexDirection: "column",
              justifyContent: isPortrait ? "flex-end" : "center",
              alignItems: isPortrait ? "center" : "flex-end",
              padding: isPortrait ? `0 ${60 * s}px ${300 * s}px` : `0 ${120 * s}px 0 0`
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { position: "relative" }, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.title,
                    fontSize: (isPortrait ? 56 : 72) * s,
                    fontFamily: interFont,
                    color: COLORS.textPrimary,
                    fontWeight: 800
                  }
                ),
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "svg",
                  {
                    width: "100%",
                    height: 16 * s,
                    viewBox: "0 0 200 16",
                    preserveAspectRatio: "none",
                    style: {
                      position: "absolute",
                      bottom: -8 * s,
                      left: 0
                    },
                    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "path",
                      {
                        d: "M 0 8 Q 50 2, 100 8 T 200 8",
                        fill: "none",
                        stroke: props.primaryColor,
                        strokeWidth: 4 * s,
                        strokeLinecap: "round",
                        strokeDasharray: "200",
                        strokeDashoffset: 200 - underlineWidth * 2
                      }
                    )
                  }
                )
              ] }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { marginTop: 16 * s, opacity: fadeIn(frame - 55, 15) }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subtitle,
                  fontSize: (isPortrait ? 32 : 40) * s,
                  fontFamily: interFont,
                  color: props.primaryColor,
                  fontWeight: 600
                }
              ) })
            ]
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `linear-gradient(135deg, ${props.primaryColor}, #ffffff)`,
              opacity: flashOpacity,
              mixBlendMode: "screen"
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "phone-cameo-01",
  name: "Phone Cameo with Logo Bug",
  category: "social-hooks",
  description: "Rounded phone frame with creator clip, logo bug, and scribble title underline.",
  tags: ["phone", "cameo", "creator", "frame", "logo", "clip"],
  component: PhoneCameo01,
  schema: phoneCameoSchema,
  defaultProps: phoneCameoSchema.parse({}),
  durationInFrames: 315,
  // 10.5s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/ProofTiles01.tsx











const proofTilesSchema = lib.z.object({
  presenterImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=800"),
  tile1Url: lib.z.string().default("https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=600"),
  tile1Tag: lib.z.string().default("Revenue +240%"),
  tile2Url: lib.z.string().default("https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=600"),
  tile2Tag: lib.z.string().default("Users 10M+"),
  tile3Url: lib.z.string().default("https://images.unsplash.com/photo-1553877522-43269d4ea984?w=600"),
  tile3Tag: lib.z.string().default("5-Star Rating"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accent),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const ProofTiles01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  void shouldRenderBackgroundLayer(backgroundControls);
  const tiles = [
    { url: props.tile1Url, tag: props.tile1Tag, delay: 20 },
    { url: props.tile2Url, tag: props.tile2Tag, delay: 44 },
    { url: props.tile3Url, tag: props.tile3Tag, delay: 68 }
  ];
  const tileTilts = [-8, 5, -6];
  const tileOffsets = isPortrait ? [{ x: -100 * s, y: -180 * s }, { x: 80 * s, y: 0 }, { x: -60 * s, y: 180 * s }] : [{ x: -250 * s, y: -80 * s }, { x: 0, y: 40 * s }, { x: 250 * s, y: -60 * s }];
  const presenterSpring = (0,esm.spring)({
    frame,
    fps,
    config: { damping: 14, stiffness: 120, mass: 1 }
  });
  const getTagBounce = (tileIndex) => {
    const interval = 60;
    const offset = tileIndex * 20;
    const cycleFrame = (frame - 90 - offset) % interval;
    if (frame < 90 || cycleFrame < 0 || cycleFrame > 15) return 1;
    return 1 + Math.sin(cycleFrame * Math.PI / 15) * 0.1;
  };
  const getExitTransform = (tileIndex) => {
    const exitStart = 300 + tileIndex * 15;
    const rotation = (0,esm.interpolate)(frame, [exitStart, exitStart + 60], [0, tileTilts[tileIndex] * 3], {
      extrapolateLeft: "clamp",
      extrapolateRight: "clamp",
      easing: esm.Easing.in(esm.Easing.cubic)
    });
    const scale = (0,esm.interpolate)(frame, [exitStart, exitStart + 60], [1, 0.3], {
      extrapolateLeft: "clamp",
      extrapolateRight: "clamp"
    });
    const opacity = (0,esm.interpolate)(frame, [exitStart + 30, exitStart + 60], [1, 0], {
      extrapolateLeft: "clamp",
      extrapolateRight: "clamp"
    });
    return { rotation, scale, opacity };
  };
  const tileSize = isPortrait ? { w: 220 * s, h: 280 * s } : { w: 280 * s, h: 360 * s };
  const presenterHeight = (isPortrait ? 600 : 500) * s;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: "center"
            },
            children: tiles.map((tile, i) => {
              const tileSpring = (0,esm.spring)({
                frame: frame - tile.delay,
                fps,
                config: { damping: 12, stiffness: 100, mass: 0.8 }
              });
              const tileScale = (0,esm.interpolate)(tileSpring, [0, 1], [0.6, 1]);
              const tileRotation = (0,esm.interpolate)(tileSpring, [0, 1], [tileTilts[i] * 2, tileTilts[i]]);
              const exit = getExitTransform(i);
              const tagBounce = getTagBounce(i);
              return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    position: "absolute",
                    transform: `
                                    translate(${tileOffsets[i].x}px, ${tileOffsets[i].y}px)
                                    rotate(${tileRotation + exit.rotation}deg)
                                    scale(${tileScale * exit.scale})
                                `,
                    opacity: tileSpring * exit.opacity
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      esm.Img,
                      {
                        src: tile.url,
                        style: {
                          width: tileSize.w,
                          height: tileSize.h,
                          objectFit: "cover",
                          borderRadius: 20 * s,
                          boxShadow: `0 ${30 * s}px ${100 * s}px rgba(0,0,0,0.5)`,
                          border: `${3 * s}px solid ${COLORS.surface}`
                        }
                      }
                    ),
                    frame >= tile.delay + 50 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          position: "absolute",
                          bottom: (isPortrait ? -16 : -16) * s,
                          left: "50%",
                          transform: `translateX(-50%) scale(${tagBounce})`,
                          padding: `${8 * s}px ${20 * s}px`,
                          background: props.primaryColor,
                          borderRadius: 100,
                          boxShadow: `0 ${4 * s}px ${16 * s}px ${props.primaryColor}66`
                        },
                        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: tile.tag,
                            fontSize: (isPortrait ? 26 : 32) * s,
                            fontFamily: interFont,
                            color: "#FFFFFF",
                            fontWeight: 700
                          }
                        )
                      }
                    )
                  ]
                },
                i
              );
            })
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: "flex-end",
              transform: `scale(${presenterSpring})`
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              esm.Img,
              {
                src: props.presenterImageUrl,
                style: {
                  height: presenterHeight,
                  width: "auto",
                  objectFit: "contain",
                  filter: `drop-shadow(0 ${30 * s}px ${100 * s}px rgba(0,0,0,0.5))`
                }
              }
            )
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "proof-tiles-01",
  name: "Presenter + 3 Proof Tiles",
  category: "social-hooks",
  description: "Mid-video proof montage with 3 tiles slamming in around presenter with bouncing keyword tags.",
  tags: ["proof", "tiles", "presenter", "montage", "tags", "carousel"],
  component: ProofTiles01,
  schema: proofTilesSchema,
  defaultProps: proofTilesSchema.parse({}),
  durationInFrames: 420,
  // 14s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/SplitCompare01.tsx











const splitCompareSchema = lib.z.object({
  leftImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=1920"),
  rightImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1553877522-43269d4ea984?w=1920"),
  leftLabel: lib.z.string().default("BEFORE"),
  rightLabel: lib.z.string().default("AFTER"),
  leftColor: lib.z.string().default("#FF4444"),
  rightColor: lib.z.string().default("#00E676"),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const SplitCompare01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const initialBlur = (0,esm.interpolate)(frame, [0, 24], [8, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const dividerPosition = (0,esm.interpolate)(frame, [24, 60], [isPortrait ? 0 : 0, 50], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.inOut(esm.Easing.cubic)
  });
  const labelOpacity = (0,esm.interpolate)(frame, [50, 70], [0, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const labelScale = (0,esm.interpolate)(frame, [50, 65, 70], [0.8, 1.1, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const getBounce = (bounceFrame) => {
    const elapsed = frame - bounceFrame;
    if (elapsed < 0 || elapsed > 20) return 1;
    return 1 + Math.sin(elapsed * Math.PI / 20) * 0.1;
  };
  const bounce1 = getBounce(120);
  const bounce2 = getBounce(180);
  const currentBounce = bounce1 * bounce2;
  const flashOpacity = (0,esm.interpolate)(frame, [240, 255, 270, 300], [0, 0.9, 0.4, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const splitDirection = isPortrait ? "vertical" : "horizontal";
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              width: splitDirection === "horizontal" ? `${dividerPosition}%` : "100%",
              height: splitDirection === "horizontal" ? "100%" : `${dividerPosition}%`,
              overflow: "hidden"
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                esm.Img,
                {
                  src: props.leftImageUrl,
                  style: {
                    width: splitDirection === "horizontal" ? `${100 / (dividerPosition / 100)}%` : "100%",
                    height: splitDirection === "horizontal" ? "100%" : `${100 / (dividerPosition / 100)}%`,
                    objectFit: "cover",
                    filter: `blur(${initialBlur}px) brightness(0.8)`
                  }
                }
              ),
              frame >= 50 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    position: "absolute",
                    top: splitDirection === "horizontal" ? "50%" : "30%",
                    left: "50%",
                    transform: `translate(-50%, -50%) scale(${labelScale * currentBounce})`,
                    opacity: labelOpacity
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        background: props.leftColor,
                        padding: isPortrait ? `${16 * s}px ${40 * s}px` : `${20 * s}px ${48 * s}px`,
                        borderRadius: 12 * s,
                        boxShadow: `0 ${8 * s}px ${32 * s}px ${props.leftColor}66`
                      },
                      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                        EditableText,
                        {
                          text: props.leftLabel,
                          fontSize: (isPortrait ? 44 : 96) * s,
                          fontFamily: interFont,
                          color: "#FFFFFF",
                          fontWeight: 900
                        }
                      )
                    }
                  )
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "absolute",
              top: splitDirection === "horizontal" ? 0 : `${dividerPosition}%`,
              left: splitDirection === "horizontal" ? `${dividerPosition}%` : 0,
              width: splitDirection === "horizontal" ? `${100 - dividerPosition}%` : "100%",
              height: splitDirection === "horizontal" ? "100%" : `${100 - dividerPosition}%`,
              overflow: "hidden"
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                esm.Img,
                {
                  src: props.rightImageUrl,
                  style: {
                    width: splitDirection === "horizontal" ? `${100 / ((100 - dividerPosition) / 100)}%` : "100%",
                    height: splitDirection === "horizontal" ? "100%" : `${100 / ((100 - dividerPosition) / 100)}%`,
                    objectFit: "cover",
                    objectPosition: splitDirection === "horizontal" ? "right center" : "center bottom",
                    marginLeft: splitDirection === "horizontal" ? "auto" : 0,
                    filter: `blur(${initialBlur}px) brightness(0.8)`
                  }
                }
              ),
              frame >= 50 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    position: "absolute",
                    top: splitDirection === "horizontal" ? "50%" : "70%",
                    left: "50%",
                    transform: `translate(-50%, -50%) scale(${labelScale * currentBounce})`,
                    opacity: labelOpacity
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        background: props.rightColor,
                        padding: isPortrait ? `${16 * s}px ${40 * s}px` : `${20 * s}px ${48 * s}px`,
                        borderRadius: 12 * s,
                        boxShadow: `0 ${8 * s}px ${32 * s}px ${props.rightColor}66`
                      },
                      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                        EditableText,
                        {
                          text: props.rightLabel,
                          fontSize: (isPortrait ? 44 : 96) * s,
                          fontFamily: interFont,
                          color: "#FFFFFF",
                          fontWeight: 900
                        }
                      )
                    }
                  )
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: splitDirection === "horizontal" ? 0 : `${dividerPosition}%`,
              left: splitDirection === "horizontal" ? `${dividerPosition}%` : 0,
              width: splitDirection === "horizontal" ? 6 * s : "100%",
              height: splitDirection === "horizontal" ? "100%" : 6 * s,
              background: "#FFFFFF",
              boxShadow: `0 0 ${20 * s}px rgba(0,0,0,0.5)`,
              transform: splitDirection === "horizontal" ? "translateX(-50%)" : "translateY(-50%)"
            }
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: "#FFFFFF",
              opacity: flashOpacity
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "split-compare-01",
  name: "Before/After Split Compare",
  category: "social-hooks",
  description: "Split screen comparison with sliding divider for before/after, budget/profit, myth/reality contrasts.",
  tags: ["split", "compare", "before-after", "contrast", "divider"],
  component: SplitCompare01,
  schema: splitCompareSchema,
  defaultProps: splitCompareSchema.parse({}),
  durationInFrames: 300,
  // 10s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/StampVerdict01.tsx












const stampVerdictSchema = lib.z.object({
  backgroundImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1557804506-669a67965ba0?w=1920"),
  subtitleLine: lib.z.string().default("Is this actually legal?"),
  stampText: lib.z.string().default("NOT LEGAL"),
  followupLine: lib.z.string().default("Here's why it matters"),
  stampColor: lib.z.string().default("#FF4444"),
  stampRotation: lib.z.number().default(-6),
  backgroundColor: lib.z.string().default(COLORS.bg),
  showDistress: lib.z.boolean().default(true)
});
const StampVerdict01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const subtitleOpacity = fadeIn(frame, 40);
  const subtitleY = (0,esm.interpolate)(frame, [0, 40], [30 * s, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.out(esm.Easing.cubic)
  });
  const stampSpring = (0,esm.spring)({
    frame: frame - 40,
    fps,
    config: { damping: 8, stiffness: 200, mass: 0.6 }
  });
  const stampScale = (0,esm.interpolate)(stampSpring, [0, 1], [1.6, 1]);
  const stampRotation = (0,esm.interpolate)(stampSpring, [0, 1], [-12, props.stampRotation]);
  const pulseScale = frame >= 120 && frame < 135 ? 1 + Math.sin((frame - 120) * Math.PI / 15) * 0.08 : 1;
  const stampExitX = (0,esm.interpolate)(frame, [200, 260], [0, isPortrait ? 0 : -300 * s], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.in(esm.Easing.cubic)
  });
  const stampExitY = (0,esm.interpolate)(frame, [200, 260], [0, isPortrait ? -200 * s : 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.in(esm.Easing.cubic)
  });
  const stampExitOpacity = (0,esm.interpolate)(frame, [200, 260], [1, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const followupOpacity = fadeIn(frame - 220, 30);
  const followupY = (0,esm.interpolate)(frame, [220, 260], [40 * s, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.out(esm.Easing.cubic)
  });
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Img,
          {
            src: props.backgroundImageUrl,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              filter: "brightness(0.5)"
            }
          }
        ) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: isPortrait ? "flex-start" : "flex-end",
              padding: isPortrait ? `${136 * s}px ${56 * s}px` : `0 ${100 * s}px ${136 * s}px`,
              opacity: subtitleOpacity,
              transform: `translateY(${subtitleY}px)`
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              EditableText,
              {
                text: props.subtitleLine,
                fontSize: (isPortrait ? 48 : 56) * s,
                fontFamily: interFont,
                color: COLORS.textSecondary,
                fontWeight: 600,
                textAlign: "center"
              }
            )
          }
        ),
        frame >= 40 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: "center"
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsxs)(
              "div",
              {
                style: {
                  transform: `
                                rotate(${stampRotation}deg)
                                scale(${stampScale * pulseScale})
                                translate(${stampExitX}px, ${stampExitY}px)
                            `,
                  opacity: stampExitOpacity,
                  position: "relative"
                },
                children: [
                  /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        border: `${8 * s}px solid ${props.stampColor}`,
                        borderRadius: 16 * s,
                        padding: isPortrait ? `${24 * s}px ${48 * s}px` : `${32 * s}px ${64 * s}px`,
                        background: "transparent"
                      },
                      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                        EditableText,
                        {
                          text: props.stampText,
                          fontSize: (isPortrait ? 72 : 96) * s,
                          fontFamily: interFont,
                          color: props.stampColor,
                          fontWeight: 900,
                          letterSpacing: 8 * s
                        }
                      )
                    }
                  ),
                  props.showDistress && /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        position: "absolute",
                        inset: 0,
                        background: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.5' numOctaves='3' /%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E")`,
                        opacity: 0.2,
                        mixBlendMode: "multiply",
                        borderRadius: 16
                      }
                    }
                  )
                ]
              }
            )
          }
        ),
        frame >= 220 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: isPortrait ? "flex-end" : "center",
              padding: isPortrait ? `0 ${56 * s}px ${136 * s}px` : `0 ${100 * s}px`,
              opacity: followupOpacity,
              transform: `translateY(${followupY}px)`
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              EditableText,
              {
                text: props.followupLine,
                fontSize: (isPortrait ? 56 : 72) * s,
                fontFamily: interFont,
                color: COLORS.textPrimary,
                fontWeight: 800,
                textAlign: "center"
              }
            )
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "stamp-verdict-01",
  name: "Stamp Verdict Explainer",
  category: "social-hooks",
  description: "Bold verdict stamp (LEGAL/NOT LEGAL/SMART/DUMB) slams over footage for punchy editorial moments.",
  tags: ["stamp", "verdict", "legal", "editorial", "meme", "bold"],
  component: StampVerdict01,
  schema: stampVerdictSchema,
  defaultProps: stampVerdictSchema.parse({}),
  durationInFrames: 345,
  // 11.5s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/TimelineSteps01.tsx













const timelineStepsSchema = lib.z.object({
  title: lib.z.string().default("How it works"),
  step1Title: lib.z.string().default("Step 1"),
  step1Desc: lib.z.string().default("Initial setup"),
  step2Title: lib.z.string().default("Step 2"),
  step2Desc: lib.z.string().default("Configure settings"),
  step3Title: lib.z.string().default("Step 3"),
  step3Desc: lib.z.string().default("Launch & scale"),
  step4Title: lib.z.string().default("Step 4"),
  step4Desc: lib.z.string().default("See results"),
  recapText: lib.z.string().default("Simple as that!"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accent),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const TimelineSteps01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  void shouldRenderBackgroundLayer(backgroundControls);
  const steps = [
    { title: props.step1Title, desc: props.step1Desc, delay: 30 },
    { title: props.step2Title, desc: props.step2Desc, delay: 105 },
    { title: props.step3Title, desc: props.step3Desc, delay: 180 },
    { title: props.step4Title, desc: props.step4Desc, delay: 255 }
  ];
  const titleOpacity = fadeIn(frame, 30);
  const titleY = (0,esm.interpolate)(frame, [0, 30], [30 * s, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const recapX = (0,esm.interpolate)(frame, [330, 380], [isPortrait ? 0 : -300 * s, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const recapOpacity = fadeIn(frame - 330, 30);
  const stepSize = (isPortrait ? 80 : 100) * s;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: (isPortrait ? 120 : 80) * s,
              left: 0,
              right: 0,
              display: "flex",
              justifyContent: "center",
              opacity: titleOpacity,
              transform: `translateY(${titleY}px)`
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              EditableText,
              {
                text: props.title,
                fontSize: (isPortrait ? 72 : 88) * s,
                fontFamily: interFont,
                color: COLORS.textPrimary,
                fontWeight: 800
              }
            )
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              flexDirection: isPortrait ? "column" : "row",
              justifyContent: "center",
              alignItems: "center",
              gap: (isPortrait ? 40 : 60) * s,
              padding: isPortrait ? `${156 * s}px ${56 * s}px` : `0 ${80 * s}px`
            },
            children: steps.map((step, i) => {
              const stepSpring = (0,esm.spring)({
                frame: frame - step.delay,
                fps,
                config: { damping: 12, stiffness: 120, mass: 0.8 }
              });
              const stepScale = (0,esm.interpolate)(stepSpring, [0, 1], [0.6, 1]);
              const lineProgress = (0,esm.interpolate)(frame, [step.delay + 20, step.delay + 50], [0, 1], {
                extrapolateLeft: "clamp",
                extrapolateRight: "clamp"
              });
              return /* @__PURE__ */ (0,jsx_runtime.jsxs)(react.Fragment, { children: [
                /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                  "div",
                  {
                    style: {
                      display: "flex",
                      flexDirection: "column",
                      alignItems: "center",
                      gap: 16 * s,
                      transform: `scale(${stepScale})`,
                      opacity: stepSpring
                    },
                    children: [
                      /* @__PURE__ */ (0,jsx_runtime.jsx)(
                        "div",
                        {
                          style: {
                            width: stepSize,
                            height: stepSize,
                            borderRadius: "50%",
                            background: `linear-gradient(135deg, ${props.primaryColor}, ${props.accentColor})`,
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            boxShadow: `0 ${8 * s}px ${32 * s}px ${props.primaryColor}44`
                          },
                          children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: `${i + 1}`,
                              fontSize: (isPortrait ? 40 : 48) * s,
                              fontFamily: interFont,
                              color: "#FFFFFF",
                              fontWeight: 900
                            }
                          )
                        }
                      ),
                      /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { textAlign: "center" }, children: [
                        /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: step.title,
                            fontSize: (isPortrait ? 32 : 36) * s,
                            fontFamily: interFont,
                            color: props.primaryColor,
                            fontWeight: 700
                          }
                        ),
                        /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: step.desc,
                            fontSize: (isPortrait ? 24 : 28) * s,
                            fontFamily: interFont,
                            color: COLORS.textSecondary,
                            fontWeight: 500,
                            style: { marginTop: 8 * s }
                          }
                        )
                      ] })
                    ]
                  }
                ),
                i < steps.length - 1 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "div",
                  {
                    style: {
                      width: (isPortrait ? 4 : 60) * s,
                      height: (isPortrait ? 30 : 4) * s,
                      background: `${props.primaryColor}40`,
                      borderRadius: 2 * s,
                      overflow: "hidden"
                    },
                    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          width: isPortrait ? "100%" : `${lineProgress * 100}%`,
                          height: isPortrait ? `${lineProgress * 100}%` : "100%",
                          background: props.primaryColor
                        }
                      }
                    )
                  }
                )
              ] }, i);
            })
          }
        ),
        frame >= 330 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: "flex-end",
              padding: isPortrait ? `0 ${60 * s}px ${120 * s}px` : `0 ${100 * s}px ${80 * s}px`,
              opacity: recapOpacity,
              transform: `translateX(${recapX}px)`
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "div",
              {
                style: {
                  background: `linear-gradient(135deg, ${props.primaryColor}, ${props.accentColor})`,
                  padding: isPortrait ? `${20 * s}px ${48 * s}px` : `${24 * s}px ${56 * s}px`,
                  borderRadius: 100 * s,
                  boxShadow: `0 ${8 * s}px ${32 * s}px ${props.primaryColor}44`
                },
                children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.recapText,
                    fontSize: (isPortrait ? 36 : 44) * s,
                    fontFamily: interFont,
                    color: "#FFFFFF",
                    fontWeight: 700
                  }
                )
              }
            )
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "timeline-steps-01",
  name: "Timeline Steps with Numbers",
  category: "social-hooks",
  description: "Explain a process in 4 animated steps with numbered badges and connector lines.",
  tags: ["timeline", "steps", "process", "flow", "numbers", "explainer"],
  component: TimelineSteps01,
  schema: timelineStepsSchema,
  defaultProps: timelineStepsSchema.parse({}),
  durationInFrames: 450,
  // 15s @ 30fps
  fps: 30
});

;// ./src/templates/social-hooks/ZoomReveal01.tsx












const zoomRevealSchema = lib.z.object({
  backgroundImageUrl: lib.z.string().default("https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=1920"),
  caption1: lib.z.string().default("This changed everything"),
  caption2: lib.z.string().default("Here's the PROOF"),
  highlightWord: lib.z.string().default("PROOF"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accent),
  backgroundColor: lib.z.string().default(COLORS.bg),
  showVignette: lib.z.boolean().default(true)
});
const ZoomReveal01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const s = useScaleFactor();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const zoomScale = (0,esm.interpolate)(frame, [0, 16, 52], [1.55, 1.55, 1], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.out(esm.Easing.cubic)
  });
  const panX = (0,esm.interpolate)(frame, [0, 16, 52], [80 * s, 80 * s, 0], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp",
    easing: esm.Easing.out(esm.Easing.cubic)
  });
  const caption1Spring = (0,esm.spring)({
    frame: frame - 52,
    fps,
    config: { damping: 14, stiffness: 120, mass: 0.8 }
  });
  const caption1Y = (0,esm.interpolate)(caption1Spring, [0, 1], [60 * s, 0]);
  const highlightWidth = (0,esm.interpolate)(frame, [84, 115], [0, 100], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const driftX = (0,esm.interpolate)(frame, [115, 260], [0, 15 * s], {
    extrapolateLeft: "clamp",
    extrapolateRight: "clamp"
  });
  const caption2Spring = (0,esm.spring)({
    frame: frame - 260,
    fps,
    config: { damping: 12, stiffness: 180, mass: 0.6 }
  });
  const caption2Scale = (0,esm.interpolate)(caption2Spring, [0, 1], [1.3, 1]);
  const stampScale = (0,esm.spring)({
    frame: frame - 280,
    fps,
    config: { damping: 10, stiffness: 200, mass: 0.5 }
  });
  const outroOpacity = fadeIn(frame - 300, 20);
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              transform: `scale(${zoomScale}) translateX(${panX + driftX}px)`
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              esm.Img,
              {
                src: props.backgroundImageUrl,
                style: {
                  width: "100%",
                  height: "100%",
                  objectFit: "cover",
                  filter: "brightness(0.6) contrast(1.1) saturate(1.1)"
                }
              }
            )
          }
        ),
        renderBackgroundLayers && props.showVignette && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: "radial-gradient(ellipse at center, transparent 30%, rgba(0,0,0,0.6) 100%)"
            }
          }
        ),
        frame >= 52 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: isPortrait ? "center" : "flex-start",
              alignItems: "flex-end",
              padding: isPortrait ? "0 60px 500px" : "0 100px 200px"
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsxs)(
              "div",
              {
                style: {
                  transform: `translateY(${caption1Y}px)`,
                  position: "relative"
                },
                children: [
                  /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        position: "absolute",
                        left: -12 * s,
                        right: -12 * s,
                        top: "50%",
                        height: "60%",
                        transform: "translateY(-50%)",
                        background: `${props.primaryColor}40`,
                        width: `${highlightWidth}%`,
                        borderRadius: 8 * s
                      }
                    }
                  ),
                  /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.caption1,
                      fontSize: (isPortrait ? 56 : 72) * s,
                      fontFamily: interFont,
                      color: COLORS.textPrimary,
                      fontWeight: 800,
                      style: { position: "relative", zIndex: 1 }
                    }
                  )
                ]
              }
            )
          }
        ),
        frame >= 260 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              flexDirection: "column",
              justifyContent: "center",
              alignItems: "center",
              padding: isPortrait ? "0 60px" : "0 100px"
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
              "div",
              {
                style: {
                  transform: `scale(${caption2Scale})`,
                  display: "flex",
                  flexWrap: "wrap",
                  justifyContent: "center",
                  gap: 16 * s
                },
                children: props.caption2.split(" ").map((word, i) => {
                  const isHighlight = word.toUpperCase() === props.highlightWord.toUpperCase();
                  return /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "span",
                    {
                      style: {
                        display: "inline-block",
                        transform: isHighlight ? `scale(${(0,esm.interpolate)(stampScale, [0, 1], [1.4, 1])}) rotate(-3deg)` : void 0,
                        background: isHighlight ? props.primaryColor : "transparent",
                        padding: isHighlight ? `${8 * s}px ${20 * s}px` : 0,
                        borderRadius: isHighlight ? 8 * s : 0
                      },
                      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                        EditableText,
                        {
                          text: word,
                          fontSize: (isPortrait ? 64 : 84) * s,
                          fontFamily: interFont,
                          color: isHighlight ? "#FFFFFF" : COLORS.textPrimary,
                          fontWeight: 900
                        }
                      )
                    },
                    i
                  );
                })
              }
            )
          }
        ),
        frame >= 300 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              justifyContent: "center",
              alignItems: "flex-end",
              paddingBottom: isPortrait ? 112 : 80,
              opacity: outroOpacity
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsxs)(
              "div",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: 12 * s,
                  background: `${props.accentColor}20`,
                  border: `${2 * s}px solid ${props.accentColor}`,
                  padding: `${12 * s}px ${28 * s}px`,
                  borderRadius: 100 * s
                },
                children: [
                  /* @__PURE__ */ (0,jsx_runtime.jsx)("span", { style: { fontSize: 28 * s }, children: "\u{1F4A1}" }),
                  /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: "So what does this mean?",
                      fontSize: (isPortrait ? 28 : 32) * s,
                      fontFamily: interFont,
                      color: props.accentColor,
                      fontWeight: 600
                    }
                  )
                ]
              }
            )
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "zoom-reveal-01",
  name: "Zoom-Out B-roll Reveal",
  category: "social-hooks",
  description: "Dramatic zoom-out reveal with caption punches and highlight sweeps.",
  tags: ["zoom", "reveal", "caption", "highlight", "b-roll", "dramatic"],
  component: ZoomReveal01,
  schema: zoomRevealSchema,
  defaultProps: zoomRevealSchema.parse({}),
  durationInFrames: 375,
  // 12.5s @ 30fps
  fps: 30
});

;// ./src/templates/social-media-promo/SocialPromo01.tsx














const socialPromoSchema = lib.z.object({
  headline: lib.z.string().default("Flash Sale"),
  highlight: lib.z.string().default("50% OFF"),
  description: lib.z.string().default("Everything in our premium collection for a limited time only"),
  ctaText: lib.z.string().default("SHOP NOW \u2192"),
  imageUrl: lib.z.string().default("https://images.unsplash.com/photo-1441986300917-64674bd600d8?w=800"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const SocialPromo01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const highlightScale = (0,esm.spring)({
    frame: frame - 20,
    fps,
    config: { damping: 6, stiffness: 150, mass: 0.5 }
  });
  const ctaSpring = (0,esm.spring)({
    frame: frame - 70,
    fps,
    config: { damping: 10, stiffness: 120, mass: 0.4 }
  });
  const pulse = (0,esm.interpolate)(Math.sin(frame * 0.08), [-1, 1], [0.95, 1.05]);
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              opacity: fadeIn(frame, 0, 20) * 0.2
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedImage, { src: props.imageUrl })
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                top: 0,
                left: 0,
                right: 0,
                bottom: 0,
                background: linearGradient(180, `${props.backgroundColor}99`, `${props.backgroundColor}dd`, props.backgroundColor)
              }
            }
          ),
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                bottom: 0,
                left: 0,
                right: 0,
                height: "50%",
                background: linearGradient(0, "transparent", `${props.primaryColor}08`)
              }
            }
          )
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              justifyContent: "center",
              width: "100%",
              height: "100%",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 32 : 48,
              textAlign: "center"
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 72 : 88,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 600,
                  textTransform: "uppercase",
                  letterSpacing: 6,
                  textAlign: "center",
                  style: {
                    opacity: fadeIn(frame, 5),
                    transform: slideIn(frame, "down", 5, 20)
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    transform: `scale(${highlightScale * pulse})`
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        fontSize: isPortrait ? 72 : 110,
                        fontFamily: interFont,
                        fontWeight: 900,
                        letterSpacing: -3,
                        textAlign: "center",
                        backgroundImage: linearGradient(135, props.primaryColor, props.accentColor),
                        WebkitBackgroundClip: "text",
                        WebkitTextFillColor: "transparent",
                        backgroundClip: "text",
                        filter: `drop-shadow(0 0 30px ${props.primaryColor}44)`
                      },
                      children: props.highlight
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.description,
                  fontSize: isPortrait ? 52 : 64,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  textAlign: "center",
                  lineHeight: 1.5,
                  maxLines: 2,
                  style: {
                    opacity: fadeIn(frame, 40),
                    maxWidth: isPortrait ? 1100 : 1500
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    marginTop: 32 * scale,
                    padding: `${14 * scale}px ${40 * scale}px`,
                    borderRadius: 20 * scale,
                    background: GRADIENTS.bgMain,
                    transform: `scale(${ctaSpring})`,
                    boxShadow: `0 0 40px ${props.primaryColor}33`
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.ctaText,
                      fontSize: 40 * scale,
                      fontFamily: interFont,
                      color: COLORS.textPrimary,
                      fontWeight: 800,
                      letterSpacing: 3
                    }
                  )
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6 * scale,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "social-promo-01",
  name: "Flash Sale Promo",
  category: "social-media-promo",
  description: "Bold flash sale with pulsing gradient highlight, background image, and CTA button",
  tags: ["sale", "promo", "social", "discount", "flash-sale"],
  component: SocialPromo01,
  schema: socialPromoSchema,
  defaultProps: socialPromoSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/social-media-promo/SocialPromoEvent01.tsx














const socialPromoEventSchema = lib.z.object({
  badge: lib.z.string().default("LIVE EVENT"),
  headline: lib.z.string().default("Design Summit 2026"),
  subtitle: lib.z.string().default("The future of product design is here"),
  date: lib.z.string().default("March 15\u201317, 2026"),
  location: lib.z.string().default("San Francisco, CA"),
  ctaText: lib.z.string().default("GET TICKETS \u2192"),
  speakers: lib.z.string().default("50+ Speakers"),
  imageUrl: lib.z.string().default("https://images.unsplash.com/photo-1540575467063-178a50c2df87?w=800"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const SocialPromoEvent01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const ctaSpring = (0,esm.spring)({
    frame: frame - 65,
    fps,
    config: { damping: 10, stiffness: 120, mass: 0.4 }
  });
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              opacity: fadeIn(frame, 0, 25) * 0.25
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedImage, { src: props.imageUrl })
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: linearGradient(180, `${props.backgroundColor}88`, `${props.backgroundColor}ee`, props.backgroundColor)
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 28 : 40
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { opacity: fadeIn(frame, 0) }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "inline-flex",
                    padding: `${5 * scale}px ${14 * scale}px`,
                    borderRadius: 12 * scale,
                    background: `${props.primaryColor}25`,
                    border: `2px solid ${props.primaryColor}50`
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.badge,
                      fontSize: 32 * scale,
                      fontFamily: interFont,
                      color: COLORS.accent,
                      fontWeight: 800,
                      letterSpacing: 3
                    }
                  )
                }
              ) }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 92 : 128,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 900,
                  lineHeight: 1.05,
                  letterSpacing: -2,
                  maxLines: 3,
                  style: { opacity: fadeIn(frame, 8), transform: slideIn(frame, "up", 8, 25) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subtitle,
                  fontSize: isPortrait ? 44 : 52,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  lineHeight: 1.4,
                  maxLines: 2,
                  style: { opacity: fadeIn(frame, 20) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "flex",
                    flexWrap: "wrap",
                    gap: 20 * scale,
                    marginTop: 16 * scale,
                    opacity: fadeIn(frame, 35)
                  },
                  children: [props.date, props.location, props.speakers].map((info, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        padding: `${8 * scale}px ${16 * scale}px`,
                        borderRadius: 16 * scale,
                        background: "rgba(255,255,255,0.06)",
                        border: "2px solid rgba(255,255,255,0.08)"
                      },
                      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                        EditableText,
                        {
                          text: info,
                          fontSize: 32 * scale,
                          fontFamily: interFont,
                          color: COLORS.textSecondary,
                          fontWeight: 500
                        }
                      )
                    },
                    i
                  ))
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    marginTop: isPortrait ? 18 : 30,
                    alignSelf: isPortrait ? "stretch" : "flex-start",
                    padding: `${16 * scale}px ${40 * scale}px`,
                    borderRadius: 24 * scale,
                    background: GRADIENTS.bgMain,
                    transform: `scale(${ctaSpring})`,
                    boxShadow: `0 0 40px ${props.primaryColor}33`,
                    textAlign: "center"
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.ctaText,
                      fontSize: 40 * scale,
                      fontFamily: interFont,
                      color: COLORS.textPrimary,
                      fontWeight: 800,
                      letterSpacing: 2
                    }
                  )
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6 * scale,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "social-promo-event-01",
  name: "Event Promo",
  category: "social-media-promo",
  description: "Event promotion with background image, info pills, date/location, and CTA button",
  tags: ["event", "conference", "promo", "social", "tickets"],
  component: SocialPromoEvent01,
  schema: socialPromoEventSchema,
  defaultProps: socialPromoEventSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/startup-showcase/AppDemo01.tsx












const appDemoSchema = lib.z.object({
  title: lib.z.string().default("APP LAUNCH"),
  subtitle: lib.z.string().default("Available on all stores"),
  color1: lib.z.string().default("#FF9A9E"),
  color2: lib.z.string().default("#FECFEF"),
  color3: lib.z.string().default("#A18CD1"),
  showBubbles: lib.z.boolean().default(true),
  darkTheme: lib.z.boolean().default(false)
});
const AppDemo01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const t = frame * 0.02;
  const x1 = Math.sin(t) * 50 + 50;
  const y1 = Math.cos(t * 0.8) * 50 + 50;
  const x2 = Math.cos(t * 1.2) * 50 + 50;
  const y2 = Math.sin(t * 0.9) * 50 + 50;
  const bubbles = react.useMemo(() => new Array(10).fill(0).map((_, i) => ({
    size: (0,esm.random)(i) * 200 + 100,
    x: (0,esm.random)(i + 10) * 100,
    y: (0,esm.random)(i + 20) * 100,
    speed: (0,esm.random)(i + 30) * 0.2 + 0.1
  })), []);
  const textColor = props.darkTheme ? "#fff" : "#000";
  const glassBg = props.darkTheme ? "rgba(0,0,0,0.3)" : "rgba(255,255,255,0.3)";
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.color1, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          top: "-50%",
          left: "-50%",
          width: "200%",
          height: "200%",
          background: `
                    radial-gradient(circle at ${x1}% ${y1}%, ${props.color2}, transparent 50%),
                    radial-gradient(circle at ${x2}% ${y2}%, ${props.color3}, transparent 50%)
                `,
          filter: "blur(60px)",
          opacity: 0.8
        } }),
        renderBackgroundLayers && props.showBubbles && bubbles.map((b, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              left: `${b.x}%`,
              top: `${(b.y - frame * b.speed) % 120 - 20}%`,
              width: b.size,
              height: b.size,
              borderRadius: "50%",
              background: "linear-gradient(135deg, rgba(255,255,255,0.4), rgba(255,255,255,0.1))",
              border: "2px solid rgba(255,255,255,0.2)",
              backdropFilter: "blur(4px)",
              boxShadow: "0 8px 32px 0 rgba(31, 38, 135, 0.1)"
            }
          },
          i
        )),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          zIndex: 10,
          padding: isPortrait ? "140px 80px" : void 0
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          padding: isPortrait ? "40px 20px" : "60px 100px",
          background: glassBg,
          backdropFilter: "blur(16px)",
          borderRadius: 48,
          border: "2px solid rgba(255,255,255,0.3)",
          boxShadow: "0 8px 32px 0 rgba(0, 0, 0, 0.1)",
          transform: `scale(${(0,esm.spring)({ frame, fps, config: { damping: 12 } })})`,
          textAlign: "center",
          display: "flex",
          flexDirection: "column",
          gap: 32
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.title,
              fontSize: isPortrait ? 100 : 160,
              fontFamily: interFont,
              color: textColor,
              fontWeight: 800,
              letterSpacing: -2
            }
          ),
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.subtitle,
              fontSize: isPortrait ? 40 : 60,
              fontFamily: interFont,
              color: props.darkTheme ? "#ffffffcc" : "#00000099",
              fontWeight: 500
            }
          )
        ] }) })
      ]
    }
  );
};
registerTemplate({
  id: "app-demo-01",
  name: "Mobile App Demo",
  category: "startup-showcase",
  description: "Modern abstract gradient background perfect for app demos and software showcases.",
  tags: ["app", "mobile", "tech", "startup", "demo"],
  component: AppDemo01,
  schema: appDemoSchema,
  defaultProps: appDemoSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/startup-showcase/BoldPitch01.tsx












const boldPitchSchema = lib.z.object({
  word1: lib.z.string().default("PROBLEM"),
  word2: lib.z.string().default("SOLUTION"),
  word3: lib.z.string().default("MARKET"),
  word4: lib.z.string().default("TRACTION"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  textColor: lib.z.string().default(COLORS.textPrimary),
  showShapes: lib.z.boolean().default(true)
});
const BoldPitch01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const t1 = 0;
  const t2 = 20;
  const t3 = 40;
  const t4 = 60;
  const springConfig = { damping: 10, stiffness: 200, mass: 0.5 };
  const scale1 = (0,esm.spring)({ frame: frame - t1, fps, config: springConfig });
  const scale2 = (0,esm.spring)({ frame: frame - t2, fps, config: springConfig });
  const scale3 = (0,esm.spring)({ frame: frame - t3, fps, config: springConfig });
  const scale4 = (0,esm.spring)({ frame: frame - t4, fps, config: springConfig });
  const bgColor = frame < t2 ? props.primaryColor : frame < t3 ? props.accentColor : frame < t4 ? props.primaryColor : props.accentColor;
  const textColor = frame < t2 ? props.textColor : frame < t3 ? props.primaryColor : frame < t4 ? props.textColor : props.primaryColor;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(bgColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && props.showShapes && /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            position: "absolute",
            top: "-50%",
            left: "-50%",
            width: "200%",
            height: "200%",
            background: `repeating-linear-gradient(
                            45deg,
                            transparent,
                            transparent 40px,
                            #ffffff10 40px,
                            #ffffff10 80px
                        )`,
            transform: `rotate(${frame * 0.5}deg)`
          } }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            position: "absolute",
            right: -100,
            bottom: -100,
            width: 400,
            height: 400,
            borderRadius: "50%",
            border: "20px solid #ffffff10",
            transform: `scale(${(0,esm.interpolate)(frame, [0, 100], [0.8, 1.2])})`
          } })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: {
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        }, children: [
          frame >= t1 && frame < t2 && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { transform: `scale(${scale1}) rotate(${(0,esm.interpolate)(scale1, [0, 1], [-10, 0])}deg)` }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.word1,
              fontSize: isPortrait ? 92 : 172,
              fontFamily: interFont,
              color: textColor,
              fontWeight: 900
            }
          ) }),
          frame >= t2 && frame < t3 && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { transform: `scale(${scale2})` }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.word2,
              fontSize: isPortrait ? 92 : 172,
              fontFamily: interFont,
              color: textColor,
              fontWeight: 900,
              fontStyle: "italic"
            }
          ) }),
          frame >= t3 && frame < t4 && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { transform: `scale(${scale3}) rotate(${(0,esm.interpolate)(scale3, [0, 1], [10, 0])}deg)` }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.word3,
              fontSize: isPortrait ? 92 : 172,
              fontFamily: interFont,
              color: textColor,
              fontWeight: 900
            }
          ) }),
          frame >= t4 && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { transform: `scale(${scale4})` }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.word4,
              fontSize: isPortrait ? 110 : 180,
              fontFamily: interFont,
              color: textColor,
              fontWeight: 900,
              style: {
                textDecoration: "underline",
                textDecorationColor: props.primaryColor
              }
            }
          ) })
        ] })
      ]
    }
  );
};
registerTemplate({
  id: "bold-pitch-01",
  name: "Bold Elevator Pitch",
  category: "startup-showcase",
  description: "Fast-paced rhythmic text animation for elevator pitches and key value propositions.",
  tags: ["pitch", "startup", "investor", "bold", "text"],
  component: BoldPitch01,
  schema: boldPitchSchema,
  defaultProps: boldPitchSchema.parse({}),
  durationInFrames: 90,
  fps: DEFAULT_FPS
});

;// ./src/templates/startup-showcase/CompanyHistory01.tsx












const companyHistorySchema = lib.z.object({
  title: lib.z.string().default("ORIGIN STORY"),
  date: lib.z.string().default("EST 2015"),
  time: lib.z.string().default("DAY 01"),
  videoUrl: lib.z.string().default("https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4"),
  showTracking: lib.z.boolean().default(true),
  showDate: lib.z.boolean().default(true),
  showScanlines: lib.z.boolean().default(true),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const CompanyHistory01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const trackingY = props.showTracking ? ((0,esm.random)(Math.floor(frame / 5)) - 0.5) * 10 : 0;
  const bleedX = Math.sin(frame * 0.2) * 2;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { mixBlendMode: "screen", transform: `translate(${bleedX}px, ${trackingY}px)`, opacity: 0.8 }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Video,
          {
            src: props.videoUrl,
            style: { width: "100%", height: "100%", objectFit: "cover", filter: "sepia(0.4) contrast(1.2) hue-rotate(-10deg)" }
          }
        ) }),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { mixBlendMode: "screen", transform: `translate(${-bleedX}px, ${trackingY}px)`, opacity: 0.8 }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Video,
          {
            src: props.videoUrl,
            style: { width: "100%", height: "100%", objectFit: "cover", filter: "sepia(0.4) contrast(1.2) hue-rotate(10deg)" }
          }
        ) }),
        renderBackgroundLayers && props.showScanlines && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          background: `repeating-linear-gradient(
                        0deg,
                        transparent,
                        transparent 2px,
                        #000000 3px,
                        #000000 4px
                    )`,
          opacity: 0.2,
          pointerEvents: "none",
          zIndex: 10
        } }),
        renderBackgroundLayers && props.showTracking && frame % 120 < 10 && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          top: `${(0,esm.interpolate)(frame % 120, [0, 10], [10, 100])}%`,
          left: 0,
          width: "100%",
          height: 50 * scale,
          background: "rgba(255,255,255,0.2)",
          backdropFilter: "blur(4px) invert(0.8)",
          transform: "translateY(-50%)",
          zIndex: 20
        } }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: { zIndex: 30, padding: isPortrait ? 56 : 80, fontFamily: interFont }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { position: "absolute", top: isPortrait ? 56 : 80, left: isPortrait ? 56 : 80, display: "flex", alignItems: "center", gap: 24 * scale }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: isPortrait ? 52 : 64, color: "#fff", textShadow: "2px 2px 0px #000" }, children: "\u25B6 PLAY" }),
            frame % 60 < 30 && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: isPortrait ? 52 : 64, color: "#fff", textShadow: "2px 2px 0px #000" }, children: "SP" })
          ] }),
          props.showDate && /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { position: "absolute", bottom: isPortrait ? 56 : 80, right: isPortrait ? 56 : 80, textAlign: "right" }, children: [
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: isPortrait ? 52 : 64, color: "#fff", textShadow: "2px 2px 0px #000", marginBottom: 8 * scale }, children: props.date }),
            /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { fontSize: isPortrait ? 52 : 64, color: "#fff", textShadow: "2px 2px 0px #000" }, children: props.time })
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { display: "flex", justifyContent: "center", alignItems: "center" }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.title,
              fontSize: isPortrait ? 112 : 172,
              fontFamily: interFont,
              color: COLORS.textPrimary,
              style: {
                textShadow: "4px 4px 0px #0000ff",
                filter: "blur(0.5px)",
                opacity: (0,esm.interpolate)(frame, [0, 30], [0, 0.8])
              }
            }
          ) })
        ] }),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          background: "radial-gradient(circle, transparent 60%, black 100%)",
          opacity: 0.6,
          zIndex: 40,
          pointerEvents: "none"
        } })
      ]
    }
  );
};
registerTemplate({
  id: "company-history-01",
  name: "Company History Archive",
  category: "startup-showcase",
  description: "Nostalgic archive style for showcasing company history and milestones.",
  tags: ["history", "timeline", "archive", "startup", "journey"],
  component: CompanyHistory01,
  schema: companyHistorySchema,
  defaultProps: companyHistorySchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/startup-showcase/CreativeStory01.tsx












const creativeStorySchema = lib.z.object({
  title: lib.z.string().default("OUR STORY"),
  subtitle: lib.z.string().default("Crafted with passion"),
  imageUrl: lib.z.string().default("https://images.unsplash.com/photo-1493863641943-9b68992a8d07?w=1600"),
  paperColor: lib.z.string().default("#f4e4bc"),
  // Beige/Paper
  accentColor: lib.z.string().default(COLORS.accentLight),
  showTexture: lib.z.boolean().default(true),
  stopMotion: lib.z.boolean().default(true)
});
const CreativeStory01 = (props) => {
  const scale = useScaleFactor();
  const rawFrame = (0,esm.useCurrentFrame)();
  (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const frame = props.stopMotion ? Math.floor(rawFrame / 3) * 3 : rawFrame;
  const wiggleX = ((0,esm.random)(frame) - 0.5) * 4;
  const wiggleY = ((0,esm.random)(frame + 10) - 0.5) * 4;
  const rotate = ((0,esm.random)(frame + 20) - 0.5) * 2;
  const paperTexture = `
        repeating-linear-gradient(
            45deg,
            #00000005,
            #00000005 2px,
            transparent 2px,
            transparent 4px
        )
    `;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.paperColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        renderBackgroundLayers && props.showTexture && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          background: paperTexture,
          opacity: 0.5
        } }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          display: "flex",
          justifyContent: "center",
          alignItems: "center"
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          width: isPortrait ? "80%" : "60%",
          height: isPortrait ? "50%" : "70%",
          position: "relative",
          transform: `translate(${wiggleX}px, ${wiggleY}px) rotate(${rotate}deg)`,
          boxShadow: "10px 10px 20px rgba(0,0,0,0.2)",
          background: "#fff",
          padding: 20 * scale
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedImage, { src: props.imageUrl }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            position: "absolute",
            top: -15,
            left: "50%",
            transform: "translateX(-50%) rotate(-2deg)",
            width: 100 * scale,
            height: 30 * scale,
            background: "rgba(255,255,255,0.6)",
            boxShadow: "0 2px 4px rgba(0,0,0,0.1)"
          } })
        ] }) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          bottom: 0,
          left: 0,
          right: 0,
          height: "30%",
          background: COLORS.accentLight,
          clipPath: "polygon(0% 20%, 5% 5%, 10% 20%, 15% 5%, 20% 20%, 25% 5%, 30% 20%, 35% 5%, 40% 20%, 45% 5%, 50% 20%, 55% 5%, 60% 20%, 65% 5%, 70% 20%, 75% 5%, 80% 20%, 85% 5%, 90% 20%, 95% 5%, 100% 20%, 100% 100%, 0% 100%)",
          transform: `translateY(${(0,esm.interpolate)(frame, [0, 30], [100, 0], { extrapolateRight: "clamp" })}%)`
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: {
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          color: props.paperColor,
          paddingTop: 40 * scale
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.title,
              fontSize: isPortrait ? 108 : 176,
              fontFamily: interFont,
              color: props.paperColor,
              fontWeight: 900
            }
          ),
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.subtitle,
              fontSize: isPortrait ? 40 : 60,
              fontFamily: interFont,
              color: props.paperColor,
              fontWeight: 400,
              letterSpacing: 4
            }
          )
        ] }) }),
        renderBackgroundLayers && props.showTexture && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          filter: "url(#noise)",
          opacity: 0.1,
          pointerEvents: "none",
          background: 'url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScxMDAlJyBoZWlnaHQ9JzEwMCUnPjxmaWx0ZXIgaWQ9J25vaXNlJz48ZmVUdXJidWxlbmNlIHR5cGU9J2ZyYWN0YWxOb2lzZScgYmFzZUZyZXF1ZW5jeT0nMC41JyB1bURvdD0nMS41JyBzdGl0Y2hUaWxlcz0nc3RpdGNoJy8+PC9maWx0ZXI+PHJlY3Qgd2lkdGg9JzEwMCUnIGhlaWdodD0nMTAwJScgZmlsdGVyPSd1cmwoI25vaXNlKScgb3BhY2l0eT0nMC41Jy8+PC9zdmc+")'
        } })
      ]
    }
  );
};
registerTemplate({
  id: "creative-story-01",
  name: "Creative Brand Story",
  category: "startup-showcase",
  description: "Artistic stop-motion style for telling unique brand origin stories.",
  tags: ["story", "brand", "creative", "origin", "startup"],
  component: CreativeStory01,
  schema: creativeStorySchema,
  defaultProps: creativeStorySchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/startup-showcase/DataInsights01.tsx












const dataInsightsSchema = lib.z.object({
  title: lib.z.string().default("MARKET DATA"),
  subtitle: lib.z.string().default("Q3 Performance Analysis"),
  videoUrl: lib.z.string().default("https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"),
  primaryColor: lib.z.string().default(COLORS.accent),
  // Hacker Green
  secondaryColor: lib.z.string().default(COLORS.accentDark),
  showNumbers: lib.z.boolean().default(true),
  showGrid: lib.z.boolean().default(true),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const DataInsights01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const rollingNum = Math.floor((0,esm.random)(frame) * 1e5);
  const rollingHex = Math.floor((0,esm.random)(frame + 100) * 16777215).toString(16).toUpperCase();
  const scanY = (0,esm.interpolate)(frame % 150, [0, 150], [0, 100]);
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden",
        fontFamily: interFont
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { opacity: 0.4 }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Video,
          {
            src: props.videoUrl,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              filter: `grayscale(100%) brightness(0.5) sepia(1) hue-rotate(80deg) saturate(3)`
            }
          }
        ) }),
        renderBackgroundLayers && props.showGrid && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          background: `
                        linear-gradient(90deg, ${props.secondaryColor}40 1px, transparent 1px),
                        linear-gradient(180deg, ${props.secondaryColor}40 1px, transparent 1px)
                    `,
          backgroundSize: "50px 50px",
          pointerEvents: "none",
          opacity: 0.5
        } }),
        props.showNumbers && /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
            position: "absolute",
            top: 48 * scale,
            left: 36 * scale,
            color: props.primaryColor,
            fontSize: isPortrait ? 30 : 40,
            lineHeight: 1.35,
            background: "#00000080",
            border: `2px solid ${props.primaryColor}55`,
            borderRadius: 16 * scale,
            padding: "14px 18px"
          }, children: [
            "DATA_STREAM_01: ",
            rollingNum,
            /* @__PURE__ */ (0,jsx_runtime.jsx)("br", {}),
            "HEX_VAL: 0x",
            rollingHex,
            /* @__PURE__ */ (0,jsx_runtime.jsx)("br", {}),
            "FPS: ",
            fps,
            /* @__PURE__ */ (0,jsx_runtime.jsx)("br", {}),
            "TIME: ",
            frame
          ] }),
          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
            position: "absolute",
            bottom: 48 * scale,
            right: 36 * scale,
            color: props.primaryColor,
            fontSize: isPortrait ? 30 : 40,
            lineHeight: 1.35,
            textAlign: "right",
            background: "#00000080",
            border: `2px solid ${props.primaryColor}55`,
            borderRadius: 16 * scale,
            padding: "14px 18px"
          }, children: [
            "SYS_STATUS: OK",
            /* @__PURE__ */ (0,jsx_runtime.jsx)("br", {}),
            "MEM_USAGE: ",
            Math.floor((0,esm.interpolate)(frame, [0, 100], [20, 80])),
            "%",
            /* @__PURE__ */ (0,jsx_runtime.jsx)("br", {}),
            "NET_SPEED: ",
            Math.floor((0,esm.random)(frame) * 100),
            " MBps"
          ] })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { display: "flex", justifyContent: "center", alignItems: "center", pointerEvents: "none" }, children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
          width: isPortrait ? 300 : 600,
          height: isPortrait ? 300 : 400,
          border: `2px solid ${props.primaryColor}80`,
          position: "relative"
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { position: "absolute", top: -1, left: -1, width: 20 * scale, height: 20 * scale, borderTop: `2px solid ${props.primaryColor}`, borderLeft: `2px solid ${props.primaryColor}` } }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { position: "absolute", top: -1, right: -1, width: 20 * scale, height: 20 * scale, borderTop: `2px solid ${props.primaryColor}`, borderRight: `2px solid ${props.primaryColor}` } }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { position: "absolute", bottom: -1, left: -1, width: 20 * scale, height: 20 * scale, borderBottom: `2px solid ${props.primaryColor}`, borderLeft: `2px solid ${props.primaryColor}` } }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { position: "absolute", bottom: -1, right: -1, width: 20 * scale, height: 20 * scale, borderBottom: `2px solid ${props.primaryColor}`, borderRight: `2px solid ${props.primaryColor}` } }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { position: "absolute", top: "50%", left: "50%", width: 20 * scale, height: 1 * scale, background: COLORS.accent, transform: "translate(-50%, -50%)" } }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { position: "absolute", top: "50%", left: "50%", width: 1 * scale, height: 20 * scale, background: COLORS.accent, transform: "translate(-50%, -50%)" } })
        ] }) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          top: `${scanY}%`,
          left: 0,
          width: "100%",
          height: 2 * scale,
          background: COLORS.accent,
          opacity: 0.5,
          boxShadow: `0 0 10px ${props.primaryColor}`
        } }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: {
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          zIndex: 10
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { background: "#000000cc", padding: "30px 56px", border: `2px solid ${props.primaryColor}` }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.title,
              fontSize: isPortrait ? 92 : 136,
              fontFamily: interFont,
              color: COLORS.accent,
              fontWeight: 700,
              letterSpacing: 4
            }
          ) }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { marginTop: 20 * scale, opacity: frame % 20 < 10 ? 1 : 0.5 }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.subtitle,
              fontSize: isPortrait ? 42 : 58,
              fontFamily: interFont,
              color: COLORS.accent,
              fontWeight: 400
            }
          ) })
        ] })
      ]
    }
  );
};
registerTemplate({
  id: "data-insights-01",
  name: "Data Insights Dashboard",
  category: "startup-showcase",
  description: "Cybersecurity style interface for visualizing complex data, analytics, and metrics.",
  tags: ["data", "fintech", "analytics", "startup", "metrics"],
  component: DataInsights01,
  schema: dataInsightsSchema,
  defaultProps: dataInsightsSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/startup-showcase/FounderJourney01.tsx













const founderJourneySchema = lib.z.object({
  title: lib.z.string().default("THE FOUNDER"),
  subtitle: lib.z.string().default("A vision realized"),
  videoUrlBG: lib.z.string().default("https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerFun.mp4"),
  videoUrlFG: lib.z.string().default("https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4"),
  sihouetteUrl: lib.z.string().default("https://remotion.dev/img/silhouette.png"),
  // Placeholder or use text mask
  primaryColor: lib.z.string().default(COLORS.accent),
  enableGrayscale: lib.z.boolean().default(true),
  showOverlay: lib.z.boolean().default(true),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const FounderJourney01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const grayscaleFilter = props.enableGrayscale ? "grayscale(100%) contrast(1.2)" : "none";
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Video,
          {
            src: props.videoUrlBG,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              opacity: 0.4,
              filter: grayscaleFilter
            }
          }
        ) }),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { mixBlendMode: "screen" }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Video,
          {
            src: props.videoUrlFG,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              filter: `${grayscaleFilter} brightness(1.2)`,
              transform: `scale(${(0,esm.interpolate)(frame, [0, 300], [1, 1.2])})`
            }
          }
        ) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          zIndex: 10,
          // Using blend mode to make text "cut out" or "blend"
          mixBlendMode: renderBackgroundLayers ? "overlay" : "normal"
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { transform: `scale(${(0,esm.interpolate)(frame, [0, 100], [0.9, 1])})` }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          EditableText,
          {
            text: props.title,
            fontSize: isPortrait ? 108 : 178,
            fontFamily: interFont,
            color: COLORS.textPrimary,
            fontWeight: 900,
            letterSpacing: -5,
            lineHeight: 0.8
          }
        ) }) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          display: "flex",
          justifyContent: "flex-end",
          alignItems: "center",
          paddingBottom: 100 * scale,
          flexDirection: "column",
          zIndex: 20
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { opacity: fadeIn(frame, 30) }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          EditableText,
          {
            text: props.subtitle,
            fontSize: isPortrait ? 40 : 60,
            fontFamily: interFont,
            color: COLORS.accent,
            fontWeight: 400,
            letterSpacing: 10,
            textTransform: "uppercase"
          }
        ) }) }),
        renderBackgroundLayers && props.showOverlay && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          background: "linear-gradient(45deg, rgba(255,100,0,0.2) 0%, transparent 70%)",
          mixBlendMode: "screen",
          pointerEvents: "none",
          opacity: (0,esm.interpolate)(Math.sin(frame * 0.05), [-1, 1], [0.3, 0.6])
        } })
      ]
    }
  );
};
registerTemplate({
  id: "founder-journey-01",
  name: "Founder Journey",
  category: "startup-showcase",
  description: "Emotive double exposure effect ideal for telling the personal stories of founders and visionaries.",
  tags: ["founder", "story", "vision", "startup", "leadership"],
  component: FounderJourney01,
  schema: founderJourneySchema,
  defaultProps: founderJourneySchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/startup-showcase/LifestyleBrand01.tsx













const lifestyleBrandSchema = lib.z.object({
  title: lib.z.string().default("PREMIUM"),
  subtitle: lib.z.string().default("Quality Redefined"),
  videoUrl1: lib.z.string().default("https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4"),
  videoUrl2: lib.z.string().default("https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerEscapes.mp4"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  // Gold
  showGrain: lib.z.boolean().default(true),
  enableSplits: lib.z.boolean().default(true),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const LifestyleBrand01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { width, height } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const splitProgress = (0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" });
  const splitX = isPortrait ? 0 : (0,esm.interpolate)(splitProgress, [0, 100], [width, width / 2]);
  const splitY = isPortrait ? (0,esm.interpolate)(splitProgress, [0, 100], [height, height / 2]) : 0;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Video,
          {
            src: props.videoUrl1,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              opacity: 0.6,
              filter: "grayscale(100%) contrast(1.1)",
              transform: `scale(${(0,esm.interpolate)(frame, [0, 300], [1, 1.1])})`
            }
          }
        ) }),
        renderBackgroundLayers && props.enableSplits && /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: {
          clipPath: isPortrait ? `polygon(0 ${splitY}px, 100% ${splitY}px, 100% 100%, 0 100%)` : `polygon(${splitX}px 0, 100% 0, 100% 100%, ${splitX}px 100%)`
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            esm.Video,
            {
              src: props.videoUrl2,
              style: {
                width: "100%",
                height: "100%",
                objectFit: "cover",
                filter: "grayscale(50%) contrast(1.1) sepia(0.2)",
                transform: `scale(${(0,esm.interpolate)(frame, [0, 300], [1.2, 1])})`
              }
            }
          ),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            position: "absolute",
            top: isPortrait ? splitY : 0,
            left: isPortrait ? 0 : splitX,
            width: isPortrait ? "100%" : 2,
            height: isPortrait ? 2 : "100%",
            background: COLORS.accentLight
          } })
        ] }),
        renderBackgroundLayers && props.showGrain && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          background: `url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='1'/%3E%3C/svg%3E")`,
          opacity: 0.15,
          mixBlendMode: "overlay",
          pointerEvents: "none",
          filter: "contrast(1.5)"
        } }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: {
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          padding: isPortrait ? "140px 80px" : void 0,
          alignItems: "center",
          zIndex: 10
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            borderTop: `1px solid ${props.accentColor}`,
            borderBottom: `1px solid ${props.accentColor}`,
            padding: "20px 0",
            textAlign: "center",
            transform: `scale(${(0,esm.interpolate)(frame, [0, 100], [0.95, 1], { extrapolateRight: "clamp" })})`,
            opacity: fadeIn(frame, 30)
          }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.title,
              fontSize: isPortrait ? 100 : 180,
              fontFamily: interFont,
              color: COLORS.accent,
              fontWeight: 500,
              letterSpacing: isPortrait ? 4 : 12
            }
          ) }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { marginTop: 32 * scale, opacity: fadeIn(frame, 50) }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.subtitle,
              fontSize: isPortrait ? 36 : 48,
              fontFamily: interFont,
              color: COLORS.textSecondary,
              fontWeight: 300,
              letterSpacing: 6,
              textTransform: "uppercase"
            }
          ) })
        ] })
      ]
    }
  );
};
registerTemplate({
  id: "lifestyle-brand-01",
  name: "Lifestyle Brand Promo",
  category: "startup-showcase",
  description: "Luxurious lifestyle brand style with split screen transitions and elegant typography.",
  tags: ["lifestyle", "brand", "premium", "startup", "product"],
  component: LifestyleBrand01,
  schema: lifestyleBrandSchema,
  defaultProps: lifestyleBrandSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/startup-showcase/ProductLaunch01.tsx












const productLaunchSchema = lib.z.object({
  word1: lib.z.string().default("LAUNCH"),
  word2: lib.z.string().default("YOUR"),
  word3: lib.z.string().default("PRODUCT"),
  videoUrl: lib.z.string().default("https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4"),
  primaryColor: lib.z.string().default(COLORS.accent),
  // Cyan
  secondaryColor: lib.z.string().default(COLORS.accentDark),
  // Magenta
  showGlitch: lib.z.boolean().default(true),
  enableFlash: lib.z.boolean().default(true),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const ProductLaunch01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const glitchX = props.showGlitch ? ((0,esm.random)(frame) - 0.5) * 40 : 0;
  const glitchY = props.showGlitch ? ((0,esm.random)(frame + 100) - 0.5) * 10 : 0;
  const glitchOpposite = props.showGlitch ? ((0,esm.random)(frame + 200) - 0.5) * -40 : 0;
  const word1Start = 0;
  const word2Start = 15;
  const word3Start = 30;
  const stomp = (delay) => (0,esm.spring)({
    frame: frame - delay,
    fps,
    config: { damping: 12, stiffness: 200, mass: 0.5 }
  });
  const flash = props.enableFlash && frame % 45 < 5 ? 1 : 0;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          transform: `translate(${glitchX * 0.2}px, ${glitchY * 0.2}px) scale(1.1)`
        }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Video,
          {
            src: props.videoUrl,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              filter: "grayscale(100%) contrast(1.2)",
              opacity: 0.6
            }
          }
        ) }),
        renderBackgroundLayers && props.showGlitch && /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
            mixBlendMode: "screen",
            transform: `translate(${glitchX}px, 0)`,
            opacity: 0.7
          }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            width: "100%",
            height: "100%",
            background: COLORS.accent,
            clipPath: `inset(${(0,esm.random)(frame) * 100}% 0 ${(0,esm.random)(frame + 50) * 100}% 0)`
          } }) }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
            mixBlendMode: "screen",
            transform: `translate(${glitchOpposite}px, 0)`,
            opacity: 0.7
          }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            width: "100%",
            height: "100%",
            background: props.secondaryColor,
            clipPath: `inset(${(0,esm.random)(frame + 20) * 100}% 0 ${(0,esm.random)(frame + 70) * 100}% 0)`
          } }) })
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: {
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          zIndex: 10,
          gap: 0,
          padding: isPortrait ? "140px 80px" : void 0
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { transform: `scale(${stomp(word1Start)})`, opacity: frame >= word1Start ? 1 : 0 }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.word1,
              fontSize: isPortrait ? 124 : 168,
              fontFamily: interFont,
              color: COLORS.textPrimary,
              fontWeight: 900,
              fontStyle: "italic",
              letterSpacing: -5,
              lineHeight: 0.9,
              style: {
                textShadow: `${glitchX}px 0 ${props.primaryColor}, ${glitchOpposite}px 0 ${props.secondaryColor}`,
                transform: `skewX(-10deg)`
              }
            }
          ) }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { transform: `scale(${stomp(word2Start)})`, opacity: frame >= word2Start ? 1 : 0 }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.word2,
              fontSize: isPortrait ? 76 : 88,
              fontFamily: interFont,
              color: COLORS.accent,
              fontWeight: 700,
              letterSpacing: 10,
              lineHeight: 1,
              style: {
                background: renderBackgroundLayers ? COLORS.bg : "transparent",
                padding: "0 20px",
                transform: `skewX(-10deg)`
              }
            }
          ) }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { transform: `scale(${stomp(word3Start)})`, opacity: frame >= word3Start ? 1 : 0 }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.word3,
              fontSize: isPortrait ? 152 : 180,
              fontFamily: interFont,
              color: COLORS.textPrimary,
              fontWeight: 900,
              fontStyle: "italic",
              letterSpacing: -8,
              lineHeight: 0.8,
              style: {
                textShadow: `${glitchOpposite}px 0 ${props.secondaryColor}, ${glitchX}px 0 ${props.primaryColor}`,
                transform: `skewX(-10deg)`,
                WebkitTextStroke: "2px white",
                color: "transparent"
              }
            }
          ) })
        ] }),
        renderBackgroundLayers && props.enableFlash && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          background: "#fff",
          opacity: flash * 0.15,
          mixBlendMode: "overlay"
        } }),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          background: `repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    #000000 3px,
                    #000000 4px
                )`,
          opacity: 0.2,
          pointerEvents: "none"
        } }),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          background: "radial-gradient(circle, transparent 50%, black 100%)",
          opacity: 0.6
        } })
      ]
    }
  );
};
registerTemplate({
  id: "product-launch-01",
  name: "Product Launch Energy",
  category: "startup-showcase",
  description: "High-energy rhythmic opener for product launches with aggressive glitch effects and stomp typography.",
  tags: ["product", "launch", "startup", "energy", "bold"],
  component: ProductLaunch01,
  schema: productLaunchSchema,
  defaultProps: productLaunchSchema.parse({}),
  durationInFrames: 90,
  // Short & punchy
  fps: DEFAULT_FPS
});

;// ./src/templates/startup-showcase/StartupVision01.tsx













const startupVisionSchema = lib.z.object({
  title: lib.z.string().default("OUR VISION"),
  subtitle: lib.z.string().default("Building the future of tech"),
  location: lib.z.string().default("ESTABLISHED \u2022 2026"),
  imageUrl: lib.z.string().default("https://images.unsplash.com/photo-1476610182048-b716b8518aae?w=1600"),
  overlayColor: lib.z.string().default("#000000"),
  accentColor: lib.z.string().default(COLORS.accentLight),
  // Gold
  showDust: lib.z.boolean().default(true),
  showVignette: lib.z.boolean().default(true),
  enableGrade: lib.z.boolean().default(true),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const StartupVision01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const imageScale = (0,esm.interpolate)(frame, [0, 300], [1, 1.3], { extrapolateRight: "clamp" });
  const textY = (0,esm.interpolate)(frame, [0, 150], [0, -40]);
  const dustParticles = react.useMemo(() => {
    return new Array(20).fill(0).map((_, i) => ({
      x: (0,esm.random)(i) * 100,
      y: (0,esm.random)(i + 10) * 100,
      size: (0,esm.random)(i + 20) * 4 + 1,
      speed: (0,esm.random)(i + 30) * 0.5 + 0.2,
      opacity: (0,esm.random)(i + 40) * 0.5 + 0.2
    }));
  }, []);
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Img,
          {
            src: props.imageUrl,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              transform: `scale(${imageScale})`,
              filter: props.enableGrade ? "contrast(1.1) saturate(0.9) brightness(0.8)" : "none"
            }
          }
        ) }),
        renderBackgroundLayers && props.showVignette && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              background: `radial-gradient(circle at center, transparent 40%, ${props.overlayColor}cc 100%)`,
              opacity: 0.8
            }
          }
        ),
        renderBackgroundLayers && props.showDust && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { children: dustParticles.map((p, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              left: `${p.x}%`,
              top: `${(p.y + frame * p.speed) % 110 - 10}%`,
              width: p.size,
              height: p.size,
              borderRadius: "50%",
              background: "#fff",
              opacity: p.opacity,
              boxShadow: "0 0 4px rgba(255,255,255,0.8)",
              filter: "blur(1px)"
            }
          },
          i
        )) }),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.AbsoluteFill,
          {
            style: {
              display: "flex",
              flexDirection: "column",
              justifyContent: "center",
              alignItems: "center",
              zIndex: 10,
              padding: isPortrait ? "140px 80px" : void 0
            },
            children: /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { transform: `translateY(${textY}px)` }, children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
                opacity: fadeIn(frame, 10),
                transform: `translateY(${(0,esm.interpolate)(frame, [0, 30], [20, 0], { extrapolateRight: "clamp" })}px)`,
                marginBottom: 40 * scale,
                textAlign: "center"
              }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.location,
                  fontSize: isPortrait ? 32 : 28 * scale,
                  fontFamily: interFont,
                  color: COLORS.accentLight,
                  fontWeight: 600,
                  letterSpacing: 6,
                  textTransform: "uppercase"
                }
              ) }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
                opacity: fadeIn(frame, 30),
                transform: `scale(${(0,esm.interpolate)(frame, [30, 90], [1.1, 1], { extrapolateRight: "clamp" })})`,
                marginBottom: 20 * scale,
                textAlign: "center"
              }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.title,
                  fontSize: isPortrait ? 112 : 176,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 700,
                  letterSpacing: isPortrait ? 5 : 20,
                  lineHeight: 1
                }
              ) }),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: {
                opacity: fadeIn(frame, 60),
                marginTop: 40 * scale,
                textAlign: "center"
              }, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
                  width: 1 * scale,
                  height: 60 * scale,
                  background: "#fff",
                  margin: "0 auto 20px",
                  opacity: 0.5
                } }),
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.subtitle,
                    fontSize: isPortrait ? 42 : 46 * scale,
                    fontFamily: interFont,
                    color: COLORS.textSecondary,
                    fontWeight: 300,
                    letterSpacing: 4,
                    fontStyle: "italic"
                  }
                )
              ] })
            ] })
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { pointerEvents: "none" }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          top: isPortrait ? 40 : 60,
          left: isPortrait ? 20 : 60,
          right: isPortrait ? 20 : 60,
          bottom: isPortrait ? 40 : 60,
          border: `2px solid ${props.accentColor}40`,
          opacity: fadeIn(frame, 80)
        } }) })
      ]
    }
  );
};
registerTemplate({
  id: "startup-vision-01",
  name: "Startup Vision Journey",
  category: "startup-showcase",
  description: "Inspiring slow-motion parallax effect to showcase company vision and values.",
  tags: ["startup", "vision", "mission", "corporate", "future"],
  component: StartupVision01,
  schema: startupVisionSchema,
  defaultProps: startupVisionSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/startup-showcase/TechInnovation01.tsx














const techInnovationSchema = lib.z.object({
  title: lib.z.string().default("AI DRIVEN"),
  subtitle: lib.z.string().default("Next Gen Technology"),
  videoUrl: lib.z.string().default("https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/TearsOfSteel.mp4"),
  primaryColor: lib.z.string().default(COLORS.accent),
  // Neon Cyan
  secondaryColor: lib.z.string().default(COLORS.accentDark),
  // Neon Pink
  showGrid: lib.z.boolean().default(true),
  enableGlow: lib.z.boolean().default(true),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const TechInnovation01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const gridMove = (0,esm.interpolate)(frame, [0, 300], [0, 200]);
  const particles = react.useMemo(() => new Array(15).fill(0).map((_, i) => ({
    x: (0,esm.random)(i) * 100,
    y: (0,esm.random)(i + 20) * 100,
    size: (0,esm.random)(i + 40) * 4 + 2,
    speed: (0,esm.random)(i + 60) * 0.5 + 0.5
  })), []);
  const glowStyle = props.enableGlow ? {
    textShadow: `
            0 0 10px ${props.primaryColor},
            0 0 20px ${props.primaryColor},
            0 0 40px ${props.secondaryColor}
        `
  } : {};
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden",
        perspective: 1e3
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: { zIndex: 0 }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Video,
          {
            src: props.videoUrl,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              filter: "brightness(0.3) contrast(1.2) hue-rotate(180deg)",
              opacity: 0.5
            }
          }
        ) }),
        renderBackgroundLayers && props.showGrid && /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
          position: "absolute",
          bottom: "-40%",
          left: "-50%",
          width: "200%",
          height: "100%",
          transform: "rotateX(60deg)",
          background: `
                        linear-gradient(transparent 0%, ${props.secondaryColor}20 100%),
                        repeating-linear-gradient(90deg, ${props.primaryColor}40 0px, ${props.primaryColor}40 1px, transparent 1px, transparent 100px),
                        repeating-linear-gradient(0deg, ${props.primaryColor}40 0px, ${props.primaryColor}40 1px, transparent 1px, transparent 100px)
                    `,
          backgroundPosition: `0 ${gridMove}px`,
          maskImage: "linear-gradient(to top, black 0%, transparent 80%)",
          WebkitMaskImage: "linear-gradient(to top, black 0%, transparent 80%)"
        } }),
        particles.map((p, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              left: `${p.x}%`,
              top: `${(p.y - frame * p.speed) % 110}%`,
              width: p.size,
              height: p.size,
              background: i % 2 === 0 ? props.primaryColor : props.secondaryColor,
              opacity: (0,esm.interpolate)(frame, [0, 30], [0, 0.6], { extrapolateRight: "clamp" }),
              boxShadow: `0 0 8px ${i % 2 === 0 ? props.primaryColor : props.secondaryColor}`
            }
          },
          i
        )),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(esm.AbsoluteFill, { style: {
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          padding: isPortrait ? "140px 80px" : void 0,
          alignItems: "center",
          zIndex: 10
        }, children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: {
            border: `2px solid ${props.primaryColor}`,
            padding: "40px 80px",
            borderRadius: 4 * scale,
            background: "#00000080",
            boxShadow: `0 0 20px ${props.primaryColor}40`,
            transform: `scale(${(0,esm.spring)({ frame, fps, config: { damping: 10 } })})`
          }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.title,
              fontSize: isPortrait ? 112 : 176,
              fontFamily: interFont,
              color: COLORS.textPrimary,
              fontWeight: 700,
              letterSpacing: 4,
              style: glowStyle
            }
          ) }),
          /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { marginTop: 40 * scale, opacity: fadeIn(frame, 20) }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
            EditableText,
            {
              text: props.subtitle,
              fontSize: isPortrait ? 40 : 64,
              fontFamily: interFont,
              color: COLORS.accentDark,
              fontWeight: 500,
              letterSpacing: 8,
              textTransform: "uppercase",
              style: {
                textShadow: `0 0 10px ${props.secondaryColor}`
              }
            }
          ) })
        ] }),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.AbsoluteFill, { style: {
          background: `repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 4px,
                    #000000 5px
                )`,
          opacity: 0.15,
          pointerEvents: "none"
        } })
      ]
    }
  );
};
registerTemplate({
  id: "tech-innovation-01",
  name: "Tech Innovation Hub",
  category: "startup-showcase",
  description: "Futuristic tech showcase with 3D grid floor, neon glow text, and digital particles.",
  tags: ["tech", "innovation", "ai", "startup", "future"],
  component: TechInnovation01,
  schema: techInnovationSchema,
  defaultProps: techInnovationSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/tech-news/TechNewsAIUpdate01.tsx













const techNewsAIUpdateSchema = lib.z.object({
  badge: lib.z.string().default("AI / ML"),
  headline: lib.z.string().default("GPT-5 Sets New Benchmarks Across Every Category"),
  subheadline: lib.z.string().default("OpenAI's latest model achieves superhuman performance on reasoning, coding, and multimodal tasks"),
  feature1Icon: lib.z.string().default("\u{1F9E0}"),
  feature1Title: lib.z.string().default("Reasoning"),
  feature1Desc: lib.z.string().default("92% on ARC-AGI, up from 71%"),
  feature2Icon: lib.z.string().default("\u{1F4BB}"),
  feature2Title: lib.z.string().default("Coding"),
  feature2Desc: lib.z.string().default("98th percentile on SWE-bench"),
  feature3Icon: lib.z.string().default("\u{1F441}"),
  feature3Title: lib.z.string().default("Multimodal"),
  feature3Desc: lib.z.string().default("Native video + audio understanding"),
  feature4Icon: lib.z.string().default("\u26A1"),
  feature4Title: lib.z.string().default("Speed"),
  feature4Desc: lib.z.string().default("3x throughput vs GPT-4o"),
  source: lib.z.string().default("The Verge"),
  timestamp: lib.z.string().default("2 hours ago"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const TechNewsAIUpdate01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const features = [
    { icon: props.feature1Icon, title: props.feature1Title, desc: props.feature1Desc },
    { icon: props.feature2Icon, title: props.feature2Title, desc: props.feature2Desc },
    { icon: props.feature3Icon, title: props.feature3Title, desc: props.feature3Desc },
    { icon: props.feature4Icon, title: props.feature4Title, desc: props.feature4Desc }
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "svg",
          {
            viewBox: "0 0 1920 1080",
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              opacity: 0.04
            },
            children: [
              Array.from({ length: 20 }).map((_, i) => {
                const x1 = i * 137 % 1920;
                const y1 = i * 89 % 1080;
                const x2 = (i + 5) * 173 % 1920;
                const y2 = (i + 3) * 131 % 1080;
                return /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "line",
                  {
                    x1,
                    y1,
                    x2,
                    y2,
                    stroke: props.primaryColor,
                    strokeWidth: "1",
                    strokeDasharray: `${(0,esm.interpolate)(frame, [i * 5, i * 5 + 60], [0, 200], { extrapolateLeft: "clamp", extrapolateRight: "clamp" })}`
                  },
                  i
                );
              }),
              Array.from({ length: 12 }).map((_, i) => {
                const cx = i * 173 % 1920;
                const cy = i * 107 % 1080;
                return /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "circle",
                  {
                    cx,
                    cy,
                    r: 4,
                    fill: props.primaryColor,
                    opacity: fadeIn(frame, i * 5, 15)
                  },
                  i
                );
              })
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 32 : 48
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: 24,
                    opacity: fadeIn(frame, 0)
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        padding: `${5 * scale}px ${14 * scale}px`,
                        borderRadius: 12,
                        background: `${props.primaryColor}20`,
                        border: `2px solid ${props.primaryColor}40`
                      },
                      children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                        EditableText,
                        {
                          text: props.badge,
                          fontSize: 32 * scale,
                          fontFamily: interFont,
                          color: COLORS.accent,
                          fontWeight: 800,
                          letterSpacing: 2
                        }
                      )
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 84 : 104,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.1,
                  letterSpacing: -1,
                  maxLines: 3,
                  style: {
                    opacity: fadeIn(frame, 8),
                    transform: slideIn(frame, "up", 8, 25)
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subheadline,
                  fontSize: isPortrait ? 44 : 52,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  lineHeight: 1.5,
                  maxLines: 2,
                  style: { opacity: fadeIn(frame, 18) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "grid",
                    gridTemplateColumns: isPortrait ? "1fr" : "1fr 1fr",
                    gap: isPortrait ? 20 : 32,
                    marginTop: isPortrait ? 0 : "auto",
                    marginBottom: isPortrait ? 0 : 16
                  },
                  children: features.map((feat, i) => {
                    const delay = 30 + staggerDelay(i, 10);
                    const cardSpring = (0,esm.spring)({
                      frame: frame - delay,
                      fps,
                      config: { damping: 12, stiffness: 120, mass: 0.5 }
                    });
                    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          alignItems: "flex-start",
                          gap: 28,
                          padding: `${18 * scale}px ${20 * scale}px`,
                          borderRadius: 28,
                          background: "rgba(255,255,255,0.03)",
                          border: "2px solid rgba(255,255,255,0.06)",
                          opacity: fadeIn(frame, delay),
                          transform: `scale(${cardSpring})`
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            "div",
                            {
                              style: {
                                width: 40 * scale,
                                height: 40 * scale,
                                borderRadius: 20,
                                background: `${props.primaryColor}12`,
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                fontSize: 44 * scale,
                                flexShrink: 0
                              },
                              children: feat.icon
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", flexDirection: "column", gap: 8 }, children: [
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              EditableText,
                              {
                                text: feat.title,
                                fontSize: 36 * scale,
                                fontFamily: interFont,
                                color: COLORS.textSecondary,
                                fontWeight: 700
                              }
                            ),
                            /* @__PURE__ */ (0,jsx_runtime.jsx)(
                              EditableText,
                              {
                                text: feat.desc,
                                fontSize: 32 * scale,
                                fontFamily: interFont,
                                color: COLORS.textSecondary,
                                fontWeight: 400,
                                lineHeight: 1.3
                              }
                            )
                          ] })
                        ]
                      },
                      i
                    );
                  })
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    gap: 24,
                    alignItems: "center",
                    flexWrap: isPortrait ? "wrap" : "nowrap",
                    opacity: fadeIn(frame, 75)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.source,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 600
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 4, height: 8, borderRadius: "50%", background: "#ffffff33" } }),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.timestamp,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: 400
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "tech-news-ai-update-01",
  name: "AI / ML Update",
  category: "tech-news",
  description: "AI model update with feature grid, neural network background, and benchmark data",
  tags: ["AI", "ML", "update", "tech-news", "model", "benchmarks"],
  component: TechNewsAIUpdate01,
  schema: techNewsAIUpdateSchema,
  defaultProps: techNewsAIUpdateSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/tech-news/TechNewsFunding01.tsx













const techNewsFundingSchema = lib.z.object({
  badge: lib.z.string().default("FUNDING"),
  companyName: lib.z.string().default("Anthropic"),
  headline: lib.z.string().default("Anthropic Raises $2B Series D at $18B Valuation"),
  subheadline: lib.z.string().default("AI safety company accelerates compute scaling and research partnerships"),
  amount: lib.z.string().default("$2B"),
  amountLabel: lib.z.string().default("Series D"),
  valuation: lib.z.string().default("$18B"),
  valuationLabel: lib.z.string().default("Valuation"),
  investors: lib.z.string().default("Led by Google, Spark Capital, with participation from Salesforce Ventures"),
  imageUrl: lib.z.string().default("https://images.unsplash.com/photo-1620712943543-bcc4688e7485?w=800"),
  source: lib.z.string().default("TechCrunch"),
  timestamp: lib.z.string().default("3 hours ago"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const TechNewsFunding01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                top: "-20%",
                left: "60%",
                width: 600,
                height: 600,
                borderRadius: "50%",
                background: `${props.primaryColor}0c`,
                filter: "blur(120px)"
              }
            }
          ),
          /* @__PURE__ */ (0,jsx_runtime.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                bottom: "-20%",
                right: "60%",
                width: 500,
                height: 500,
                borderRadius: "50%",
                background: `${props.accentColor}08`,
                filter: "blur(100px)"
              }
            }
          )
        ] }),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 40 : 56
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: 24,
                    opacity: fadeIn(frame, 0)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          padding: `${5 * scale}px ${14 * scale}px`,
                          borderRadius: 12,
                          background: COLORS.accentLight
                        },
                        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: props.badge,
                            fontSize: 32 * scale,
                            fontFamily: interFont,
                            color: "#000000",
                            fontWeight: 800,
                            letterSpacing: 2
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.companyName,
                        fontSize: 40 * scale,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: 600
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 84 : 112,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.1,
                  letterSpacing: -1,
                  maxLines: 3,
                  style: {
                    opacity: fadeIn(frame, 8),
                    transform: slideIn(frame, "up", 8, 25)
                  }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subheadline,
                  fontSize: isPortrait ? 48 : 60,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  lineHeight: 1.5,
                  maxLines: 2,
                  style: { opacity: fadeIn(frame, 20) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: isPortrait ? "column" : "row",
                    gap: isPortrait ? 24 : 48,
                    marginTop: isPortrait ? 8 : "auto"
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          flex: isPortrait ? void 0 : 1,
                          padding: `${28 * scale}px`,
                          borderRadius: 40,
                          background: `${props.primaryColor}10`,
                          border: `2px solid ${props.primaryColor}30`,
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "center",
                          justifyContent: isPortrait ? "flex-end" : "center",
                          gap: 16,
                          transform: `scale(${(0,esm.spring)({ frame: frame - 30, fps, config: { damping: 12, stiffness: 120, mass: 0.6 } })})`,
                          opacity: fadeIn(frame, 30)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.amount,
                              fontSize: isPortrait ? 128 : 160,
                              fontFamily: interFont,
                              color: COLORS.accent,
                              fontWeight: 900,
                              letterSpacing: -2
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.amountLabel,
                              fontSize: 36 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 600,
                              textTransform: "uppercase",
                              letterSpacing: 3
                            }
                          )
                        ]
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          flex: isPortrait ? void 0 : 1,
                          padding: `${28 * scale}px`,
                          borderRadius: 40,
                          background: `${props.accentColor}08`,
                          border: `2px solid ${props.accentColor}25`,
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "center",
                          justifyContent: "center",
                          gap: 16,
                          transform: `scale(${(0,esm.spring)({ frame: frame - 40, fps, config: { damping: 12, stiffness: 120, mass: 0.6 } })})`,
                          opacity: fadeIn(frame, 40)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.valuation,
                              fontSize: isPortrait ? 128 : 160,
                              fontFamily: interFont,
                              color: COLORS.accentLight,
                              fontWeight: 900,
                              letterSpacing: -2
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.valuationLabel,
                              fontSize: 36 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 600,
                              textTransform: "uppercase",
                              letterSpacing: 3
                            }
                          )
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    padding: `${14 * scale}px ${20 * scale}px`,
                    borderRadius: 20,
                    background: "rgba(255,255,255,0.03)",
                    border: "2px solid rgba(255,255,255,0.06)",
                    opacity: fadeIn(frame, 60),
                    transform: slideIn(frame, "up", 60, 15)
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.investors,
                      fontSize: 36 * scale,
                      fontFamily: interFont,
                      color: COLORS.textSecondary,
                      fontWeight: 400,
                      lineHeight: 1.4
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    gap: 24,
                    alignItems: "center",
                    flexWrap: isPortrait ? "wrap" : "nowrap",
                    opacity: fadeIn(frame, 70)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.source,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 600
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 4, height: 8, borderRadius: "50%", background: "#ffffff33" } }),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.timestamp,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: 400
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "tech-news-funding-01",
  name: "Startup Funding Announcement",
  category: "tech-news",
  description: "Startup funding round with amount/valuation metric cards, investors, and editorial layout",
  tags: ["funding", "startup", "investment", "tech-news", "venture-capital"],
  component: TechNewsFunding01,
  schema: techNewsFundingSchema,
  defaultProps: techNewsFundingSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/tech-news/TechNewsLaunch01.tsx













const techNewsLaunchSchema = lib.z.object({
  badge: lib.z.string().default("NEW LAUNCH"),
  headline: lib.z.string().default("Apple Vision Pro 2 Unveiled with Revolutionary Spatial Computing"),
  subheadline: lib.z.string().default("Next-gen mixed reality headset features 8K micro-OLED displays and M4 Ultra chip"),
  imageUrl: lib.z.string().default("https://images.unsplash.com/photo-1531297484001-80022131f5a1?w=800"),
  source: lib.z.string().default("TechCrunch"),
  author: lib.z.string().default("By Alex Rivera"),
  timestamp: lib.z.string().default("2 hours ago"),
  category: lib.z.string().default("HARDWARE"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const TechNewsLaunch01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundImage: `
linear-gradient(${props.primaryColor}08 1px, transparent 1px),
    linear-gradient(90deg, ${props.primaryColor}08 1px, transparent 1px)
        `,
              backgroundSize: "60px 60px",
              opacity: fadeIn(frame, 0, 30)
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: isPortrait ? "column" : "row",
              width: "100%",
              height: "100%"
            },
            children: [
              renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    flex: isPortrait ? void 0 : 1,
                    height: isPortrait ? "42%" : "100%",
                    position: "relative",
                    overflow: "hidden",
                    opacity: fadeIn(frame, 5)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      esm.Img,
                      {
                        src: props.imageUrl,
                        style: {
                          width: "100%",
                          height: "100%",
                          objectFit: "cover",
                          transform: `scale(${(0,esm.interpolate)(frame, [0, 300], [1.1, 1], {
                            extrapolateRight: "clamp"
                          })})`
                        }
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          position: "absolute",
                          top: 0,
                          left: 0,
                          right: 0,
                          bottom: 0,
                          background: isPortrait ? linearGradient(180, "transparent", props.backgroundColor) : linearGradient(90, "transparent", props.backgroundColor)
                        }
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          position: "absolute",
                          top: isPortrait ? 30 : 40,
                          left: isPortrait ? 20 : 30,
                          padding: `${6 * scale}px ${16 * scale}px`,
                          borderRadius: 12 * scale,
                          background: COLORS.accentLight,
                          opacity: fadeIn(frame, 10),
                          transform: `scale(${scaleIn(frame, fps, 10)})`
                        },
                        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: props.badge,
                            fontSize: 32 * scale,
                            fontFamily: interFont,
                            color: COLORS.textPrimary,
                            fontWeight: 700,
                            letterSpacing: 2
                          }
                        )
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    flex: 1,
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center",
                    padding: isPortrait ? "130px 80px 100px" : "60px 60px",
                    gap: isPortrait ? 44 : 32
                  },
                  children: [
                    !renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          display: "inline-flex",
                          alignSelf: "flex-start",
                          padding: `${6 * scale}px ${16 * scale}px`,
                          borderRadius: 12 * scale,
                          background: COLORS.accentLight,
                          opacity: fadeIn(frame, 10)
                        },
                        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: props.badge,
                            fontSize: 32 * scale,
                            fontFamily: interFont,
                            color: COLORS.textPrimary,
                            fontWeight: 700,
                            letterSpacing: 2
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      "div",
                      {
                        style: {
                          display: "inline-flex",
                          alignSelf: "flex-start",
                          padding: `${4 * scale}px ${12 * scale}px`,
                          borderRadius: 4 * scale,
                          border: `2px solid ${props.primaryColor}44`,
                          opacity: fadeIn(frame, 20)
                        },
                        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                          EditableText,
                          {
                            text: props.category,
                            fontSize: 28 * scale,
                            fontFamily: interFont,
                            color: COLORS.accent,
                            fontWeight: 600,
                            letterSpacing: 3
                          }
                        )
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.headline,
                        fontSize: isPortrait ? 92 : 112,
                        fontFamily: interFont,
                        color: "#f0f6fc",
                        fontWeight: 800,
                        lineHeight: 1.15,
                        letterSpacing: -0.5,
                        maxLines: 3,
                        style: {
                          opacity: fadeIn(frame, 25),
                          transform: slideIn(frame, "up", 25, 25)
                        }
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.subheadline,
                        fontSize: isPortrait ? 46 : 52,
                        fontFamily: interFont,
                        color: "#8b949e",
                        fontWeight: 400,
                        lineHeight: 1.5,
                        maxLines: 2,
                        style: { opacity: fadeIn(frame, 40) }
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          alignItems: "center",
                          flexWrap: isPortrait ? "wrap" : "nowrap",
                          gap: 24 * scale,
                          marginTop: 24 * scale,
                          opacity: fadeIn(frame, 50)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.source,
                              fontSize: 36 * scale,
                              fontFamily: interFont,
                              color: COLORS.accent,
                              fontWeight: 600
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            "div",
                            {
                              style: {
                                width: 1 * scale,
                                height: 16 * scale,
                                background: "#30363d"
                              }
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.author,
                              fontSize: 32 * scale,
                              fontFamily: interFont,
                              color: "#8b949e",
                              fontWeight: 400
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            "div",
                            {
                              style: {
                                width: 1 * scale,
                                height: 16 * scale,
                                background: "#30363d"
                              }
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: props.timestamp,
                              fontSize: 32 * scale,
                              fontFamily: interFont,
                              color: "#484f58",
                              fontWeight: 400
                            }
                          )
                        ]
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 50], [0, 100], {
                extrapolateRight: "clamp"
              })}% `,
              height: 6 * scale,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "tech-news-launch-01",
  name: "Tech News Product Launch",
  category: "tech-news",
  description: "Product launch announcement with hero image, tech grid background, and editorial layout",
  tags: ["launch", "product", "announcement", "tech-news", "gadget"],
  component: TechNewsLaunch01,
  schema: techNewsLaunchSchema,
  defaultProps: techNewsLaunchSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/tech-news/TechNewsOpenSource01.tsx













const techNewsOpenSourceSchema = lib.z.object({
  badge: lib.z.string().default("OPEN SOURCE"),
  projectName: lib.z.string().default("LlamaCode"),
  headline: lib.z.string().default("Meta Releases LlamaCode \u2014 Open-Source AI Coding Assistant"),
  subheadline: lib.z.string().default("Outperforms GPT-4 on coding benchmarks with fully open weights and fine-tuning support"),
  stars: lib.z.string().default("42.3k \u2605"),
  license: lib.z.string().default("Apache 2.0"),
  languages: lib.z.string().default("50+ languages"),
  modelSize: lib.z.string().default("70B params"),
  source: lib.z.string().default("GitHub Blog"),
  timestamp: lib.z.string().default("Just released"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const TechNewsOpenSource01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const codeRain = Array.from({ length: 20 }).map((_, i) => ({
    x: i * 97 % 100,
    speed: 0.3 + i % 5 * 0.15,
    char: ["0", "1", "{", "}", "/", "*", "<", ">", "=", ";"][i % 10],
    delay: i * 3
  }));
  const stats = [
    { label: "Stars", value: props.stars },
    { label: "License", value: props.license },
    { label: "Support", value: props.languages },
    { label: "Size", value: props.modelSize }
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && codeRain.map((drop, i) => /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              left: `${drop.x}%`,
              top: `${(frame * drop.speed + drop.delay * 20) % 120 - 10}%`,
              fontSize: 28 * scale,
              fontFamily: "monospace",
              color: props.primaryColor,
              opacity: 0.06
            },
            children: drop.char
          },
          i
        )),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 100px",
              gap: isPortrait ? 32 : 48
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: 24 * scale, opacity: fadeIn(frame, 0) }, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "div",
                  {
                    style: {
                      padding: `${5 * scale}px ${14 * scale}px`,
                      borderRadius: 12 * scale,
                      background: `${props.primaryColor}20`,
                      border: `2px solid ${props.primaryColor}40`
                    },
                    children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.badge,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 800,
                        letterSpacing: 2
                      }
                    )
                  }
                ),
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  EditableText,
                  {
                    text: props.projectName,
                    fontSize: 40 * scale,
                    fontFamily: interFont,
                    color: COLORS.textSecondary,
                    fontWeight: 600
                  }
                )
              ] }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 84 : 112,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.1,
                  letterSpacing: -1,
                  maxLines: 3,
                  style: { opacity: fadeIn(frame, 8), transform: slideIn(frame, "up", 8, 25) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subheadline,
                  fontSize: isPortrait ? 44 : 52,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  lineHeight: 1.5,
                  maxLines: 2,
                  style: { opacity: fadeIn(frame, 20) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "grid",
                    gridTemplateColumns: isPortrait ? "1fr 1fr" : "repeat(4, 1fr)",
                    gap: isPortrait ? 20 : 32,
                    marginTop: isPortrait ? 0 : "auto",
                    marginBottom: isPortrait ? 0 : 16
                  },
                  children: stats.map((stat, i) => {
                    const cardSpring = (0,esm.spring)({
                      frame: frame - 35 - i * 8,
                      fps,
                      config: { damping: 12, stiffness: 130, mass: 0.5 }
                    });
                    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          flexDirection: "column",
                          padding: `${16 * scale}px`,
                          borderRadius: 20 * scale,
                          background: "rgba(255,255,255,0.03)",
                          border: `2px solid ${props.primaryColor}15`,
                          gap: 12 * scale,
                          transform: `scale(${cardSpring})`,
                          opacity: fadeIn(frame, 35 + i * 8)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: `// ${stat.label}`,
                              fontSize: 28 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 500
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: stat.value,
                              fontSize: 48 * scale,
                              fontFamily: interFont,
                              color: COLORS.accent,
                              fontWeight: 700
                            }
                          )
                        ]
                      },
                      i
                    );
                  })
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    gap: 24 * scale,
                    alignItems: "center",
                    flexWrap: isPortrait ? "wrap" : "nowrap",
                    opacity: fadeIn(frame, 75)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.source,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 600
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 4 * scale, height: 8 * scale, borderRadius: "50%", background: "#ffffff33" } }),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.timestamp,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: 400
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6 * scale,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "tech-news-open-source-01",
  name: "Open Source Release",
  category: "tech-news",
  description: "Open source project release with code rain background, terminal-style stat cards",
  tags: ["open-source", "github", "release", "tech-news", "code"],
  component: TechNewsOpenSource01,
  schema: techNewsOpenSourceSchema,
  defaultProps: techNewsOpenSourceSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/tech-news/TechNewsSecurity01.tsx













const techNewsSecuritySchema = lib.z.object({
  badge: lib.z.string().default("\u{1F512} SECURITY ALERT"),
  headline: lib.z.string().default("Critical Zero-Day Vulnerability Found in Popular Framework"),
  subheadline: lib.z.string().default("Affects 40% of web applications worldwide \u2014 patches available now"),
  severity: lib.z.string().default("Critical"),
  cvssScore: lib.z.string().default("9.8 / 10"),
  affectedSystems: lib.z.string().default("2.4M+ servers"),
  patchStatus: lib.z.string().default("Available"),
  source: lib.z.string().default("NIST / CVE"),
  timestamp: lib.z.string().default("Feb 12, 2026 \u2022 Breaking"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const TechNewsSecurity01 = (props) => {
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const scale = useResponsive(1, 1);
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const pulse = (0,esm.interpolate)(Math.sin(frame * 0.1), [-1, 1], [0.6, 1]);
  const stats = [
    { label: "Severity", value: props.severity },
    { label: "CVSS", value: props.cvssScore },
    { label: "Affected", value: props.affectedSystems },
    { label: "Patch", value: props.patchStatus }
  ];
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              border: `2px solid ${props.primaryColor}`,
              opacity: pulse * 0.15,
              borderRadius: 0
            }
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              height: 6,
              background: `repeating-linear-gradient(
            90deg,
            ${props.primaryColor} 0px,
            ${props.primaryColor} 20px,
            ${props.accentColor} 20px,
            ${props.accentColor} 40px
          )`,
              opacity: fadeIn(frame, 0, 15)
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              justifyContent: "center",
              padding: isPortrait ? "130px 80px 100px" : "70px 100px 60px",
              gap: isPortrait ? 28 : 40
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { display: "flex", alignItems: "center", gap: 24, opacity: fadeIn(frame, 5) }, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    padding: `${6 * scale}px ${14 * scale}px`,
                    borderRadius: 12,
                    background: `${props.primaryColor}20`,
                    border: `2px solid ${props.primaryColor}60`
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.badge,
                      fontSize: 32 * scale,
                      fontFamily: interFont,
                      color: COLORS.accent,
                      fontWeight: 800,
                      letterSpacing: 2
                    }
                  )
                }
              ) }),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.headline,
                  fontSize: isPortrait ? 84 : 104,
                  fontFamily: interFont,
                  color: COLORS.textPrimary,
                  fontWeight: 800,
                  lineHeight: 1.1,
                  letterSpacing: -1,
                  maxLines: 3,
                  style: { opacity: fadeIn(frame, 10), transform: slideIn(frame, "up", 10, 25) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subheadline,
                  fontSize: isPortrait ? 44 : 52,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  lineHeight: 1.5,
                  maxLines: 2,
                  style: { opacity: fadeIn(frame, 22) }
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    display: "grid",
                    gridTemplateColumns: isPortrait ? "1fr 1fr" : "repeat(4, 1fr)",
                    gap: isPortrait ? 20 : 32,
                    marginTop: isPortrait ? 0 : "auto"
                  },
                  children: stats.map((stat, i) => {
                    const delay = 35 + staggerDelay(i, 8);
                    const cardSpring = (0,esm.spring)({
                      frame: frame - delay,
                      fps,
                      config: { damping: 12, stiffness: 130, mass: 0.5 }
                    });
                    const isCritical = stat.value.toLowerCase().includes("critical") || stat.label === "CVSS";
                    return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                      "div",
                      {
                        style: {
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "center",
                          padding: `${14 * scale}px`,
                          borderRadius: 24,
                          background: `rgba(${isCritical ? "255,23,68" : "255,255,255"},0.04)`,
                          border: `2px solid ${isCritical ? props.primaryColor + "30" : "rgba(255,255,255,0.06)"}`,
                          gap: 8,
                          transform: `scale(${cardSpring})`,
                          opacity: fadeIn(frame, delay)
                        },
                        children: [
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: stat.label,
                              fontSize: 28 * scale,
                              fontFamily: interFont,
                              color: COLORS.textSecondary,
                              fontWeight: 500,
                              textTransform: "uppercase",
                              letterSpacing: 2
                            }
                          ),
                          /* @__PURE__ */ (0,jsx_runtime.jsx)(
                            EditableText,
                            {
                              text: stat.value,
                              fontSize: 48 * scale,
                              fontFamily: interFont,
                              color: isCritical ? props.primaryColor : "#ffffffdd",
                              fontWeight: 700
                            }
                          )
                        ]
                      },
                      i
                    );
                  })
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsxs)(
                "div",
                {
                  style: {
                    display: "flex",
                    gap: 24,
                    alignItems: "center",
                    flexWrap: isPortrait ? "wrap" : "nowrap",
                    opacity: fadeIn(frame, 70)
                  },
                  children: [
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.source,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.accent,
                        fontWeight: 600
                      }
                    ),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)("div", { style: { width: 4, height: 8, borderRadius: "50%", background: "#ffffff33" } }),
                    /* @__PURE__ */ (0,jsx_runtime.jsx)(
                      EditableText,
                      {
                        text: props.timestamp,
                        fontSize: 32 * scale,
                        fontFamily: interFont,
                        color: COLORS.textSecondary,
                        fontWeight: 400
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              right: 0,
              height: 8,
              background: `repeating-linear-gradient(
            90deg,
            ${props.primaryColor} 0px,
            ${props.primaryColor} 20px,
            ${props.accentColor} 20px,
            ${props.accentColor} 40px
          )`,
              opacity: fadeIn(frame, 0, 15)
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "tech-news-security-01",
  name: "Security Alert",
  category: "tech-news",
  description: "Critical security alert with warning stripes, pulsing border, severity cards, and danger theme",
  tags: ["security", "vulnerability", "alert", "cyber", "CVE"],
  component: TechNewsSecurity01,
  schema: techNewsSecuritySchema,
  defaultProps: techNewsSecuritySchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/text-animation/TextAnimGradient01.tsx














const textAnimGradientSchema = lib.z.object({
  line1: lib.z.string().default("Think"),
  line2: lib.z.string().default("Bigger."),
  subtitle: lib.z.string().default("Your brand deserves more than ordinary"),
  gradientStart: lib.z.string().default("#FF6B6B"),
  gradientMid: lib.z.string().default("#FECA57"),
  gradientEnd: lib.z.string().default("#48DBFB"),
  backgroundColor: lib.z.string().default(COLORS.bg)
});
const TextAnimGradient01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const { fps } = (0,esm.useVideoConfig)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const gradientAngle = (0,esm.interpolate)(frame, [0, 150], [135, 315], { extrapolateRight: "extend" });
  const line1Scale = (0,esm.spring)({
    frame: frame - 5,
    fps,
    config: { damping: 8, stiffness: 120, mass: 0.6 }
  });
  const line2Scale = (0,esm.spring)({
    frame: frame - 20,
    fps,
    config: { damping: 8, stiffness: 120, mass: 0.6 }
  });
  const subtitleOpacity = fadeIn(frame, 50, 20);
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: "50%",
              left: "50%",
              transform: "translate(-50%, -50%)",
              width: "60%",
              height: "60%",
              borderRadius: "50%",
              background: linearGradient(
                gradientAngle,
                `${props.gradientStart}15`,
                `${props.gradientMid}10`,
                `${props.gradientEnd}15`
              ),
              filter: "blur(100px)"
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              alignItems: "center",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : void 0,
              gap: 0
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    overflow: "hidden",
                    transform: `scale(${line1Scale})`
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    EditableText,
                    {
                      text: props.line1,
                      fontSize: isPortrait ? 120 : 176,
                      fontFamily: interFont,
                      color: COLORS.textPrimary,
                      fontWeight: 900,
                      textAlign: "center",
                      letterSpacing: -4,
                      lineHeight: 1.1
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                "div",
                {
                  style: {
                    overflow: "hidden",
                    transform: `scale(${line2Scale})`
                  },
                  children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
                    "div",
                    {
                      style: {
                        fontSize: isPortrait ? 90 : 150,
                        fontFamily: interFont,
                        fontWeight: 900,
                        letterSpacing: -4,
                        lineHeight: 1.1,
                        textAlign: "center",
                        backgroundImage: linearGradient(gradientAngle, props.gradientStart, props.gradientMid, props.gradientEnd),
                        WebkitBackgroundClip: "text",
                        WebkitTextFillColor: "transparent",
                        backgroundClip: "text"
                      },
                      children: props.line2
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0,jsx_runtime.jsx)(
                EditableText,
                {
                  text: props.subtitle,
                  fontSize: isPortrait ? 52 : 68,
                  fontFamily: interFont,
                  color: COLORS.textSecondary,
                  fontWeight: 400,
                  textAlign: "center",
                  style: { marginTop: 48 * scale, opacity: subtitleOpacity }
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 60], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6 * scale,
              background: linearGradient(90, props.gradientStart, props.gradientMid, props.gradientEnd)
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "text-anim-gradient-01",
  name: "Gradient Text Reveal",
  category: "text-animation",
  description: "Bold two-line text with animated gradient fill, spring entry, and shifting colors",
  tags: ["text", "gradient", "animation", "typography", "bold"],
  component: TextAnimGradient01,
  schema: textAnimGradientSchema,
  defaultProps: textAnimGradientSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/templates/text-animation/TextAnimTypewriter01.tsx













const textAnimTypewriterSchema = lib.z.object({
  line1: lib.z.string().default("We build software"),
  line2: lib.z.string().default("that changes the world."),
  cursorColor: lib.z.string().default("#536DFE"),
  primaryColor: lib.z.string().default(COLORS.accent),
  accentColor: lib.z.string().default(COLORS.accentLight),
  backgroundColor: lib.z.string().default(COLORS.bg),
  textColor: lib.z.string().default(COLORS.textPrimary)
});
const TextAnimTypewriter01 = (props) => {
  const scale = useScaleFactor();
  const frame = (0,esm.useCurrentFrame)();
  const isPortrait = useIsPortrait();
  const backgroundControls = useResolvedBackgroundControls();
  const renderBackgroundLayers = shouldRenderBackgroundLayer(backgroundControls);
  const line1Text = typewriter(frame, props.line1, 0.5, 0);
  const line2Text = typewriter(frame, props.line2, 0.5, props.line1.length * 2 + 15);
  const cursorBlink = Math.sin(frame * 0.2) > 0 ? 1 : 0;
  const isDoneLine1 = line1Text.length >= props.line1.length;
  const isDoneLine2 = line2Text.length >= props.line2.length;
  return /* @__PURE__ */ (0,jsx_runtime.jsxs)(
    esm.AbsoluteFill,
    {
      style: {
        background: resolveCanvasBackground(props.backgroundColor, backgroundControls),
        overflow: "hidden"
      },
      children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(AnimatedGradient, {}),
        renderBackgroundLayers && /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              backgroundImage: `
            linear-gradient(rgba(255,255,255,0.015) 1px, transparent 1px),
            linear-gradient(90deg, rgba(255,255,255,0.015) 1px, transparent 1px)
          `,
              backgroundSize: "80px 80px",
              opacity: fadeIn(frame, 0, 30)
            }
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsxs)(
          "div",
          {
            style: {
              position: "relative",
              zIndex: 1,
              display: "flex",
              flexDirection: "column",
              width: "100%",
              height: "100%",
              alignItems: "center",
              justifyContent: "center",
              padding: isPortrait ? "140px 80px" : "60px 120px",
              gap: 16 * scale,
              textAlign: "center"
            },
            children: [
              /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", justifyContent: "center", maxWidth: isPortrait ? "100%" : 2600 }, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "span",
                  {
                    style: {
                      fontSize: isPortrait ? 56 : 76,
                      fontFamily: interFont,
                      fontWeight: 900,
                      color: props.textColor,
                      letterSpacing: -2,
                      lineHeight: 1.2
                    },
                    children: line1Text
                  }
                ),
                !isDoneLine1 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "span",
                  {
                    style: {
                      display: "inline-block",
                      width: isPortrait ? 3 : 4,
                      height: isPortrait ? 62 : 94,
                      background: props.cursorColor,
                      marginLeft: 4 * scale,
                      opacity: cursorBlink,
                      borderRadius: 2 * scale,
                      boxShadow: `0 0 12px ${props.cursorColor}88`
                    }
                  }
                )
              ] }),
              isDoneLine1 && /* @__PURE__ */ (0,jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", justifyContent: "center", maxWidth: isPortrait ? "100%" : 2600 }, children: [
                /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "span",
                  {
                    style: {
                      fontSize: isPortrait ? 102 : 146,
                      fontFamily: interFont,
                      fontWeight: 900,
                      letterSpacing: -2,
                      lineHeight: 1.2,
                      backgroundImage: linearGradient(135, props.primaryColor, props.accentColor),
                      WebkitBackgroundClip: "text",
                      WebkitTextFillColor: "transparent",
                      backgroundClip: "text"
                    },
                    children: line2Text
                  }
                ),
                !isDoneLine2 && /* @__PURE__ */ (0,jsx_runtime.jsx)(
                  "span",
                  {
                    style: {
                      display: "inline-block",
                      width: isPortrait ? 3 : 4,
                      height: isPortrait ? 62 : 94,
                      background: props.cursorColor,
                      marginLeft: 4 * scale,
                      opacity: cursorBlink,
                      borderRadius: 2 * scale,
                      boxShadow: `0 0 12px ${props.cursorColor}88`
                    }
                  }
                )
              ] })
            ]
          }
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              bottom: 0,
              left: 0,
              width: `${(0,esm.interpolate)(frame, [0, 80], [0, 100], { extrapolateRight: "clamp" })}%`,
              height: 6 * scale,
              background: GRADIENTS.bgMain
            }
          }
        )
      ]
    }
  );
};
registerTemplate({
  id: "text-anim-typewriter-01",
  name: "Typewriter Effect",
  category: "text-animation",
  description: "Two-line typewriter text with blinking cursor, gradient second line, and grid background",
  tags: ["text", "typewriter", "animation", "cursor", "typing"],
  component: TextAnimTypewriter01,
  schema: textAnimTypewriterSchema,
  defaultProps: textAnimTypewriterSchema.parse({}),
  durationInFrames: DEFAULT_DURATION_FRAMES,
  fps: DEFAULT_FPS
});

;// ./src/Root.tsx









const backgroundControlsSchema = lib.z.object({
  showBackground: lib.z.boolean().default(true),
  transparentBackground: lib.z.boolean().default(false)
});
const withBackgroundControls = (Component) => {
  const Wrapped = ({
    showBackground = true,
    transparentBackground = false,
    ...rest
  }) => {
    const controls = {
      showBackground,
      transparentBackground
    };
    const transparentCanvas = controls.transparentBackground || !controls.showBackground;
    return /* @__PURE__ */ (0,jsx_runtime.jsx)(BackgroundControlsProvider, { value: controls, children: /* @__PURE__ */ (0,jsx_runtime.jsx)(
      "div",
      {
        style: {
          width: "100%",
          height: "100%",
          position: "relative",
          ["--template-bg"]: transparentCanvas ? "transparent" : "#0F0F0F",
          ["--template-bg-alt"]: transparentCanvas ? "transparent" : "#121212",
          ["--template-bg-mid"]: transparentCanvas ? "transparent" : "#0a1a0f"
        },
        children: /* @__PURE__ */ (0,jsx_runtime.jsx)(Component, { ...rest })
      }
    ) });
  };
  Wrapped.displayName = `WithBackgroundControls(${Component.displayName ?? Component.name ?? "Template"})`;
  return Wrapped;
};
const CATEGORY_FOLDER_NAMES = {
  "case-study": "CaseStudy",
  "business-news": "BusinessNews",
  "tech-news": "TechNews",
  "data-visualization": "DataVisualization",
  "text-animation": "TextAnimation",
  "logo-reveal": "LogoReveal",
  "social-media-promo": "SocialMediaPromo",
  "listicle-ranking": "ListicleRanking",
  "lower-thirds": "LowerThirds",
  "startup-showcase": "StartupShowcase",
  "social-hooks": "SocialHooks",
  "business-marketing": "BusinessMarketing",
  "platform-mockups": "PlatformMockups"
};
function groupByCategory(templates) {
  const grouped = getCategories().reduce(
    (acc, cat) => {
      acc[cat] = [];
      return acc;
    },
    {}
  );
  for (const t of templates) {
    if (grouped[t.category]) {
      grouped[t.category].push(t);
    }
  }
  return grouped;
}












































































































const RemotionRoot = () => {
  const registry = getTemplateRegistry();
  const grouped = groupByCategory(registry);
  return /* @__PURE__ */ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, { children: getCategories().map((category) => {
    const templates = grouped[category];
    if (templates.length === 0) return null;
    return /* @__PURE__ */ (0,jsx_runtime.jsx)(esm.Folder, { name: CATEGORY_FOLDER_NAMES[category], children: templates.map((t) => {
      const ComponentWithControls = withBackgroundControls(t.component);
      const schemaWithControls = t.schema.extend(backgroundControlsSchema.shape);
      const defaultPropsWithControls = {
        ...t.defaultProps,
        ...backgroundControlsSchema.parse({})
      };
      return /* @__PURE__ */ (0,jsx_runtime.jsxs)(react.Fragment, { children: [
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Composition,
          {
            id: `${t.id}-landscape`,
            component: ComponentWithControls,
            schema: schemaWithControls,
            defaultProps: defaultPropsWithControls,
            durationInFrames: t.durationInFrames,
            fps: t.fps,
            width: ASPECT_RATIOS.LANDSCAPE.width,
            height: ASPECT_RATIOS.LANDSCAPE.height
          },
          `${t.id}-landscape`
        ),
        /* @__PURE__ */ (0,jsx_runtime.jsx)(
          esm.Composition,
          {
            id: `${t.id}-portrait`,
            component: ComponentWithControls,
            schema: schemaWithControls,
            defaultProps: defaultPropsWithControls,
            durationInFrames: t.durationInFrames,
            fps: t.fps,
            width: ASPECT_RATIOS.PORTRAIT.width,
            height: ASPECT_RATIOS.PORTRAIT.height
          },
          `${t.id}-portrait`
        )
      ] }, t.id);
    }) }, category);
  }) });
};

;// ./src/index.ts



(0,esm.registerRoot)(RemotionRoot);


/***/ },

/***/ 6507
(__unused_webpack_module, exports) {

var __webpack_unused_export__;

// https://github.com/remotion-dev/remotion/issues/3412#issuecomment-1910120552
__webpack_unused_export__ = ({ value: true });
exports.d = void 0;
function getEnvVar() {
    const parts = ['proc', 'ess', '.', 'en', 'v', '.', 'NOD', 'E_EN', 'V'];
    return parts.join('');
}
const getEnvVariables = () => {
    if (window.remotion_isStudio) {
        // For the Studio, we already set the environment variables in index-html.ts.
        // We just add NODE_ENV here.
        if (false) // removed by dead control flow
{}
        return {
            NODE_ENV: "production",
        };
    }
    const param = window.remotion_envVariables;
    if (!param) {
        return {};
    }
    return { ...JSON.parse(param), NODE_ENV: "production" };
};
const setupEnvVariables = () => {
    const env = getEnvVariables();
    if (!window.process) {
        window.process = {};
    }
    if (!window.process.env) {
        window.process.env = {};
    }
    Object.keys(env).forEach((key) => {
        window.process.env[key] = env[key];
    });
};
setupEnvVariables();
const injected = {};
const injectCSS = (css) => {
    // Skip in node
    if (typeof document === 'undefined') {
        return;
    }
    if (injected[css]) {
        return;
    }
    const head = document.head || document.getElementsByTagName('head')[0];
    const style = document.createElement('style');
    style.appendChild(document.createTextNode(css));
    head.prepend(style);
    injected[css] = true;
};
exports.d = injectCSS;
(0, exports.d)(`
  .css-reset, .css-reset * {
    font-size: 16px;
    line-height: 1.5;
    color: white;
    font-family: Arial, Helvetica, sans-serif;
    background: transparent;
    box-sizing: border-box;
  }

  .algolia-docsearch-suggestion--highlight {
    font-size: 15px;
    line-height: 1.25;
  }

  .__remotion-info-button-container code {
    font-family: monospace;
    font-size: 14px;
    color: #0584f2
  }

  .__remotion-vertical-scrollbar::-webkit-scrollbar {
      width: 6px;
  }
  .__remotion-vertical-scrollbar::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.0);
  }
  .__remotion-vertical-scrollbar:hover::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.6);
  }
  .__remotion-vertical-scrollbar:hover::-webkit-scrollbar-thumb:hover {
    background-color: rgba(0, 0, 0, 1);
  }


  .__remotion-horizontal-scrollbar::-webkit-scrollbar {
    height: 6px;
  }
  .__remotion-horizontal-scrollbar::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.0);
  }
  .__remotion-horizontal-scrollbar:hover::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.6);
  }
  .__remotion-horizontal-scrollbar:hover::-webkit-scrollbar-thumb:hover {
    background-color: rgba(0, 0, 0, 1);
  }


  @-moz-document url-prefix() {
    .__remotion-vertical-scrollbar {
      scrollbar-width: thin;
      scrollbar-color: rgba(0, 0, 0, 0.6) rgba(0, 0, 0, 0);
    }

    .__remotion-vertical-scrollbar:hover {
      scrollbar-color: rgba(0, 0, 0, 1) rgba(0, 0, 0, 0);
    }

    .__remotion-horizontal-scrollbar {
      scrollbar-width: thin;
      scrollbar-color: rgba(0, 0, 0, 0.6) rgba(0, 0, 0, 0);
    }

    .__remotion-horizontal-scrollbar:hover {
      scrollbar-width: thin;
      scrollbar-color: rgba(0, 0, 0, 1) rgba(0, 0, 0, 0);
    }
  }


  .__remotion-timeline-slider {
    appearance: none;
    width: 100px;
    border-radius: 3px;
    height: 6px;
    background-color: rgba(255, 255, 255, 0.1);
    accent-color: #ffffff;
  }
  
  .__remotion-timeline-slider::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background-color: #ffffff;
    appearance: none;
  }
`);


/***/ },

/***/ 3610
(__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) {

var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6540);


if (typeof globalThis === 'undefined') {
	window.React = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)));
} else {
	globalThis.React = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)));
}


/***/ },

/***/ 8972
(module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4991);
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6314);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/*! tailwindcss v4.1.1 | MIT License | https://tailwindcss.com */\n@layer theme, base, components, utilities;\n@supports ((-webkit-hyphens: none) and (not (margin-trim: inline))) or ((-moz-orient: inline) and (not (color:rgb(from red r g b)))) {\n  @layer base {\n    *, ::before, ::after, ::backdrop {\n      --tw-rotate-x: rotateX(0);\n      --tw-rotate-y: rotateY(0);\n      --tw-rotate-z: rotateZ(0);\n      --tw-skew-x: skewX(0);\n      --tw-skew-y: skewY(0);\n      --tw-border-style: solid;\n      --tw-shadow: 0 0 #0000;\n      --tw-shadow-color: initial;\n      --tw-shadow-alpha: 100%;\n      --tw-inset-shadow: 0 0 #0000;\n      --tw-inset-shadow-color: initial;\n      --tw-inset-shadow-alpha: 100%;\n      --tw-ring-color: initial;\n      --tw-ring-shadow: 0 0 #0000;\n      --tw-inset-ring-color: initial;\n      --tw-inset-ring-shadow: 0 0 #0000;\n      --tw-ring-inset: initial;\n      --tw-ring-offset-width: 0px;\n      --tw-ring-offset-color: #fff;\n      --tw-ring-offset-shadow: 0 0 #0000;\n      --tw-outline-style: solid;\n      --tw-blur: initial;\n      --tw-brightness: initial;\n      --tw-contrast: initial;\n      --tw-grayscale: initial;\n      --tw-hue-rotate: initial;\n      --tw-invert: initial;\n      --tw-opacity: initial;\n      --tw-saturate: initial;\n      --tw-sepia: initial;\n      --tw-drop-shadow: initial;\n      --tw-drop-shadow-color: initial;\n      --tw-drop-shadow-alpha: 100%;\n      --tw-drop-shadow-size: initial;\n    }\n  }\n}\n@layer theme {\n  :root, :host {\n    --font-sans: ui-sans-serif, system-ui, sans-serif, \"Apple Color Emoji\",\n      \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";\n    --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,\n      \"Liberation Mono\", \"Courier New\", monospace;\n    --radius-sm: 0.25rem;\n    --radius-md: 0.375rem;\n    --radius-lg: 0.5rem;\n    --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\n    --default-transition-duration: 150ms;\n    --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n    --default-font-family: var(--font-sans);\n    --default-font-feature-settings: var(--font-sans--font-feature-settings);\n    --default-font-variation-settings: var(\n      --font-sans--font-variation-settings\n    );\n    --default-mono-font-family: var(--font-mono);\n    --default-mono-font-feature-settings: var(\n      --font-mono--font-feature-settings\n    );\n    --default-mono-font-variation-settings: var(\n      --font-mono--font-variation-settings\n    );\n  }\n}\n@layer base {\n  *, ::after, ::before, ::backdrop, ::file-selector-button {\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n    border: 0 solid;\n  }\n  html, :host {\n    line-height: 1.5;\n    -webkit-text-size-adjust: 100%;\n    tab-size: 4;\n    font-family: var( --default-font-family, ui-sans-serif, system-ui, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\" );\n    font-feature-settings: var(--default-font-feature-settings, normal);\n    font-variation-settings: var( --default-font-variation-settings, normal );\n    -webkit-tap-highlight-color: transparent;\n  }\n  body {\n    line-height: inherit;\n  }\n  hr {\n    height: 0;\n    color: inherit;\n    border-top-width: 1px;\n  }\n  abbr:where([title]) {\n    -webkit-text-decoration: underline dotted;\n    text-decoration: underline dotted;\n  }\n  h1, h2, h3, h4, h5, h6 {\n    font-size: inherit;\n    font-weight: inherit;\n  }\n  a {\n    color: inherit;\n    -webkit-text-decoration: inherit;\n    text-decoration: inherit;\n  }\n  b, strong {\n    font-weight: bolder;\n  }\n  code, kbd, samp, pre {\n    font-family: var( --default-mono-font-family, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace );\n    font-feature-settings: var( --default-mono-font-feature-settings, normal );\n    font-variation-settings: var( --default-mono-font-variation-settings, normal );\n    font-size: 1em;\n  }\n  small {\n    font-size: 80%;\n  }\n  sub, sup {\n    font-size: 75%;\n    line-height: 0;\n    position: relative;\n    vertical-align: baseline;\n  }\n  sub {\n    bottom: -0.25em;\n  }\n  sup {\n    top: -0.5em;\n  }\n  table {\n    text-indent: 0;\n    border-color: inherit;\n    border-collapse: collapse;\n  }\n  :-moz-focusring {\n    outline: auto;\n  }\n  progress {\n    vertical-align: baseline;\n  }\n  summary {\n    display: list-item;\n  }\n  ol, ul, menu {\n    list-style: none;\n  }\n  img, svg, video, canvas, audio, iframe, embed, object {\n    display: block;\n    vertical-align: middle;\n  }\n  img, video {\n    max-width: 100%;\n    height: auto;\n  }\n  button, input, select, optgroup, textarea, ::file-selector-button {\n    font: inherit;\n    font-feature-settings: inherit;\n    font-variation-settings: inherit;\n    letter-spacing: inherit;\n    color: inherit;\n    border-radius: 0;\n    background-color: transparent;\n    opacity: 1;\n  }\n  :where(select:is([multiple], [size])) optgroup {\n    font-weight: bolder;\n  }\n  :where(select:is([multiple], [size])) optgroup option {\n    padding-inline-start: 20px;\n  }\n  ::file-selector-button {\n    margin-inline-end: 4px;\n  }\n  ::placeholder {\n    opacity: 1;\n    color: color-mix(in oklab, currentColor 50%, transparent);\n  }\n  textarea {\n    resize: vertical;\n  }\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n  ::-webkit-date-and-time-value {\n    min-height: 1lh;\n    text-align: inherit;\n  }\n  ::-webkit-datetime-edit {\n    display: inline-flex;\n  }\n  ::-webkit-datetime-edit-fields-wrapper {\n    padding: 0;\n  }\n  ::-webkit-datetime-edit, ::-webkit-datetime-edit-year-field, ::-webkit-datetime-edit-month-field, ::-webkit-datetime-edit-day-field, ::-webkit-datetime-edit-hour-field, ::-webkit-datetime-edit-minute-field, ::-webkit-datetime-edit-second-field, ::-webkit-datetime-edit-millisecond-field, ::-webkit-datetime-edit-meridiem-field {\n    padding-block: 0;\n  }\n  :-moz-ui-invalid {\n    box-shadow: none;\n  }\n  button, input:where([type=\"button\"], [type=\"reset\"], [type=\"submit\"]), ::file-selector-button {\n    appearance: button;\n  }\n  ::-webkit-inner-spin-button, ::-webkit-outer-spin-button {\n    height: auto;\n  }\n  [hidden]:where(:not([hidden=\"until-found\"])) {\n    display: none !important;\n  }\n}\n@layer utilities {\n  .visible {\n    visibility: visible;\n  }\n  .absolute {\n    position: absolute;\n  }\n  .fixed {\n    position: fixed;\n  }\n  .relative {\n    position: relative;\n  }\n  .static {\n    position: static;\n  }\n  .sticky {\n    position: sticky;\n  }\n  .isolate {\n    isolation: isolate;\n  }\n  .container {\n    width: 100%;\n    @media (width >= 40rem) {\n      max-width: 40rem;\n    }\n    @media (width >= 48rem) {\n      max-width: 48rem;\n    }\n    @media (width >= 64rem) {\n      max-width: 64rem;\n    }\n    @media (width >= 80rem) {\n      max-width: 80rem;\n    }\n    @media (width >= 96rem) {\n      max-width: 96rem;\n    }\n  }\n  .block {\n    display: block;\n  }\n  .contents {\n    display: contents;\n  }\n  .flex {\n    display: flex;\n  }\n  .grid {\n    display: grid;\n  }\n  .hidden {\n    display: none;\n  }\n  .inline {\n    display: inline;\n  }\n  .inline-block {\n    display: inline-block;\n  }\n  .inline-flex {\n    display: inline-flex;\n  }\n  .table {\n    display: table;\n  }\n  .grow {\n    flex-grow: 1;\n  }\n  .transform {\n    transform: var(--tw-rotate-x) var(--tw-rotate-y) var(--tw-rotate-z) var(--tw-skew-x) var(--tw-skew-y);\n  }\n  .rounded {\n    border-radius: 0.25rem;\n  }\n  .border {\n    border-style: var(--tw-border-style);\n    border-width: 1px;\n  }\n  .break-all {\n    word-break: break-all;\n  }\n  .capitalize {\n    text-transform: capitalize;\n  }\n  .uppercase {\n    text-transform: uppercase;\n  }\n  .italic {\n    font-style: italic;\n  }\n  .line-through {\n    text-decoration-line: line-through;\n  }\n  .underline {\n    text-decoration-line: underline;\n  }\n  .shadow {\n    --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 1px 2px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n  .ring {\n    --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentColor);\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n  .outline {\n    outline-style: var(--tw-outline-style);\n    outline-width: 1px;\n  }\n  .blur {\n    --tw-blur: blur(8px);\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\n  }\n  .grayscale {\n    --tw-grayscale: grayscale(100%);\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\n  }\n  .filter {\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\n  }\n  .transition {\n    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, -webkit-backdrop-filter, backdrop-filter;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n  .\\[clean\\:workspace\\] {\n    clean: workspace;\n  }\n  .\\[templates\\:check\\] {\n    templates: check;\n  }\n}\n@property --tw-rotate-x {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: rotateX(0);\n}\n@property --tw-rotate-y {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: rotateY(0);\n}\n@property --tw-rotate-z {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: rotateZ(0);\n}\n@property --tw-skew-x {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: skewX(0);\n}\n@property --tw-skew-y {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: skewY(0);\n}\n@property --tw-border-style {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: solid;\n}\n@property --tw-shadow {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-shadow-color {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-shadow-alpha {\n  syntax: \"<percentage>\";\n  inherits: false;\n  initial-value: 100%;\n}\n@property --tw-inset-shadow {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-inset-shadow-color {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-inset-shadow-alpha {\n  syntax: \"<percentage>\";\n  inherits: false;\n  initial-value: 100%;\n}\n@property --tw-ring-color {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-ring-shadow {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-inset-ring-color {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-inset-ring-shadow {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-ring-inset {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-ring-offset-width {\n  syntax: \"<length>\";\n  inherits: false;\n  initial-value: 0px;\n}\n@property --tw-ring-offset-color {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: #fff;\n}\n@property --tw-ring-offset-shadow {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-outline-style {\n  syntax: \"*\";\n  inherits: false;\n  initial-value: solid;\n}\n@property --tw-blur {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-brightness {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-contrast {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-grayscale {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-hue-rotate {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-invert {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-opacity {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-saturate {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-sepia {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-drop-shadow {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-drop-shadow-color {\n  syntax: \"*\";\n  inherits: false;\n}\n@property --tw-drop-shadow-alpha {\n  syntax: \"<percentage>\";\n  inherits: false;\n  initial-value: 100%;\n}\n@property --tw-drop-shadow-size {\n  syntax: \"*\";\n  inherits: false;\n}\n", "",{"version":3,"sources":["webpack://./src/index.css"],"names":[],"mappings":"AAAA,gEACA;AADA,yCACA;AADA;EAAA;IAAA;MAAA,yBACA;MADA,yBACA;MADA,yBACA;MADA,qBACA;MADA,qBACA;MADA,wBACA;MADA,sBACA;MADA,0BACA;MADA,uBACA;MADA,4BACA;MADA,gCACA;MADA,6BACA;MADA,wBACA;MADA,2BACA;MADA,8BACA;MADA,iCACA;MADA,wBACA;MADA,2BACA;MADA,4BACA;MADA,kCACA;MADA,yBACA;MADA,kBACA;MADA,wBACA;MADA,sBACA;MADA,uBACA;MADA,wBACA;MADA,oBACA;MADA,qBACA;MADA,sBACA;MADA,mBACA;MADA,yBACA;MADA,+BACA;MADA,4BACA;MADA,8BACA;IAAA;EAAA;AAAA;AADA;EAAA;IAAA;6DACA;IADA;iDACA;IADA,oBACA;IADA,qBACA;IADA,mBACA;IADA,0EACA;IADA,oCACA;IADA,kEACA;IADA,uCACA;IADA,wEACA;IADA;;KACA;IADA,4CACA;IADA;;KACA;IADA;;KACA;EAAA;AAAA;AADA;EAAA;IAAA,sBACA;IADA,SACA;IADA,UACA;IADA,eACA;EAAA;EADA;IAAA,gBACA;IADA,8BACA;IADA,WACA;IADA,6JACA;IADA,mEACA;IADA,yEACA;IADA,wCACA;EAAA;EADA;IAAA,oBACA;EAAA;EADA;IAAA,SACA;IADA,cACA;IADA,qBACA;EAAA;EADA;IAAA,yCACA;IADA,iCACA;EAAA;EADA;IAAA,kBACA;IADA,oBACA;EAAA;EADA;IAAA,cACA;IADA,gCACA;IADA,wBACA;EAAA;EADA;IAAA,mBACA;EAAA;EADA;IAAA,kJACA;IADA,0EACA;IADA,8EACA;IADA,cACA;EAAA;EADA;IAAA,cACA;EAAA;EADA;IAAA,cACA;IADA,cACA;IADA,kBACA;IADA,wBACA;EAAA;EADA;IAAA,eACA;EAAA;EADA;IAAA,WACA;EAAA;EADA;IAAA,cACA;IADA,qBACA;IADA,yBACA;EAAA;EADA;IAAA,aACA;EAAA;EADA;IAAA,wBACA;EAAA;EADA;IAAA,kBACA;EAAA;EADA;IAAA,gBACA;EAAA;EADA;IAAA,cACA;IADA,sBACA;EAAA;EADA;IAAA,eACA;IADA,YACA;EAAA;EADA;IAAA,aACA;IADA,8BACA;IADA,gCACA;IADA,uBACA;IADA,cACA;IADA,gBACA;IADA,6BACA;IADA,UACA;EAAA;EADA;IAAA,mBACA;EAAA;EADA;IAAA,0BACA;EAAA;EADA;IAAA,sBACA;EAAA;EADA;IAAA,UACA;IADA,yDACA;EAAA;EADA;IAAA,gBACA;EAAA;EADA;IAAA,wBACA;EAAA;EADA;IAAA,eACA;IADA,mBACA;EAAA;EADA;IAAA,oBACA;EAAA;EADA;IAAA,UACA;EAAA;EADA;IAAA,gBACA;EAAA;EADA;IAAA,gBACA;EAAA;EADA;IAAA,kBACA;EAAA;EADA;IAAA,YACA;EAAA;EADA;IAAA,wBACA;EAAA;AAAA;AADA;EAAA;IAAA,mBACA;EAAA;EADA;IAAA,kBACA;EAAA;EADA;IAAA,eACA;EAAA;EADA;IAAA,kBACA;EAAA;EADA;IAAA,gBACA;EAAA;EADA;IAAA,gBACA;EAAA;EADA;IAAA,kBACA;EAAA;EADA;IAAA,WACA;IADA;MAAA,gBACA;IAAA;IADA;MAAA,gBACA;IAAA;IADA;MAAA,gBACA;IAAA;IADA;MAAA,gBACA;IAAA;IADA;MAAA,gBACA;IAAA;EAAA;EADA;IAAA,cACA;EAAA;EADA;IAAA,iBACA;EAAA;EADA;IAAA,aACA;EAAA;EADA;IAAA,aACA;EAAA;EADA;IAAA,aACA;EAAA;EADA;IAAA,eACA;EAAA;EADA;IAAA,qBACA;EAAA;EADA;IAAA,oBACA;EAAA;EADA;IAAA,cACA;EAAA;EADA;IAAA,YACA;EAAA;EADA;IAAA,qGACA;EAAA;EADA;IAAA,sBACA;EAAA;EADA;IAAA,oCACA;IADA,iBACA;EAAA;EADA;IAAA,qBACA;EAAA;EADA;IAAA,0BACA;EAAA;EADA;IAAA,yBACA;EAAA;EADA;IAAA,kBACA;EAAA;EADA;IAAA,kCACA;EAAA;EADA;IAAA,+BACA;EAAA;EADA;IAAA,0HACA;IADA,sIACA;EAAA;EADA;IAAA,wHACA;IADA,sIACA;EAAA;EADA;IAAA,sCACA;IADA,kBACA;EAAA;EADA;IAAA,oBACA;IADA,0LACA;EAAA;EADA;IAAA,+BACA;IADA,0LACA;EAAA;EADA;IAAA,0LACA;EAAA;EADA;IAAA,mRACA;IADA,qFACA;IADA,2EACA;EAAA;EADA;IAAA,gBACA;EAAA;EADA;IAAA,gBACA;EAAA;AAAA;AADA;EAAA,WACA;EADA,eACA;EADA,yBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;EADA,yBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;EADA,yBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;EADA,uBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;EADA,uBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;EADA,oBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;EADA,wBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,sBACA;EADA,eACA;EADA,mBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;EADA,wBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,sBACA;EADA,eACA;EADA,mBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,WACA;EADA,eACA;EADA,wBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,WACA;EADA,eACA;EADA,wBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,kBACA;EADA,eACA;EADA,kBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;EADA,mBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;EADA,wBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;EADA,oBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA;AADA;EAAA,sBACA;EADA,eACA;EADA,mBACA;AAAA;AADA;EAAA,WACA;EADA,eACA;AAAA","sourcesContent":["@import \"tailwindcss\";\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ },

/***/ 6314
(module) {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join("");
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === "string") {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, ""]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ },

/***/ 4991
(module) {



function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

module.exports = function cssWithMappingToString(item) {
  var _item = _slicedToArray(item, 4),
      content = _item[1],
      cssMapping = _item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    // eslint-disable-next-line no-undef
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ },

/***/ 1247
(__unused_webpack_module, exports, __webpack_require__) {

/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/

var Scheduler = __webpack_require__(9982),
  React = __webpack_require__(6540),
  ReactDOM = __webpack_require__(961);
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return (
    "Minified React error #" +
    code +
    "; visit " +
    url +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
function isValidContainer(node) {
  return !(
    !node ||
    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
  );
}
function getNearestMountedFiber(fiber) {
  var node = fiber,
    nearestMounted = fiber;
  if (fiber.alternate) for (; node.return; ) node = node.return;
  else {
    fiber = node;
    do
      (node = fiber),
        0 !== (node.flags & 4098) && (nearestMounted = node.return),
        (fiber = node.return);
    while (fiber);
  }
  return 3 === node.tag ? nearestMounted : null;
}
function getSuspenseInstanceFromFiber(fiber) {
  if (13 === fiber.tag) {
    var suspenseState = fiber.memoizedState;
    null === suspenseState &&
      ((fiber = fiber.alternate),
      null !== fiber && (suspenseState = fiber.memoizedState));
    if (null !== suspenseState) return suspenseState.dehydrated;
  }
  return null;
}
function getActivityInstanceFromFiber(fiber) {
  if (31 === fiber.tag) {
    var activityState = fiber.memoizedState;
    null === activityState &&
      ((fiber = fiber.alternate),
      null !== fiber && (activityState = fiber.memoizedState));
    if (null !== activityState) return activityState.dehydrated;
  }
  return null;
}
function assertIsMounted(fiber) {
  if (getNearestMountedFiber(fiber) !== fiber)
    throw Error(formatProdErrorMessage(188));
}
function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    alternate = getNearestMountedFiber(fiber);
    if (null === alternate) throw Error(formatProdErrorMessage(188));
    return alternate !== fiber ? null : fiber;
  }
  for (var a = fiber, b = alternate; ; ) {
    var parentA = a.return;
    if (null === parentA) break;
    var parentB = parentA.alternate;
    if (null === parentB) {
      b = parentA.return;
      if (null !== b) {
        a = b;
        continue;
      }
      break;
    }
    if (parentA.child === parentB.child) {
      for (parentB = parentA.child; parentB; ) {
        if (parentB === a) return assertIsMounted(parentA), fiber;
        if (parentB === b) return assertIsMounted(parentA), alternate;
        parentB = parentB.sibling;
      }
      throw Error(formatProdErrorMessage(188));
    }
    if (a.return !== b.return) (a = parentA), (b = parentB);
    else {
      for (var didFindChild = !1, child$0 = parentA.child; child$0; ) {
        if (child$0 === a) {
          didFindChild = !0;
          a = parentA;
          b = parentB;
          break;
        }
        if (child$0 === b) {
          didFindChild = !0;
          b = parentA;
          a = parentB;
          break;
        }
        child$0 = child$0.sibling;
      }
      if (!didFindChild) {
        for (child$0 = parentB.child; child$0; ) {
          if (child$0 === a) {
            didFindChild = !0;
            a = parentB;
            b = parentA;
            break;
          }
          if (child$0 === b) {
            didFindChild = !0;
            b = parentB;
            a = parentA;
            break;
          }
          child$0 = child$0.sibling;
        }
        if (!didFindChild) throw Error(formatProdErrorMessage(189));
      }
    }
    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
  }
  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
  return a.stateNode.current === a ? fiber : alternate;
}
function findCurrentHostFiberImpl(node) {
  var tag = node.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
  for (node = node.child; null !== node; ) {
    tag = findCurrentHostFiberImpl(node);
    if (null !== tag) return tag;
    node = node.sibling;
  }
  return null;
}
var assign = Object.assign,
  REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
  REACT_MEMO_TYPE = Symbol.for("react.memo"),
  REACT_LAZY_TYPE = Symbol.for("react.lazy");
Symbol.for("react.scope");
var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
Symbol.for("react.legacy_hidden");
Symbol.for("react.tracing_marker");
var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
Symbol.for("react.view_transition");
var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable =
    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
    maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
function getComponentNameFromType(type) {
  if (null == type) return null;
  if ("function" === typeof type)
    return type.$$typeof === REACT_CLIENT_REFERENCE
      ? null
      : type.displayName || type.name || null;
  if ("string" === typeof type) return type;
  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return "Fragment";
    case REACT_PROFILER_TYPE:
      return "Profiler";
    case REACT_STRICT_MODE_TYPE:
      return "StrictMode";
    case REACT_SUSPENSE_TYPE:
      return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
      return "SuspenseList";
    case REACT_ACTIVITY_TYPE:
      return "Activity";
  }
  if ("object" === typeof type)
    switch (type.$$typeof) {
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_CONTEXT_TYPE:
        return type.displayName || "Context";
      case REACT_CONSUMER_TYPE:
        return (type._context.displayName || "Context") + ".Consumer";
      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type ||
          ((type = innerType.displayName || innerType.name || ""),
          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
        return type;
      case REACT_MEMO_TYPE:
        return (
          (innerType = type.displayName || null),
          null !== innerType
            ? innerType
            : getComponentNameFromType(type.type) || "Memo"
        );
      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;
        try {
          return getComponentNameFromType(type(innerType));
        } catch (x) {}
    }
  return null;
}
var isArrayImpl = Array.isArray,
  ReactSharedInternals =
    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
  ReactDOMSharedInternals =
    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
  sharedNotPendingObject = {
    pending: !1,
    data: null,
    method: null,
    action: null
  },
  valueStack = [],
  index = -1;
function createCursor(defaultValue) {
  return { current: defaultValue };
}
function pop(cursor) {
  0 > index ||
    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);
}
function push(cursor, value) {
  index++;
  valueStack[index] = cursor.current;
  cursor.current = value;
}
var contextStackCursor = createCursor(null),
  contextFiberStackCursor = createCursor(null),
  rootInstanceStackCursor = createCursor(null),
  hostTransitionProviderCursor = createCursor(null);
function pushHostContainer(fiber, nextRootInstance) {
  push(rootInstanceStackCursor, nextRootInstance);
  push(contextFiberStackCursor, fiber);
  push(contextStackCursor, null);
  switch (nextRootInstance.nodeType) {
    case 9:
    case 11:
      fiber = (fiber = nextRootInstance.documentElement)
        ? (fiber = fiber.namespaceURI)
          ? getOwnHostContext(fiber)
          : 0
        : 0;
      break;
    default:
      if (
        ((fiber = nextRootInstance.tagName),
        (nextRootInstance = nextRootInstance.namespaceURI))
      )
        (nextRootInstance = getOwnHostContext(nextRootInstance)),
          (fiber = getChildHostContextProd(nextRootInstance, fiber));
      else
        switch (fiber) {
          case "svg":
            fiber = 1;
            break;
          case "math":
            fiber = 2;
            break;
          default:
            fiber = 0;
        }
  }
  pop(contextStackCursor);
  push(contextStackCursor, fiber);
}
function popHostContainer() {
  pop(contextStackCursor);
  pop(contextFiberStackCursor);
  pop(rootInstanceStackCursor);
}
function pushHostContext(fiber) {
  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
  var context = contextStackCursor.current;
  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
  context !== JSCompiler_inline_result &&
    (push(contextFiberStackCursor, fiber),
    push(contextStackCursor, JSCompiler_inline_result));
}
function popHostContext(fiber) {
  contextFiberStackCursor.current === fiber &&
    (pop(contextStackCursor), pop(contextFiberStackCursor));
  hostTransitionProviderCursor.current === fiber &&
    (pop(hostTransitionProviderCursor),
    (HostTransitionContext._currentValue = sharedNotPendingObject));
}
var prefix, suffix;
function describeBuiltInComponentFrame(name) {
  if (void 0 === prefix)
    try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = (match && match[1]) || "";
      suffix =
        -1 < x.stack.indexOf("\n    at")
          ? " (<anonymous>)"
          : -1 < x.stack.indexOf("@")
            ? "@unknown:0:0"
            : "";
    }
  return "\n" + prefix + name + suffix;
}
var reentry = !1;
function describeNativeComponentFrame(fn, construct) {
  if (!fn || reentry) return "";
  reentry = !0;
  var previousPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    var RunInRootFrame = {
      DetermineComponentFrameRoot: function () {
        try {
          if (construct) {
            var Fake = function () {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function () {
                throw Error();
              }
            });
            if ("object" === typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                var control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x$1) {
                control = x$1;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x$2) {
              control = x$2;
            }
            (Fake = fn()) &&
              "function" === typeof Fake.catch &&
              Fake.catch(function () {});
          }
        } catch (sample) {
          if (sample && control && "string" === typeof sample.stack)
            return [sample.stack, control.stack];
        }
        return [null, null];
      }
    };
    RunInRootFrame.DetermineComponentFrameRoot.displayName =
      "DetermineComponentFrameRoot";
    var namePropDescriptor = Object.getOwnPropertyDescriptor(
      RunInRootFrame.DetermineComponentFrameRoot,
      "name"
    );
    namePropDescriptor &&
      namePropDescriptor.configurable &&
      Object.defineProperty(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
      sampleStack = _RunInRootFrame$Deter[0],
      controlStack = _RunInRootFrame$Deter[1];
    if (sampleStack && controlStack) {
      var sampleLines = sampleStack.split("\n"),
        controlLines = controlStack.split("\n");
      for (
        namePropDescriptor = RunInRootFrame = 0;
        RunInRootFrame < sampleLines.length &&
        !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");

      )
        RunInRootFrame++;
      for (
        ;
        namePropDescriptor < controlLines.length &&
        !controlLines[namePropDescriptor].includes(
          "DetermineComponentFrameRoot"
        );

      )
        namePropDescriptor++;
      if (
        RunInRootFrame === sampleLines.length ||
        namePropDescriptor === controlLines.length
      )
        for (
          RunInRootFrame = sampleLines.length - 1,
            namePropDescriptor = controlLines.length - 1;
          1 <= RunInRootFrame &&
          0 <= namePropDescriptor &&
          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];

        )
          namePropDescriptor--;
      for (
        ;
        1 <= RunInRootFrame && 0 <= namePropDescriptor;
        RunInRootFrame--, namePropDescriptor--
      )
        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
            do
              if (
                (RunInRootFrame--,
                namePropDescriptor--,
                0 > namePropDescriptor ||
                  sampleLines[RunInRootFrame] !==
                    controlLines[namePropDescriptor])
              ) {
                var frame =
                  "\n" +
                  sampleLines[RunInRootFrame].replace(" at new ", " at ");
                fn.displayName &&
                  frame.includes("<anonymous>") &&
                  (frame = frame.replace("<anonymous>", fn.displayName));
                return frame;
              }
            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
          }
          break;
        }
    }
  } finally {
    (reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace);
  }
  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "")
    ? describeBuiltInComponentFrame(previousPrepareStackTrace)
    : "";
}
function describeFiber(fiber, childFiber) {
  switch (fiber.tag) {
    case 26:
    case 27:
    case 5:
      return describeBuiltInComponentFrame(fiber.type);
    case 16:
      return describeBuiltInComponentFrame("Lazy");
    case 13:
      return fiber.child !== childFiber && null !== childFiber
        ? describeBuiltInComponentFrame("Suspense Fallback")
        : describeBuiltInComponentFrame("Suspense");
    case 19:
      return describeBuiltInComponentFrame("SuspenseList");
    case 0:
    case 15:
      return describeNativeComponentFrame(fiber.type, !1);
    case 11:
      return describeNativeComponentFrame(fiber.type.render, !1);
    case 1:
      return describeNativeComponentFrame(fiber.type, !0);
    case 31:
      return describeBuiltInComponentFrame("Activity");
    default:
      return "";
  }
}
function getStackByFiberInDevAndProd(workInProgress) {
  try {
    var info = "",
      previous = null;
    do
      (info += describeFiber(workInProgress, previous)),
        (previous = workInProgress),
        (workInProgress = workInProgress.return);
    while (workInProgress);
    return info;
  } catch (x) {
    return "\nError generating stack: " + x.message + "\n" + x.stack;
  }
}
var hasOwnProperty = Object.prototype.hasOwnProperty,
  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
  cancelCallback$1 = Scheduler.unstable_cancelCallback,
  shouldYield = Scheduler.unstable_shouldYield,
  requestPaint = Scheduler.unstable_requestPaint,
  now = Scheduler.unstable_now,
  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
  ImmediatePriority = Scheduler.unstable_ImmediatePriority,
  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
  NormalPriority$1 = Scheduler.unstable_NormalPriority,
  LowPriority = Scheduler.unstable_LowPriority,
  IdlePriority = Scheduler.unstable_IdlePriority,
  log$1 = Scheduler.log,
  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
  rendererID = null,
  injectedHook = null;
function setIsStrictModeForDevtools(newIsStrictMode) {
  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
  if (injectedHook && "function" === typeof injectedHook.setStrictMode)
    try {
      injectedHook.setStrictMode(rendererID, newIsStrictMode);
    } catch (err) {}
}
var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
  log = Math.log,
  LN2 = Math.LN2;
function clz32Fallback(x) {
  x >>>= 0;
  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
}
var nextTransitionUpdateLane = 256,
  nextTransitionDeferredLane = 262144,
  nextRetryLane = 4194304;
function getHighestPriorityLanes(lanes) {
  var pendingSyncLanes = lanes & 42;
  if (0 !== pendingSyncLanes) return pendingSyncLanes;
  switch (lanes & -lanes) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
      return 64;
    case 128:
      return 128;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
      return lanes & 261888;
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return lanes & 3932160;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return lanes & 62914560;
    case 67108864:
      return 67108864;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 0;
    default:
      return lanes;
  }
}
function getNextLanes(root, wipLanes, rootHasPendingCommit) {
  var pendingLanes = root.pendingLanes;
  if (0 === pendingLanes) return 0;
  var nextLanes = 0,
    suspendedLanes = root.suspendedLanes,
    pingedLanes = root.pingedLanes;
  root = root.warmLanes;
  var nonIdlePendingLanes = pendingLanes & 134217727;
  0 !== nonIdlePendingLanes
    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
      0 !== pendingLanes
        ? (nextLanes = getHighestPriorityLanes(pendingLanes))
        : ((pingedLanes &= nonIdlePendingLanes),
          0 !== pingedLanes
            ? (nextLanes = getHighestPriorityLanes(pingedLanes))
            : rootHasPendingCommit ||
              ((rootHasPendingCommit = nonIdlePendingLanes & ~root),
              0 !== rootHasPendingCommit &&
                (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))))
    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
      0 !== nonIdlePendingLanes
        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
        : 0 !== pingedLanes
          ? (nextLanes = getHighestPriorityLanes(pingedLanes))
          : rootHasPendingCommit ||
            ((rootHasPendingCommit = pendingLanes & ~root),
            0 !== rootHasPendingCommit &&
              (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
  return 0 === nextLanes
    ? 0
    : 0 !== wipLanes &&
        wipLanes !== nextLanes &&
        0 === (wipLanes & suspendedLanes) &&
        ((suspendedLanes = nextLanes & -nextLanes),
        (rootHasPendingCommit = wipLanes & -wipLanes),
        suspendedLanes >= rootHasPendingCommit ||
          (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))
      ? wipLanes
      : nextLanes;
}
function checkIfRootIsPrerendering(root, renderLanes) {
  return (
    0 ===
    (root.pendingLanes &
      ~(root.suspendedLanes & ~root.pingedLanes) &
      renderLanes)
  );
}
function computeExpirationTime(lane, currentTime) {
  switch (lane) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 64:
      return currentTime + 250;
    case 16:
    case 32:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return currentTime + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return -1;
    case 67108864:
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function claimNextRetryLane() {
  var lane = nextRetryLane;
  nextRetryLane <<= 1;
  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
  return lane;
}
function createLaneMap(initial) {
  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
  return laneMap;
}
function markRootUpdated$1(root, updateLane) {
  root.pendingLanes |= updateLane;
  268435456 !== updateLane &&
    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));
}
function markRootFinished(
  root,
  finishedLanes,
  remainingLanes,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes
) {
  var previouslyPendingLanes = root.pendingLanes;
  root.pendingLanes = remainingLanes;
  root.suspendedLanes = 0;
  root.pingedLanes = 0;
  root.warmLanes = 0;
  root.expiredLanes &= remainingLanes;
  root.entangledLanes &= remainingLanes;
  root.errorRecoveryDisabledLanes &= remainingLanes;
  root.shellSuspendCounter = 0;
  var entanglements = root.entanglements,
    expirationTimes = root.expirationTimes,
    hiddenUpdates = root.hiddenUpdates;
  for (
    remainingLanes = previouslyPendingLanes & ~remainingLanes;
    0 < remainingLanes;

  ) {
    var index$7 = 31 - clz32(remainingLanes),
      lane = 1 << index$7;
    entanglements[index$7] = 0;
    expirationTimes[index$7] = -1;
    var hiddenUpdatesForLane = hiddenUpdates[index$7];
    if (null !== hiddenUpdatesForLane)
      for (
        hiddenUpdates[index$7] = null, index$7 = 0;
        index$7 < hiddenUpdatesForLane.length;
        index$7++
      ) {
        var update = hiddenUpdatesForLane[index$7];
        null !== update && (update.lane &= -536870913);
      }
    remainingLanes &= ~lane;
  }
  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
  0 !== suspendedRetryLanes &&
    0 === updatedLanes &&
    0 !== root.tag &&
    (root.suspendedLanes |=
      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
}
function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
  root.pendingLanes |= spawnedLane;
  root.suspendedLanes &= ~spawnedLane;
  var spawnedLaneIndex = 31 - clz32(spawnedLane);
  root.entangledLanes |= spawnedLane;
  root.entanglements[spawnedLaneIndex] =
    root.entanglements[spawnedLaneIndex] |
    1073741824 |
    (entangledLanes & 261930);
}
function markRootEntangled(root, entangledLanes) {
  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
  for (root = root.entanglements; rootEntangledLanes; ) {
    var index$8 = 31 - clz32(rootEntangledLanes),
      lane = 1 << index$8;
    (lane & entangledLanes) | (root[index$8] & entangledLanes) &&
      (root[index$8] |= entangledLanes);
    rootEntangledLanes &= ~lane;
  }
}
function getBumpedLaneForHydration(root, renderLanes) {
  var renderLane = renderLanes & -renderLanes;
  renderLane =
    0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
  return 0 !== (renderLane & (root.suspendedLanes | renderLanes))
    ? 0
    : renderLane;
}
function getBumpedLaneForHydrationByLane(lane) {
  switch (lane) {
    case 2:
      lane = 1;
      break;
    case 8:
      lane = 4;
      break;
    case 32:
      lane = 16;
      break;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      lane = 128;
      break;
    case 268435456:
      lane = 134217728;
      break;
    default:
      lane = 0;
  }
  return lane;
}
function lanesToEventPriority(lanes) {
  lanes &= -lanes;
  return 2 < lanes
    ? 8 < lanes
      ? 0 !== (lanes & 134217727)
        ? 32
        : 268435456
      : 8
    : 2;
}
function resolveUpdatePriority() {
  var updatePriority = ReactDOMSharedInternals.p;
  if (0 !== updatePriority) return updatePriority;
  updatePriority = window.event;
  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
}
function runWithPriority(priority, fn) {
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    return (ReactDOMSharedInternals.p = priority), fn();
  } finally {
    ReactDOMSharedInternals.p = previousPriority;
  }
}
var randomKey = Math.random().toString(36).slice(2),
  internalInstanceKey = "__reactFiber$" + randomKey,
  internalPropsKey = "__reactProps$" + randomKey,
  internalContainerInstanceKey = "__reactContainer$" + randomKey,
  internalEventHandlersKey = "__reactEvents$" + randomKey,
  internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
  internalEventHandlesSetKey = "__reactHandles$" + randomKey,
  internalRootNodeResourcesKey = "__reactResources$" + randomKey,
  internalHoistableMarker = "__reactMarker$" + randomKey;
function detachDeletedInstance(node) {
  delete node[internalInstanceKey];
  delete node[internalPropsKey];
  delete node[internalEventHandlersKey];
  delete node[internalEventHandlerListenersKey];
  delete node[internalEventHandlesSetKey];
}
function getClosestInstanceFromNode(targetNode) {
  var targetInst = targetNode[internalInstanceKey];
  if (targetInst) return targetInst;
  for (var parentNode = targetNode.parentNode; parentNode; ) {
    if (
      (targetInst =
        parentNode[internalContainerInstanceKey] ||
        parentNode[internalInstanceKey])
    ) {
      parentNode = targetInst.alternate;
      if (
        null !== targetInst.child ||
        (null !== parentNode && null !== parentNode.child)
      )
        for (
          targetNode = getParentHydrationBoundary(targetNode);
          null !== targetNode;

        ) {
          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;
          targetNode = getParentHydrationBoundary(targetNode);
        }
      return targetInst;
    }
    targetNode = parentNode;
    parentNode = targetNode.parentNode;
  }
  return null;
}
function getInstanceFromNode(node) {
  if (
    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
  ) {
    var tag = node.tag;
    if (
      5 === tag ||
      6 === tag ||
      13 === tag ||
      31 === tag ||
      26 === tag ||
      27 === tag ||
      3 === tag
    )
      return node;
  }
  return null;
}
function getNodeFromInstance(inst) {
  var tag = inst.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
  throw Error(formatProdErrorMessage(33));
}
function getResourcesFromRoot(root) {
  var resources = root[internalRootNodeResourcesKey];
  resources ||
    (resources = root[internalRootNodeResourcesKey] =
      { hoistableStyles: new Map(), hoistableScripts: new Map() });
  return resources;
}
function markNodeAsHoistable(node) {
  node[internalHoistableMarker] = !0;
}
var allNativeEvents = new Set(),
  registrationNameDependencies = {};
function registerTwoPhaseEvent(registrationName, dependencies) {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + "Capture", dependencies);
}
function registerDirectEvent(registrationName, dependencies) {
  registrationNameDependencies[registrationName] = dependencies;
  for (
    registrationName = 0;
    registrationName < dependencies.length;
    registrationName++
  )
    allNativeEvents.add(dependencies[registrationName]);
}
var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ),
  illegalAttributeNameCache = {},
  validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
    return !0;
  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
    return (validatedAttributeNameCache[attributeName] = !0);
  illegalAttributeNameCache[attributeName] = !0;
  return !1;
}
function setValueForAttribute(node, name, value) {
  if (isAttributeNameSafe(name))
    if (null === value) node.removeAttribute(name);
    else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
          node.removeAttribute(name);
          return;
        case "boolean":
          var prefix$10 = name.toLowerCase().slice(0, 5);
          if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
            node.removeAttribute(name);
            return;
          }
      }
      node.setAttribute(name, "" + value);
    }
}
function setValueForKnownAttribute(node, name, value) {
  if (null === value) node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttribute(name, "" + value);
  }
}
function setValueForNamespacedAttribute(node, namespace, name, value) {
  if (null === value) node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttributeNS(namespace, name, "" + value);
  }
}
function getToStringValue(value) {
  switch (typeof value) {
    case "bigint":
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return value;
    case "object":
      return value;
    default:
      return "";
  }
}
function isCheckable(elem) {
  var type = elem.type;
  return (
    (elem = elem.nodeName) &&
    "input" === elem.toLowerCase() &&
    ("checkbox" === type || "radio" === type)
  );
}
function trackValueOnNode(node, valueField, currentValue) {
  var descriptor = Object.getOwnPropertyDescriptor(
    node.constructor.prototype,
    valueField
  );
  if (
    !node.hasOwnProperty(valueField) &&
    "undefined" !== typeof descriptor &&
    "function" === typeof descriptor.get &&
    "function" === typeof descriptor.set
  ) {
    var get = descriptor.get,
      set = descriptor.set;
    Object.defineProperty(node, valueField, {
      configurable: !0,
      get: function () {
        return get.call(this);
      },
      set: function (value) {
        currentValue = "" + value;
        set.call(this, value);
      }
    });
    Object.defineProperty(node, valueField, {
      enumerable: descriptor.enumerable
    });
    return {
      getValue: function () {
        return currentValue;
      },
      setValue: function (value) {
        currentValue = "" + value;
      },
      stopTracking: function () {
        node._valueTracker = null;
        delete node[valueField];
      }
    };
  }
}
function track(node) {
  if (!node._valueTracker) {
    var valueField = isCheckable(node) ? "checked" : "value";
    node._valueTracker = trackValueOnNode(
      node,
      valueField,
      "" + node[valueField]
    );
  }
}
function updateValueIfChanged(node) {
  if (!node) return !1;
  var tracker = node._valueTracker;
  if (!tracker) return !0;
  var lastValue = tracker.getValue();
  var value = "";
  node &&
    (value = isCheckable(node)
      ? node.checked
        ? "true"
        : "false"
      : node.value);
  node = value;
  return node !== lastValue ? (tracker.setValue(node), !0) : !1;
}
function getActiveElement(doc) {
  doc = doc || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof doc) return null;
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}
var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
  return value.replace(
    escapeSelectorAttributeValueInsideDoubleQuotesRegex,
    function (ch) {
      return "\\" + ch.charCodeAt(0).toString(16) + " ";
    }
  );
}
function updateInput(
  element,
  value,
  defaultValue,
  lastDefaultValue,
  checked,
  defaultChecked,
  type,
  name
) {
  element.name = "";
  null != type &&
  "function" !== typeof type &&
  "symbol" !== typeof type &&
  "boolean" !== typeof type
    ? (element.type = type)
    : element.removeAttribute("type");
  if (null != value)
    if ("number" === type) {
      if ((0 === value && "" === element.value) || element.value != value)
        element.value = "" + getToStringValue(value);
    } else
      element.value !== "" + getToStringValue(value) &&
        (element.value = "" + getToStringValue(value));
  else
    ("submit" !== type && "reset" !== type) || element.removeAttribute("value");
  null != value
    ? setDefaultValue(element, type, getToStringValue(value))
    : null != defaultValue
      ? setDefaultValue(element, type, getToStringValue(defaultValue))
      : null != lastDefaultValue && element.removeAttribute("value");
  null == checked &&
    null != defaultChecked &&
    (element.defaultChecked = !!defaultChecked);
  null != checked &&
    (element.checked =
      checked && "function" !== typeof checked && "symbol" !== typeof checked);
  null != name &&
  "function" !== typeof name &&
  "symbol" !== typeof name &&
  "boolean" !== typeof name
    ? (element.name = "" + getToStringValue(name))
    : element.removeAttribute("name");
}
function initInput(
  element,
  value,
  defaultValue,
  checked,
  defaultChecked,
  type,
  name,
  isHydrating
) {
  null != type &&
    "function" !== typeof type &&
    "symbol" !== typeof type &&
    "boolean" !== typeof type &&
    (element.type = type);
  if (null != value || null != defaultValue) {
    if (
      !(
        ("submit" !== type && "reset" !== type) ||
        (void 0 !== value && null !== value)
      )
    ) {
      track(element);
      return;
    }
    defaultValue =
      null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    value = null != value ? "" + getToStringValue(value) : defaultValue;
    isHydrating || value === element.value || (element.value = value);
    element.defaultValue = value;
  }
  checked = null != checked ? checked : defaultChecked;
  checked =
    "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
  element.checked = isHydrating ? element.checked : !!checked;
  element.defaultChecked = !!checked;
  null != name &&
    "function" !== typeof name &&
    "symbol" !== typeof name &&
    "boolean" !== typeof name &&
    (element.name = name);
  track(element);
}
function setDefaultValue(node, type, value) {
  ("number" === type && getActiveElement(node.ownerDocument) === node) ||
    node.defaultValue === "" + value ||
    (node.defaultValue = "" + value);
}
function updateOptions(node, multiple, propValue, setDefaultSelected) {
  node = node.options;
  if (multiple) {
    multiple = {};
    for (var i = 0; i < propValue.length; i++)
      multiple["$" + propValue[i]] = !0;
    for (propValue = 0; propValue < node.length; propValue++)
      (i = multiple.hasOwnProperty("$" + node[propValue].value)),
        node[propValue].selected !== i && (node[propValue].selected = i),
        i && setDefaultSelected && (node[propValue].defaultSelected = !0);
  } else {
    propValue = "" + getToStringValue(propValue);
    multiple = null;
    for (i = 0; i < node.length; i++) {
      if (node[i].value === propValue) {
        node[i].selected = !0;
        setDefaultSelected && (node[i].defaultSelected = !0);
        return;
      }
      null !== multiple || node[i].disabled || (multiple = node[i]);
    }
    null !== multiple && (multiple.selected = !0);
  }
}
function updateTextarea(element, value, defaultValue) {
  if (
    null != value &&
    ((value = "" + getToStringValue(value)),
    value !== element.value && (element.value = value),
    null == defaultValue)
  ) {
    element.defaultValue !== value && (element.defaultValue = value);
    return;
  }
  element.defaultValue =
    null != defaultValue ? "" + getToStringValue(defaultValue) : "";
}
function initTextarea(element, value, defaultValue, children) {
  if (null == value) {
    if (null != children) {
      if (null != defaultValue) throw Error(formatProdErrorMessage(92));
      if (isArrayImpl(children)) {
        if (1 < children.length) throw Error(formatProdErrorMessage(93));
        children = children[0];
      }
      defaultValue = children;
    }
    null == defaultValue && (defaultValue = "");
    value = defaultValue;
  }
  defaultValue = getToStringValue(value);
  element.defaultValue = defaultValue;
  children = element.textContent;
  children === defaultValue &&
    "" !== children &&
    null !== children &&
    (element.value = children);
  track(element);
}
function setTextContent(node, text) {
  if (text) {
    var firstChild = node.firstChild;
    if (
      firstChild &&
      firstChild === node.lastChild &&
      3 === firstChild.nodeType
    ) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
}
var unitlessNumbers = new Set(
  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
    " "
  )
);
function setValueForStyle(style, styleName, value) {
  var isCustomProperty = 0 === styleName.indexOf("--");
  null == value || "boolean" === typeof value || "" === value
    ? isCustomProperty
      ? style.setProperty(styleName, "")
      : "float" === styleName
        ? (style.cssFloat = "")
        : (style[styleName] = "")
    : isCustomProperty
      ? style.setProperty(styleName, value)
      : "number" !== typeof value ||
          0 === value ||
          unitlessNumbers.has(styleName)
        ? "float" === styleName
          ? (style.cssFloat = value)
          : (style[styleName] = ("" + value).trim())
        : (style[styleName] = value + "px");
}
function setValueForStyles(node, styles, prevStyles) {
  if (null != styles && "object" !== typeof styles)
    throw Error(formatProdErrorMessage(62));
  node = node.style;
  if (null != prevStyles) {
    for (var styleName in prevStyles)
      !prevStyles.hasOwnProperty(styleName) ||
        (null != styles && styles.hasOwnProperty(styleName)) ||
        (0 === styleName.indexOf("--")
          ? node.setProperty(styleName, "")
          : "float" === styleName
            ? (node.cssFloat = "")
            : (node[styleName] = ""));
    for (var styleName$16 in styles)
      (styleName = styles[styleName$16]),
        styles.hasOwnProperty(styleName$16) &&
          prevStyles[styleName$16] !== styleName &&
          setValueForStyle(node, styleName$16, styleName);
  } else
    for (var styleName$17 in styles)
      styles.hasOwnProperty(styleName$17) &&
        setValueForStyle(node, styleName$17, styles[styleName$17]);
}
function isCustomElement(tagName) {
  if (-1 === tagName.indexOf("-")) return !1;
  switch (tagName) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var aliases = new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]),
  isJavaScriptProtocol =
    /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
function sanitizeURL(url) {
  return isJavaScriptProtocol.test("" + url)
    ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
    : url;
}
function noop$1() {}
var currentReplayingEvent = null;
function getEventTarget(nativeEvent) {
  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
  nativeEvent.correspondingUseElement &&
    (nativeEvent = nativeEvent.correspondingUseElement);
  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
}
var restoreTarget = null,
  restoreQueue = null;
function restoreStateOfTarget(target) {
  var internalInstance = getInstanceFromNode(target);
  if (internalInstance && (target = internalInstance.stateNode)) {
    var props = target[internalPropsKey] || null;
    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {
      case "input":
        updateInput(
          target,
          props.value,
          props.defaultValue,
          props.defaultValue,
          props.checked,
          props.defaultChecked,
          props.type,
          props.name
        );
        internalInstance = props.name;
        if ("radio" === props.type && null != internalInstance) {
          for (props = target; props.parentNode; ) props = props.parentNode;
          props = props.querySelectorAll(
            'input[name="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(
                "" + internalInstance
              ) +
              '"][type="radio"]'
          );
          for (
            internalInstance = 0;
            internalInstance < props.length;
            internalInstance++
          ) {
            var otherNode = props[internalInstance];
            if (otherNode !== target && otherNode.form === target.form) {
              var otherProps = otherNode[internalPropsKey] || null;
              if (!otherProps) throw Error(formatProdErrorMessage(90));
              updateInput(
                otherNode,
                otherProps.value,
                otherProps.defaultValue,
                otherProps.defaultValue,
                otherProps.checked,
                otherProps.defaultChecked,
                otherProps.type,
                otherProps.name
              );
            }
          }
          for (
            internalInstance = 0;
            internalInstance < props.length;
            internalInstance++
          )
            (otherNode = props[internalInstance]),
              otherNode.form === target.form && updateValueIfChanged(otherNode);
        }
        break a;
      case "textarea":
        updateTextarea(target, props.value, props.defaultValue);
        break a;
      case "select":
        (internalInstance = props.value),
          null != internalInstance &&
            updateOptions(target, !!props.multiple, internalInstance, !1);
    }
  }
}
var isInsideEventHandler = !1;
function batchedUpdates$1(fn, a, b) {
  if (isInsideEventHandler) return fn(a, b);
  isInsideEventHandler = !0;
  try {
    var JSCompiler_inline_result = fn(a);
    return JSCompiler_inline_result;
  } finally {
    if (
      ((isInsideEventHandler = !1),
      null !== restoreTarget || null !== restoreQueue)
    )
      if (
        (flushSyncWork$1(),
        restoreTarget &&
          ((a = restoreTarget),
          (fn = restoreQueue),
          (restoreQueue = restoreTarget = null),
          restoreStateOfTarget(a),
          fn))
      )
        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
  }
}
function getListener(inst, registrationName) {
  var stateNode = inst.stateNode;
  if (null === stateNode) return null;
  var props = stateNode[internalPropsKey] || null;
  if (null === props) return null;
  stateNode = props[registrationName];
  a: switch (registrationName) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (props = !props.disabled) ||
        ((inst = inst.type),
        (props = !(
          "button" === inst ||
          "input" === inst ||
          "select" === inst ||
          "textarea" === inst
        )));
      inst = !props;
      break a;
    default:
      inst = !1;
  }
  if (inst) return null;
  if (stateNode && "function" !== typeof stateNode)
    throw Error(
      formatProdErrorMessage(231, registrationName, typeof stateNode)
    );
  return stateNode;
}
var canUseDOM = !(
    "undefined" === typeof window ||
    "undefined" === typeof window.document ||
    "undefined" === typeof window.document.createElement
  ),
  passiveBrowserEventsSupported = !1;
if (canUseDOM)
  try {
    var options = {};
    Object.defineProperty(options, "passive", {
      get: function () {
        passiveBrowserEventsSupported = !0;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (e) {
    passiveBrowserEventsSupported = !1;
  }
var root = null,
  startText = null,
  fallbackText = null;
function getData() {
  if (fallbackText) return fallbackText;
  var start,
    startValue = startText,
    startLength = startValue.length,
    end,
    endValue = "value" in root ? root.value : root.textContent,
    endLength = endValue.length;
  for (
    start = 0;
    start < startLength && startValue[start] === endValue[start];
    start++
  );
  var minEnd = startLength - start;
  for (
    end = 1;
    end <= minEnd &&
    startValue[startLength - end] === endValue[endLength - end];
    end++
  );
  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
}
function getEventCharCode(nativeEvent) {
  var keyCode = nativeEvent.keyCode;
  "charCode" in nativeEvent
    ? ((nativeEvent = nativeEvent.charCode),
      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
    : (nativeEvent = keyCode);
  10 === nativeEvent && (nativeEvent = 13);
  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
}
function functionThatReturnsTrue() {
  return !0;
}
function functionThatReturnsFalse() {
  return !1;
}
function createSyntheticEvent(Interface) {
  function SyntheticBaseEvent(
    reactName,
    reactEventType,
    targetInst,
    nativeEvent,
    nativeEventTarget
  ) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;
    for (var propName in Interface)
      Interface.hasOwnProperty(propName) &&
        ((reactName = Interface[propName]),
        (this[propName] = reactName
          ? reactName(nativeEvent)
          : nativeEvent[propName]));
    this.isDefaultPrevented = (
      null != nativeEvent.defaultPrevented
        ? nativeEvent.defaultPrevented
        : !1 === nativeEvent.returnValue
    )
      ? functionThatReturnsTrue
      : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }
  assign(SyntheticBaseEvent.prototype, {
    preventDefault: function () {
      this.defaultPrevented = !0;
      var event = this.nativeEvent;
      event &&
        (event.preventDefault
          ? event.preventDefault()
          : "unknown" !== typeof event.returnValue && (event.returnValue = !1),
        (this.isDefaultPrevented = functionThatReturnsTrue));
    },
    stopPropagation: function () {
      var event = this.nativeEvent;
      event &&
        (event.stopPropagation
          ? event.stopPropagation()
          : "unknown" !== typeof event.cancelBubble &&
            (event.cancelBubble = !0),
        (this.isPropagationStopped = functionThatReturnsTrue));
    },
    persist: function () {},
    isPersistent: functionThatReturnsTrue
  });
  return SyntheticBaseEvent;
}
var EventInterface = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
  SyntheticEvent = createSyntheticEvent(EventInterface),
  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
  lastMovementX,
  lastMovementY,
  lastMouseEvent,
  MouseEventInterface = assign({}, UIEventInterface, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: getEventModifierState,
    button: 0,
    buttons: 0,
    relatedTarget: function (event) {
      return void 0 === event.relatedTarget
        ? event.fromElement === event.srcElement
          ? event.toElement
          : event.fromElement
        : event.relatedTarget;
    },
    movementX: function (event) {
      if ("movementX" in event) return event.movementX;
      event !== lastMouseEvent &&
        (lastMouseEvent && "mousemove" === event.type
          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
            (lastMovementY = event.screenY - lastMouseEvent.screenY))
          : (lastMovementY = lastMovementX = 0),
        (lastMouseEvent = event));
      return lastMovementX;
    },
    movementY: function (event) {
      return "movementY" in event ? event.movementY : lastMovementY;
    }
  }),
  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
  AnimationEventInterface = assign({}, EventInterface, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
  ClipboardEventInterface = assign({}, EventInterface, {
    clipboardData: function (event) {
      return "clipboardData" in event
        ? event.clipboardData
        : window.clipboardData;
    }
  }),
  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
  normalizeKey = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
  translateToKey = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
  modifierKeyToProp = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
function modifierStateGetter(keyArg) {
  var nativeEvent = this.nativeEvent;
  return nativeEvent.getModifierState
    ? nativeEvent.getModifierState(keyArg)
    : (keyArg = modifierKeyToProp[keyArg])
      ? !!nativeEvent[keyArg]
      : !1;
}
function getEventModifierState() {
  return modifierStateGetter;
}
var KeyboardEventInterface = assign({}, UIEventInterface, {
    key: function (nativeEvent) {
      if (nativeEvent.key) {
        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if ("Unidentified" !== key) return key;
      }
      return "keypress" === nativeEvent.type
        ? ((nativeEvent = getEventCharCode(nativeEvent)),
          13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
        : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
          ? translateToKey[nativeEvent.keyCode] || "Unidentified"
          : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: getEventModifierState,
    charCode: function (event) {
      return "keypress" === event.type ? getEventCharCode(event) : 0;
    },
    keyCode: function (event) {
      return "keydown" === event.type || "keyup" === event.type
        ? event.keyCode
        : 0;
    },
    which: function (event) {
      return "keypress" === event.type
        ? getEventCharCode(event)
        : "keydown" === event.type || "keyup" === event.type
          ? event.keyCode
          : 0;
    }
  }),
  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
  PointerEventInterface = assign({}, MouseEventInterface, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
  TouchEventInterface = assign({}, UIEventInterface, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: getEventModifierState
  }),
  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
  TransitionEventInterface = assign({}, EventInterface, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
  WheelEventInterface = assign({}, MouseEventInterface, {
    deltaX: function (event) {
      return "deltaX" in event
        ? event.deltaX
        : "wheelDeltaX" in event
          ? -event.wheelDeltaX
          : 0;
    },
    deltaY: function (event) {
      return "deltaY" in event
        ? event.deltaY
        : "wheelDeltaY" in event
          ? -event.wheelDeltaY
          : "wheelDelta" in event
            ? -event.wheelDelta
            : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }),
  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
  ToggleEventInterface = assign({}, EventInterface, {
    newState: 0,
    oldState: 0
  }),
  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
  END_KEYCODES = [9, 13, 27, 32],
  canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
  documentMode = null;
canUseDOM &&
  "documentMode" in document &&
  (documentMode = document.documentMode);
var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,
  useFallbackCompositionData =
    canUseDOM &&
    (!canUseCompositionEvent ||
      (documentMode && 8 < documentMode && 11 >= documentMode)),
  SPACEBAR_CHAR = String.fromCharCode(32),
  hasSpaceKeypress = !1;
function isFallbackCompositionEnd(domEventName, nativeEvent) {
  switch (domEventName) {
    case "keyup":
      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
    case "keydown":
      return 229 !== nativeEvent.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function getDataFromCustomEvent(nativeEvent) {
  nativeEvent = nativeEvent.detail;
  return "object" === typeof nativeEvent && "data" in nativeEvent
    ? nativeEvent.data
    : null;
}
var isComposing = !1;
function getNativeBeforeInputChars(domEventName, nativeEvent) {
  switch (domEventName) {
    case "compositionend":
      return getDataFromCustomEvent(nativeEvent);
    case "keypress":
      if (32 !== nativeEvent.which) return null;
      hasSpaceKeypress = !0;
      return SPACEBAR_CHAR;
    case "textInput":
      return (
        (domEventName = nativeEvent.data),
        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName
      );
    default:
      return null;
  }
}
function getFallbackBeforeInputChars(domEventName, nativeEvent) {
  if (isComposing)
    return "compositionend" === domEventName ||
      (!canUseCompositionEvent &&
        isFallbackCompositionEnd(domEventName, nativeEvent))
      ? ((domEventName = getData()),
        (fallbackText = startText = root = null),
        (isComposing = !1),
        domEventName)
      : null;
  switch (domEventName) {
    case "paste":
      return null;
    case "keypress":
      if (
        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||
        (nativeEvent.ctrlKey && nativeEvent.altKey)
      ) {
        if (nativeEvent.char && 1 < nativeEvent.char.length)
          return nativeEvent.char;
        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case "compositionend":
      return useFallbackCompositionData && "ko" !== nativeEvent.locale
        ? null
        : nativeEvent.data;
    default:
      return null;
  }
}
var supportedInputTypes = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};
function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return "input" === nodeName
    ? !!supportedInputTypes[elem.type]
    : "textarea" === nodeName
      ? !0
      : !1;
}
function createAndAccumulateChangeEvent(
  dispatchQueue,
  inst,
  nativeEvent,
  target
) {
  restoreTarget
    ? restoreQueue
      ? restoreQueue.push(target)
      : (restoreQueue = [target])
    : (restoreTarget = target);
  inst = accumulateTwoPhaseListeners(inst, "onChange");
  0 < inst.length &&
    ((nativeEvent = new SyntheticEvent(
      "onChange",
      "change",
      null,
      nativeEvent,
      target
    )),
    dispatchQueue.push({ event: nativeEvent, listeners: inst }));
}
var activeElement$1 = null,
  activeElementInst$1 = null;
function runEventInBatch(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}
function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance(targetInst);
  if (updateValueIfChanged(targetNode)) return targetInst;
}
function getTargetInstForChangeEvent(domEventName, targetInst) {
  if ("change" === domEventName) return targetInst;
}
var isInputEventSupported = !1;
if (canUseDOM) {
  var JSCompiler_inline_result$jscomp$286;
  if (canUseDOM) {
    var isSupported$jscomp$inline_427 = "oninput" in document;
    if (!isSupported$jscomp$inline_427) {
      var element$jscomp$inline_428 = document.createElement("div");
      element$jscomp$inline_428.setAttribute("oninput", "return;");
      isSupported$jscomp$inline_427 =
        "function" === typeof element$jscomp$inline_428.oninput;
    }
    JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
  } else JSCompiler_inline_result$jscomp$286 = !1;
  isInputEventSupported =
    JSCompiler_inline_result$jscomp$286 &&
    (!document.documentMode || 9 < document.documentMode);
}
function stopWatchingForValueChange() {
  activeElement$1 &&
    (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
    (activeElementInst$1 = activeElement$1 = null));
}
function handlePropertyChange(nativeEvent) {
  if (
    "value" === nativeEvent.propertyName &&
    getInstIfValueChanged(activeElementInst$1)
  ) {
    var dispatchQueue = [];
    createAndAccumulateChangeEvent(
      dispatchQueue,
      activeElementInst$1,
      nativeEvent,
      getEventTarget(nativeEvent)
    );
    batchedUpdates$1(runEventInBatch, dispatchQueue);
  }
}
function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
  "focusin" === domEventName
    ? (stopWatchingForValueChange(),
      (activeElement$1 = target),
      (activeElementInst$1 = targetInst),
      activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
    : "focusout" === domEventName && stopWatchingForValueChange();
}
function getTargetInstForInputEventPolyfill(domEventName) {
  if (
    "selectionchange" === domEventName ||
    "keyup" === domEventName ||
    "keydown" === domEventName
  )
    return getInstIfValueChanged(activeElementInst$1);
}
function getTargetInstForClickEvent(domEventName, targetInst) {
  if ("click" === domEventName) return getInstIfValueChanged(targetInst);
}
function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
  if ("input" === domEventName || "change" === domEventName)
    return getInstIfValueChanged(targetInst);
}
function is(x, y) {
  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
}
var objectIs = "function" === typeof Object.is ? Object.is : is;
function shallowEqual(objA, objB) {
  if (objectIs(objA, objB)) return !0;
  if (
    "object" !== typeof objA ||
    null === objA ||
    "object" !== typeof objB ||
    null === objB
  )
    return !1;
  var keysA = Object.keys(objA),
    keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return !1;
  for (keysB = 0; keysB < keysA.length; keysB++) {
    var currentKey = keysA[keysB];
    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !objectIs(objA[currentKey], objB[currentKey])
    )
      return !1;
  }
  return !0;
}
function getLeafNode(node) {
  for (; node && node.firstChild; ) node = node.firstChild;
  return node;
}
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  root = 0;
  for (var nodeEnd; node; ) {
    if (3 === node.nodeType) {
      nodeEnd = root + node.textContent.length;
      if (root <= offset && nodeEnd >= offset)
        return { node: node, offset: offset - root };
      root = nodeEnd;
    }
    a: {
      for (; node; ) {
        if (node.nextSibling) {
          node = node.nextSibling;
          break a;
        }
        node = node.parentNode;
      }
      node = void 0;
    }
    node = getLeafNode(node);
  }
}
function containsNode(outerNode, innerNode) {
  return outerNode && innerNode
    ? outerNode === innerNode
      ? !0
      : outerNode && 3 === outerNode.nodeType
        ? !1
        : innerNode && 3 === innerNode.nodeType
          ? containsNode(outerNode, innerNode.parentNode)
          : "contains" in outerNode
            ? outerNode.contains(innerNode)
            : outerNode.compareDocumentPosition
              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
              : !1
    : !1;
}
function getActiveElementDeep(containerInfo) {
  containerInfo =
    null != containerInfo &&
    null != containerInfo.ownerDocument &&
    null != containerInfo.ownerDocument.defaultView
      ? containerInfo.ownerDocument.defaultView
      : window;
  for (
    var element = getActiveElement(containerInfo.document);
    element instanceof containerInfo.HTMLIFrameElement;

  ) {
    try {
      var JSCompiler_inline_result =
        "string" === typeof element.contentWindow.location.href;
    } catch (err) {
      JSCompiler_inline_result = !1;
    }
    if (JSCompiler_inline_result) containerInfo = element.contentWindow;
    else break;
    element = getActiveElement(containerInfo.document);
  }
  return element;
}
function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return (
    nodeName &&
    (("input" === nodeName &&
      ("text" === elem.type ||
        "search" === elem.type ||
        "tel" === elem.type ||
        "url" === elem.type ||
        "password" === elem.type)) ||
      "textarea" === nodeName ||
      "true" === elem.contentEditable)
  );
}
var skipSelectionChangeEvent =
    canUseDOM && "documentMode" in document && 11 >= document.documentMode,
  activeElement = null,
  activeElementInst = null,
  lastSelection = null,
  mouseDown = !1;
function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
  var doc =
    nativeEventTarget.window === nativeEventTarget
      ? nativeEventTarget.document
      : 9 === nativeEventTarget.nodeType
        ? nativeEventTarget
        : nativeEventTarget.ownerDocument;
  mouseDown ||
    null == activeElement ||
    activeElement !== getActiveElement(doc) ||
    ((doc = activeElement),
    "selectionStart" in doc && hasSelectionCapabilities(doc)
      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
      : ((doc = (
          (doc.ownerDocument && doc.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        })),
    (lastSelection && shallowEqual(lastSelection, doc)) ||
      ((lastSelection = doc),
      (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
      0 < doc.length &&
        ((nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        )),
        dispatchQueue.push({ event: nativeEvent, listeners: doc }),
        (nativeEvent.target = activeElement))));
}
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit" + styleProp] = "webkit" + eventName;
  prefixes["Moz" + styleProp] = "moz" + eventName;
  return prefixes;
}
var vendorPrefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
    animationstart: makePrefixMap("Animation", "AnimationStart"),
    transitionrun: makePrefixMap("Transition", "TransitionRun"),
    transitionstart: makePrefixMap("Transition", "TransitionStart"),
    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  },
  prefixedEventNames = {},
  style = {};
canUseDOM &&
  ((style = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete vendorPrefixes.animationend.animation,
    delete vendorPrefixes.animationiteration.animation,
    delete vendorPrefixes.animationstart.animation),
  "TransitionEvent" in window ||
    delete vendorPrefixes.transitionend.transition);
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
  if (!vendorPrefixes[eventName]) return eventName;
  var prefixMap = vendorPrefixes[eventName],
    styleProp;
  for (styleProp in prefixMap)
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
      return (prefixedEventNames[eventName] = prefixMap[styleProp]);
  return eventName;
}
var ANIMATION_END = getVendorPrefixedEventName("animationend"),
  ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
  ANIMATION_START = getVendorPrefixedEventName("animationstart"),
  TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
  TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
  TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
  TRANSITION_END = getVendorPrefixedEventName("transitionend"),
  topLevelEventsToReactNames = new Map(),
  simpleEventPluginEvents =
    "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
simpleEventPluginEvents.push("scrollEnd");
function registerSimpleEvent(domEventName, reactName) {
  topLevelEventsToReactNames.set(domEventName, reactName);
  registerTwoPhaseEvent(reactName, [domEventName]);
}
var reportGlobalError =
    "function" === typeof reportError
      ? reportError
      : function (error) {
          if (
            "object" === typeof window &&
            "function" === typeof window.ErrorEvent
          ) {
            var event = new window.ErrorEvent("error", {
              bubbles: !0,
              cancelable: !0,
              message:
                "object" === typeof error &&
                null !== error &&
                "string" === typeof error.message
                  ? String(error.message)
                  : String(error),
              error: error
            });
            if (!window.dispatchEvent(event)) return;
          } else if (
            "object" === typeof process &&
            "function" === typeof process.emit
          ) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        },
  concurrentQueues = [],
  concurrentQueuesIndex = 0,
  concurrentlyUpdatedLanes = 0;
function finishQueueingConcurrentUpdates() {
  for (
    var endIndex = concurrentQueuesIndex,
      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
    i < endIndex;

  ) {
    var fiber = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var queue = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var update = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var lane = concurrentQueues[i];
    concurrentQueues[i++] = null;
    if (null !== queue && null !== update) {
      var pending = queue.pending;
      null === pending
        ? (update.next = update)
        : ((update.next = pending.next), (pending.next = update));
      queue.pending = update;
    }
    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
  }
}
function enqueueUpdate$1(fiber, queue, update, lane) {
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
  concurrentlyUpdatedLanes |= lane;
  fiber.lanes |= lane;
  fiber = fiber.alternate;
  null !== fiber && (fiber.lanes |= lane);
}
function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
  enqueueUpdate$1(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function enqueueConcurrentRenderForLane(fiber, lane) {
  enqueueUpdate$1(fiber, null, null, lane);
  return getRootForUpdatedFiber(fiber);
}
function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
  sourceFiber.lanes |= lane;
  var alternate = sourceFiber.alternate;
  null !== alternate && (alternate.lanes |= lane);
  for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )
    (parent.childLanes |= lane),
      (alternate = parent.alternate),
      null !== alternate && (alternate.childLanes |= lane),
      22 === parent.tag &&
        ((sourceFiber = parent.stateNode),
        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),
      (sourceFiber = parent),
      (parent = parent.return);
  return 3 === sourceFiber.tag
    ? ((parent = sourceFiber.stateNode),
      isHidden &&
        null !== update &&
        ((isHidden = 31 - clz32(lane)),
        (sourceFiber = parent.hiddenUpdates),
        (alternate = sourceFiber[isHidden]),
        null === alternate
          ? (sourceFiber[isHidden] = [update])
          : alternate.push(update),
        (update.lane = lane | 536870912)),
      parent)
    : null;
}
function getRootForUpdatedFiber(sourceFiber) {
  if (50 < nestedUpdateCount)
    throw (
      ((nestedUpdateCount = 0),
      (rootWithNestedUpdates = null),
      Error(formatProdErrorMessage(185)))
    );
  for (var parent = sourceFiber.return; null !== parent; )
    (sourceFiber = parent), (parent = sourceFiber.return);
  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
}
var emptyContextObject = {};
function FiberNode(tag, pendingProps, key, mode) {
  this.tag = tag;
  this.key = key;
  this.sibling =
    this.child =
    this.return =
    this.stateNode =
    this.type =
    this.elementType =
      null;
  this.index = 0;
  this.refCleanup = this.ref = null;
  this.pendingProps = pendingProps;
  this.dependencies =
    this.memoizedState =
    this.updateQueue =
    this.memoizedProps =
      null;
  this.mode = mode;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function createFiberImplClass(tag, pendingProps, key, mode) {
  return new FiberNode(tag, pendingProps, key, mode);
}
function shouldConstruct(Component) {
  Component = Component.prototype;
  return !(!Component || !Component.isReactComponent);
}
function createWorkInProgress(current, pendingProps) {
  var workInProgress = current.alternate;
  null === workInProgress
    ? ((workInProgress = createFiberImplClass(
        current.tag,
        pendingProps,
        current.key,
        current.mode
      )),
      (workInProgress.elementType = current.elementType),
      (workInProgress.type = current.type),
      (workInProgress.stateNode = current.stateNode),
      (workInProgress.alternate = current),
      (current.alternate = workInProgress))
    : ((workInProgress.pendingProps = pendingProps),
      (workInProgress.type = current.type),
      (workInProgress.flags = 0),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.deletions = null));
  workInProgress.flags = current.flags & 65011712;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  pendingProps = current.dependencies;
  workInProgress.dependencies =
    null === pendingProps
      ? null
      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  workInProgress.refCleanup = current.refCleanup;
  return workInProgress;
}
function resetWorkInProgress(workInProgress, renderLanes) {
  workInProgress.flags &= 65011714;
  var current = workInProgress.alternate;
  null === current
    ? ((workInProgress.childLanes = 0),
      (workInProgress.lanes = renderLanes),
      (workInProgress.child = null),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.memoizedProps = null),
      (workInProgress.memoizedState = null),
      (workInProgress.updateQueue = null),
      (workInProgress.dependencies = null),
      (workInProgress.stateNode = null))
    : ((workInProgress.childLanes = current.childLanes),
      (workInProgress.lanes = current.lanes),
      (workInProgress.child = current.child),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.deletions = null),
      (workInProgress.memoizedProps = current.memoizedProps),
      (workInProgress.memoizedState = current.memoizedState),
      (workInProgress.updateQueue = current.updateQueue),
      (workInProgress.type = current.type),
      (renderLanes = current.dependencies),
      (workInProgress.dependencies =
        null === renderLanes
          ? null
          : {
              lanes: renderLanes.lanes,
              firstContext: renderLanes.firstContext
            }));
  return workInProgress;
}
function createFiberFromTypeAndProps(
  type,
  key,
  pendingProps,
  owner,
  mode,
  lanes
) {
  var fiberTag = 0;
  owner = type;
  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
  else if ("string" === typeof type)
    fiberTag = isHostHoistableType(
      type,
      pendingProps,
      contextStackCursor.current
    )
      ? 26
      : "html" === type || "head" === type || "body" === type
        ? 27
        : 5;
  else
    a: switch (type) {
      case REACT_ACTIVITY_TYPE:
        return (
          (type = createFiberImplClass(31, pendingProps, key, mode)),
          (type.elementType = REACT_ACTIVITY_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
      case REACT_STRICT_MODE_TYPE:
        fiberTag = 8;
        mode |= 24;
        break;
      case REACT_PROFILER_TYPE:
        return (
          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),
          (type.elementType = REACT_PROFILER_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_SUSPENSE_TYPE:
        return (
          (type = createFiberImplClass(13, pendingProps, key, mode)),
          (type.elementType = REACT_SUSPENSE_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_SUSPENSE_LIST_TYPE:
        return (
          (type = createFiberImplClass(19, pendingProps, key, mode)),
          (type.elementType = REACT_SUSPENSE_LIST_TYPE),
          (type.lanes = lanes),
          type
        );
      default:
        if ("object" === typeof type && null !== type)
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              fiberTag = 10;
              break a;
            case REACT_CONSUMER_TYPE:
              fiberTag = 9;
              break a;
            case REACT_FORWARD_REF_TYPE:
              fiberTag = 11;
              break a;
            case REACT_MEMO_TYPE:
              fiberTag = 14;
              break a;
            case REACT_LAZY_TYPE:
              fiberTag = 16;
              owner = null;
              break a;
          }
        fiberTag = 29;
        pendingProps = Error(
          formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
        );
        owner = null;
    }
  key = createFiberImplClass(fiberTag, pendingProps, key, mode);
  key.elementType = type;
  key.type = owner;
  key.lanes = lanes;
  return key;
}
function createFiberFromFragment(elements, mode, lanes, key) {
  elements = createFiberImplClass(7, elements, key, mode);
  elements.lanes = lanes;
  return elements;
}
function createFiberFromText(content, mode, lanes) {
  content = createFiberImplClass(6, content, null, mode);
  content.lanes = lanes;
  return content;
}
function createFiberFromDehydratedFragment(dehydratedNode) {
  var fiber = createFiberImplClass(18, null, null, 0);
  fiber.stateNode = dehydratedNode;
  return fiber;
}
function createFiberFromPortal(portal, mode, lanes) {
  mode = createFiberImplClass(
    4,
    null !== portal.children ? portal.children : [],
    portal.key,
    mode
  );
  mode.lanes = lanes;
  mode.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null,
    implementation: portal.implementation
  };
  return mode;
}
var CapturedStacks = new WeakMap();
function createCapturedValueAtFiber(value, source) {
  if ("object" === typeof value && null !== value) {
    var existing = CapturedStacks.get(value);
    if (void 0 !== existing) return existing;
    source = {
      value: value,
      source: source,
      stack: getStackByFiberInDevAndProd(source)
    };
    CapturedStacks.set(value, source);
    return source;
  }
  return {
    value: value,
    source: source,
    stack: getStackByFiberInDevAndProd(source)
  };
}
var forkStack = [],
  forkStackIndex = 0,
  treeForkProvider = null,
  treeForkCount = 0,
  idStack = [],
  idStackIndex = 0,
  treeContextProvider = null,
  treeContextId = 1,
  treeContextOverflow = "";
function pushTreeFork(workInProgress, totalChildren) {
  forkStack[forkStackIndex++] = treeForkCount;
  forkStack[forkStackIndex++] = treeForkProvider;
  treeForkProvider = workInProgress;
  treeForkCount = totalChildren;
}
function pushTreeId(workInProgress, totalChildren, index) {
  idStack[idStackIndex++] = treeContextId;
  idStack[idStackIndex++] = treeContextOverflow;
  idStack[idStackIndex++] = treeContextProvider;
  treeContextProvider = workInProgress;
  var baseIdWithLeadingBit = treeContextId;
  workInProgress = treeContextOverflow;
  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
  baseIdWithLeadingBit &= ~(1 << baseLength);
  index += 1;
  var length = 32 - clz32(totalChildren) + baseLength;
  if (30 < length) {
    var numberOfOverflowBits = baseLength - (baseLength % 5);
    length = (
      baseIdWithLeadingBit &
      ((1 << numberOfOverflowBits) - 1)
    ).toString(32);
    baseIdWithLeadingBit >>= numberOfOverflowBits;
    baseLength -= numberOfOverflowBits;
    treeContextId =
      (1 << (32 - clz32(totalChildren) + baseLength)) |
      (index << baseLength) |
      baseIdWithLeadingBit;
    treeContextOverflow = length + workInProgress;
  } else
    (treeContextId =
      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
      (treeContextOverflow = workInProgress);
}
function pushMaterializedTreeId(workInProgress) {
  null !== workInProgress.return &&
    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
}
function popTreeContext(workInProgress) {
  for (; workInProgress === treeForkProvider; )
    (treeForkProvider = forkStack[--forkStackIndex]),
      (forkStack[forkStackIndex] = null),
      (treeForkCount = forkStack[--forkStackIndex]),
      (forkStack[forkStackIndex] = null);
  for (; workInProgress === treeContextProvider; )
    (treeContextProvider = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null),
      (treeContextOverflow = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null),
      (treeContextId = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null);
}
function restoreSuspendedTreeContext(workInProgress, suspendedContext) {
  idStack[idStackIndex++] = treeContextId;
  idStack[idStackIndex++] = treeContextOverflow;
  idStack[idStackIndex++] = treeContextProvider;
  treeContextId = suspendedContext.id;
  treeContextOverflow = suspendedContext.overflow;
  treeContextProvider = workInProgress;
}
var hydrationParentFiber = null,
  nextHydratableInstance = null,
  isHydrating = !1,
  hydrationErrors = null,
  rootOrSingletonContext = !1,
  HydrationMismatchException = Error(formatProdErrorMessage(519));
function throwOnHydrationMismatch(fiber) {
  var error = Error(
    formatProdErrorMessage(
      418,
      1 < arguments.length && void 0 !== arguments[1] && arguments[1]
        ? "text"
        : "HTML",
      ""
    )
  );
  queueHydrationError(createCapturedValueAtFiber(error, fiber));
  throw HydrationMismatchException;
}
function prepareToHydrateHostInstance(fiber) {
  var instance = fiber.stateNode,
    type = fiber.type,
    props = fiber.memoizedProps;
  instance[internalInstanceKey] = fiber;
  instance[internalPropsKey] = props;
  switch (type) {
    case "dialog":
      listenToNonDelegatedEvent("cancel", instance);
      listenToNonDelegatedEvent("close", instance);
      break;
    case "iframe":
    case "object":
    case "embed":
      listenToNonDelegatedEvent("load", instance);
      break;
    case "video":
    case "audio":
      for (type = 0; type < mediaEventTypes.length; type++)
        listenToNonDelegatedEvent(mediaEventTypes[type], instance);
      break;
    case "source":
      listenToNonDelegatedEvent("error", instance);
      break;
    case "img":
    case "image":
    case "link":
      listenToNonDelegatedEvent("error", instance);
      listenToNonDelegatedEvent("load", instance);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", instance);
      break;
    case "input":
      listenToNonDelegatedEvent("invalid", instance);
      initInput(
        instance,
        props.value,
        props.defaultValue,
        props.checked,
        props.defaultChecked,
        props.type,
        props.name,
        !0
      );
      break;
    case "select":
      listenToNonDelegatedEvent("invalid", instance);
      break;
    case "textarea":
      listenToNonDelegatedEvent("invalid", instance),
        initTextarea(instance, props.value, props.defaultValue, props.children);
  }
  type = props.children;
  ("string" !== typeof type &&
    "number" !== typeof type &&
    "bigint" !== typeof type) ||
  instance.textContent === "" + type ||
  !0 === props.suppressHydrationWarning ||
  checkForUnmatchedText(instance.textContent, type)
    ? (null != props.popover &&
        (listenToNonDelegatedEvent("beforetoggle", instance),
        listenToNonDelegatedEvent("toggle", instance)),
      null != props.onScroll && listenToNonDelegatedEvent("scroll", instance),
      null != props.onScrollEnd &&
        listenToNonDelegatedEvent("scrollend", instance),
      null != props.onClick && (instance.onclick = noop$1),
      (instance = !0))
    : (instance = !1);
  instance || throwOnHydrationMismatch(fiber, !0);
}
function popToNextHostParent(fiber) {
  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
    switch (hydrationParentFiber.tag) {
      case 5:
      case 31:
      case 13:
        rootOrSingletonContext = !1;
        return;
      case 27:
      case 3:
        rootOrSingletonContext = !0;
        return;
      default:
        hydrationParentFiber = hydrationParentFiber.return;
    }
}
function popHydrationState(fiber) {
  if (fiber !== hydrationParentFiber) return !1;
  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;
  var tag = fiber.tag,
    JSCompiler_temp;
  if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {
    if ((JSCompiler_temp = 5 === tag))
      (JSCompiler_temp = fiber.type),
        (JSCompiler_temp =
          !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
          shouldSetTextContent(fiber.type, fiber.memoizedProps));
    JSCompiler_temp = !JSCompiler_temp;
  }
  JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
  popToNextHostParent(fiber);
  if (13 === tag) {
    fiber = fiber.memoizedState;
    fiber = null !== fiber ? fiber.dehydrated : null;
    if (!fiber) throw Error(formatProdErrorMessage(317));
    nextHydratableInstance =
      getNextHydratableInstanceAfterHydrationBoundary(fiber);
  } else if (31 === tag) {
    fiber = fiber.memoizedState;
    fiber = null !== fiber ? fiber.dehydrated : null;
    if (!fiber) throw Error(formatProdErrorMessage(317));
    nextHydratableInstance =
      getNextHydratableInstanceAfterHydrationBoundary(fiber);
  } else
    27 === tag
      ? ((tag = nextHydratableInstance),
        isSingletonScope(fiber.type)
          ? ((fiber = previousHydratableOnEnteringScopedSingleton),
            (previousHydratableOnEnteringScopedSingleton = null),
            (nextHydratableInstance = fiber))
          : (nextHydratableInstance = tag))
      : (nextHydratableInstance = hydrationParentFiber
          ? getNextHydratable(fiber.stateNode.nextSibling)
          : null);
  return !0;
}
function resetHydrationState() {
  nextHydratableInstance = hydrationParentFiber = null;
  isHydrating = !1;
}
function upgradeHydrationErrorsToRecoverable() {
  var queuedErrors = hydrationErrors;
  null !== queuedErrors &&
    (null === workInProgressRootRecoverableErrors
      ? (workInProgressRootRecoverableErrors = queuedErrors)
      : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ),
    (hydrationErrors = null));
  return queuedErrors;
}
function queueHydrationError(error) {
  null === hydrationErrors
    ? (hydrationErrors = [error])
    : hydrationErrors.push(error);
}
var valueCursor = createCursor(null),
  currentlyRenderingFiber$1 = null,
  lastContextDependency = null;
function pushProvider(providerFiber, context, nextValue) {
  push(valueCursor, context._currentValue);
  context._currentValue = nextValue;
}
function popProvider(context) {
  context._currentValue = valueCursor.current;
  pop(valueCursor);
}
function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
  for (; null !== parent; ) {
    var alternate = parent.alternate;
    (parent.childLanes & renderLanes) !== renderLanes
      ? ((parent.childLanes |= renderLanes),
        null !== alternate && (alternate.childLanes |= renderLanes))
      : null !== alternate &&
        (alternate.childLanes & renderLanes) !== renderLanes &&
        (alternate.childLanes |= renderLanes);
    if (parent === propagationRoot) break;
    parent = parent.return;
  }
}
function propagateContextChanges(
  workInProgress,
  contexts,
  renderLanes,
  forcePropagateEntireTree
) {
  var fiber = workInProgress.child;
  null !== fiber && (fiber.return = workInProgress);
  for (; null !== fiber; ) {
    var list = fiber.dependencies;
    if (null !== list) {
      var nextFiber = fiber.child;
      list = list.firstContext;
      a: for (; null !== list; ) {
        var dependency = list;
        list = fiber;
        for (var i = 0; i < contexts.length; i++)
          if (dependency.context === contexts[i]) {
            list.lanes |= renderLanes;
            dependency = list.alternate;
            null !== dependency && (dependency.lanes |= renderLanes);
            scheduleContextWorkOnParentPath(
              list.return,
              renderLanes,
              workInProgress
            );
            forcePropagateEntireTree || (nextFiber = null);
            break a;
          }
        list = dependency.next;
      }
    } else if (18 === fiber.tag) {
      nextFiber = fiber.return;
      if (null === nextFiber) throw Error(formatProdErrorMessage(341));
      nextFiber.lanes |= renderLanes;
      list = nextFiber.alternate;
      null !== list && (list.lanes |= renderLanes);
      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
      nextFiber = null;
    } else nextFiber = fiber.child;
    if (null !== nextFiber) nextFiber.return = fiber;
    else
      for (nextFiber = fiber; null !== nextFiber; ) {
        if (nextFiber === workInProgress) {
          nextFiber = null;
          break;
        }
        fiber = nextFiber.sibling;
        if (null !== fiber) {
          fiber.return = nextFiber.return;
          nextFiber = fiber;
          break;
        }
        nextFiber = nextFiber.return;
      }
    fiber = nextFiber;
  }
}
function propagateParentContextChanges(
  current,
  workInProgress,
  renderLanes,
  forcePropagateEntireTree
) {
  current = null;
  for (
    var parent = workInProgress, isInsidePropagationBailout = !1;
    null !== parent;

  ) {
    if (!isInsidePropagationBailout)
      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
      else if (0 !== (parent.flags & 262144)) break;
    if (10 === parent.tag) {
      var currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent = currentParent.memoizedProps;
      if (null !== currentParent) {
        var context = parent.type;
        objectIs(parent.pendingProps.value, currentParent.value) ||
          (null !== current ? current.push(context) : (current = [context]));
      }
    } else if (parent === hostTransitionProviderCursor.current) {
      currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent.memoizedState.memoizedState !==
        parent.memoizedState.memoizedState &&
        (null !== current
          ? current.push(HostTransitionContext)
          : (current = [HostTransitionContext]));
    }
    parent = parent.return;
  }
  null !== current &&
    propagateContextChanges(
      workInProgress,
      current,
      renderLanes,
      forcePropagateEntireTree
    );
  workInProgress.flags |= 262144;
}
function checkIfContextChanged(currentDependencies) {
  for (
    currentDependencies = currentDependencies.firstContext;
    null !== currentDependencies;

  ) {
    if (
      !objectIs(
        currentDependencies.context._currentValue,
        currentDependencies.memoizedValue
      )
    )
      return !0;
    currentDependencies = currentDependencies.next;
  }
  return !1;
}
function prepareToReadContext(workInProgress) {
  currentlyRenderingFiber$1 = workInProgress;
  lastContextDependency = null;
  workInProgress = workInProgress.dependencies;
  null !== workInProgress && (workInProgress.firstContext = null);
}
function readContext(context) {
  return readContextForConsumer(currentlyRenderingFiber$1, context);
}
function readContextDuringReconciliation(consumer, context) {
  null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
  return readContextForConsumer(consumer, context);
}
function readContextForConsumer(consumer, context) {
  var value = context._currentValue;
  context = { context: context, memoizedValue: value, next: null };
  if (null === lastContextDependency) {
    if (null === consumer) throw Error(formatProdErrorMessage(308));
    lastContextDependency = context;
    consumer.dependencies = { lanes: 0, firstContext: context };
    consumer.flags |= 524288;
  } else lastContextDependency = lastContextDependency.next = context;
  return value;
}
var AbortControllerLocal =
    "undefined" !== typeof AbortController
      ? AbortController
      : function () {
          var listeners = [],
            signal = (this.signal = {
              aborted: !1,
              addEventListener: function (type, listener) {
                listeners.push(listener);
              }
            });
          this.abort = function () {
            signal.aborted = !0;
            listeners.forEach(function (listener) {
              return listener();
            });
          };
        },
  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
  NormalPriority = Scheduler.unstable_NormalPriority,
  CacheContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
function createCache() {
  return {
    controller: new AbortControllerLocal(),
    data: new Map(),
    refCount: 0
  };
}
function releaseCache(cache) {
  cache.refCount--;
  0 === cache.refCount &&
    scheduleCallback$2(NormalPriority, function () {
      cache.controller.abort();
    });
}
var currentEntangledListeners = null,
  currentEntangledPendingCount = 0,
  currentEntangledLane = 0,
  currentEntangledActionThenable = null;
function entangleAsyncAction(transition, thenable) {
  if (null === currentEntangledListeners) {
    var entangledListeners = (currentEntangledListeners = []);
    currentEntangledPendingCount = 0;
    currentEntangledLane = requestTransitionLane();
    currentEntangledActionThenable = {
      status: "pending",
      value: void 0,
      then: function (resolve) {
        entangledListeners.push(resolve);
      }
    };
  }
  currentEntangledPendingCount++;
  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
  return thenable;
}
function pingEngtangledActionScope() {
  if (
    0 === --currentEntangledPendingCount &&
    null !== currentEntangledListeners
  ) {
    null !== currentEntangledActionThenable &&
      (currentEntangledActionThenable.status = "fulfilled");
    var listeners = currentEntangledListeners;
    currentEntangledListeners = null;
    currentEntangledLane = 0;
    currentEntangledActionThenable = null;
    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
  }
}
function chainThenableValue(thenable, result) {
  var listeners = [],
    thenableWithOverride = {
      status: "pending",
      value: null,
      reason: null,
      then: function (resolve) {
        listeners.push(resolve);
      }
    };
  thenable.then(
    function () {
      thenableWithOverride.status = "fulfilled";
      thenableWithOverride.value = result;
      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
    },
    function (error) {
      thenableWithOverride.status = "rejected";
      thenableWithOverride.reason = error;
      for (error = 0; error < listeners.length; error++)
        (0, listeners[error])(void 0);
    }
  );
  return thenableWithOverride;
}
var prevOnStartTransitionFinish = ReactSharedInternals.S;
ReactSharedInternals.S = function (transition, returnValue) {
  globalMostRecentTransitionTime = now();
  "object" === typeof returnValue &&
    null !== returnValue &&
    "function" === typeof returnValue.then &&
    entangleAsyncAction(transition, returnValue);
  null !== prevOnStartTransitionFinish &&
    prevOnStartTransitionFinish(transition, returnValue);
};
var resumedCache = createCursor(null);
function peekCacheFromPool() {
  var cacheResumedFromPreviousRender = resumedCache.current;
  return null !== cacheResumedFromPreviousRender
    ? cacheResumedFromPreviousRender
    : workInProgressRoot.pooledCache;
}
function pushTransition(offscreenWorkInProgress, prevCachePool) {
  null === prevCachePool
    ? push(resumedCache, resumedCache.current)
    : push(resumedCache, prevCachePool.pool);
}
function getSuspendedCache() {
  var cacheFromPool = peekCacheFromPool();
  return null === cacheFromPool
    ? null
    : { parent: CacheContext._currentValue, pool: cacheFromPool };
}
var SuspenseException = Error(formatProdErrorMessage(460)),
  SuspenseyCommitException = Error(formatProdErrorMessage(474)),
  SuspenseActionException = Error(formatProdErrorMessage(542)),
  noopSuspenseyCommitThenable = { then: function () {} };
function isThenableResolved(thenable) {
  thenable = thenable.status;
  return "fulfilled" === thenable || "rejected" === thenable;
}
function trackUsedThenable(thenableState, thenable, index) {
  index = thenableState[index];
  void 0 === index
    ? thenableState.push(thenable)
    : index !== thenable && (thenable.then(noop$1, noop$1), (thenable = index));
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw (
        ((thenableState = thenable.reason),
        checkIfUseWrappedInAsyncCatch(thenableState),
        thenableState)
      );
    default:
      if ("string" === typeof thenable.status) thenable.then(noop$1, noop$1);
      else {
        thenableState = workInProgressRoot;
        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)
          throw Error(formatProdErrorMessage(482));
        thenableState = thenable;
        thenableState.status = "pending";
        thenableState.then(
          function (fulfilledValue) {
            if ("pending" === thenable.status) {
              var fulfilledThenable = thenable;
              fulfilledThenable.status = "fulfilled";
              fulfilledThenable.value = fulfilledValue;
            }
          },
          function (error) {
            if ("pending" === thenable.status) {
              var rejectedThenable = thenable;
              rejectedThenable.status = "rejected";
              rejectedThenable.reason = error;
            }
          }
        );
      }
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw (
            ((thenableState = thenable.reason),
            checkIfUseWrappedInAsyncCatch(thenableState),
            thenableState)
          );
      }
      suspendedThenable = thenable;
      throw SuspenseException;
  }
}
function resolveLazy(lazyType) {
  try {
    var init = lazyType._init;
    return init(lazyType._payload);
  } catch (x) {
    if (null !== x && "object" === typeof x && "function" === typeof x.then)
      throw ((suspendedThenable = x), SuspenseException);
    throw x;
  }
}
var suspendedThenable = null;
function getSuspendedThenable() {
  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
  var thenable = suspendedThenable;
  suspendedThenable = null;
  return thenable;
}
function checkIfUseWrappedInAsyncCatch(rejectedReason) {
  if (
    rejectedReason === SuspenseException ||
    rejectedReason === SuspenseActionException
  )
    throw Error(formatProdErrorMessage(483));
}
var thenableState$1 = null,
  thenableIndexCounter$1 = 0;
function unwrapThenable(thenable) {
  var index = thenableIndexCounter$1;
  thenableIndexCounter$1 += 1;
  null === thenableState$1 && (thenableState$1 = []);
  return trackUsedThenable(thenableState$1, thenable, index);
}
function coerceRef(workInProgress, element) {
  element = element.props.ref;
  workInProgress.ref = void 0 !== element ? element : null;
}
function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
    throw Error(formatProdErrorMessage(525));
  returnFiber = Object.prototype.toString.call(newChild);
  throw Error(
    formatProdErrorMessage(
      31,
      "[object Object]" === returnFiber
        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
        : returnFiber
    )
  );
}
function createChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (shouldTrackSideEffects) {
      var deletions = returnFiber.deletions;
      null === deletions
        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))
        : deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) return null;
    for (; null !== currentFirstChild; )
      deleteChild(returnFiber, currentFirstChild),
        (currentFirstChild = currentFirstChild.sibling);
    return null;
  }
  function mapRemainingChildren(currentFirstChild) {
    for (var existingChildren = new Map(); null !== currentFirstChild; )
      null !== currentFirstChild.key
        ? existingChildren.set(currentFirstChild.key, currentFirstChild)
        : existingChildren.set(currentFirstChild.index, currentFirstChild),
        (currentFirstChild = currentFirstChild.sibling);
    return existingChildren;
  }
  function useFiber(fiber, pendingProps) {
    fiber = createWorkInProgress(fiber, pendingProps);
    fiber.index = 0;
    fiber.sibling = null;
    return fiber;
  }
  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects)
      return (newFiber.flags |= 1048576), lastPlacedIndex;
    newIndex = newFiber.alternate;
    if (null !== newIndex)
      return (
        (newIndex = newIndex.index),
        newIndex < lastPlacedIndex
          ? ((newFiber.flags |= 67108866), lastPlacedIndex)
          : newIndex
      );
    newFiber.flags |= 67108866;
    return lastPlacedIndex;
  }
  function placeSingleChild(newFiber) {
    shouldTrackSideEffects &&
      null === newFiber.alternate &&
      (newFiber.flags |= 67108866);
    return newFiber;
  }
  function updateTextNode(returnFiber, current, textContent, lanes) {
    if (null === current || 6 !== current.tag)
      return (
        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, textContent);
    current.return = returnFiber;
    return current;
  }
  function updateElement(returnFiber, current, element, lanes) {
    var elementType = element.type;
    if (elementType === REACT_FRAGMENT_TYPE)
      return updateFragment(
        returnFiber,
        current,
        element.props.children,
        lanes,
        element.key
      );
    if (
      null !== current &&
      (current.elementType === elementType ||
        ("object" === typeof elementType &&
          null !== elementType &&
          elementType.$$typeof === REACT_LAZY_TYPE &&
          resolveLazy(elementType) === current.type))
    )
      return (
        (current = useFiber(current, element.props)),
        coerceRef(current, element),
        (current.return = returnFiber),
        current
      );
    current = createFiberFromTypeAndProps(
      element.type,
      element.key,
      element.props,
      null,
      returnFiber.mode,
      lanes
    );
    coerceRef(current, element);
    current.return = returnFiber;
    return current;
  }
  function updatePortal(returnFiber, current, portal, lanes) {
    if (
      null === current ||
      4 !== current.tag ||
      current.stateNode.containerInfo !== portal.containerInfo ||
      current.stateNode.implementation !== portal.implementation
    )
      return (
        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, portal.children || []);
    current.return = returnFiber;
    return current;
  }
  function updateFragment(returnFiber, current, fragment, lanes, key) {
    if (null === current || 7 !== current.tag)
      return (
        (current = createFiberFromFragment(
          fragment,
          returnFiber.mode,
          lanes,
          key
        )),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, fragment);
    current.return = returnFiber;
    return current;
  }
  function createChild(returnFiber, newChild, lanes) {
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return (
        (newChild = createFiberFromText(
          "" + newChild,
          returnFiber.mode,
          lanes
        )),
        (newChild.return = returnFiber),
        newChild
      );
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return (
            (lanes = createFiberFromTypeAndProps(
              newChild.type,
              newChild.key,
              newChild.props,
              null,
              returnFiber.mode,
              lanes
            )),
            coerceRef(lanes, newChild),
            (lanes.return = returnFiber),
            lanes
          );
        case REACT_PORTAL_TYPE:
          return (
            (newChild = createFiberFromPortal(
              newChild,
              returnFiber.mode,
              lanes
            )),
            (newChild.return = returnFiber),
            newChild
          );
        case REACT_LAZY_TYPE:
          return (
            (newChild = resolveLazy(newChild)),
            createChild(returnFiber, newChild, lanes)
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return (
          (newChild = createFiberFromFragment(
            newChild,
            returnFiber.mode,
            lanes,
            null
          )),
          (newChild.return = returnFiber),
          newChild
        );
      if ("function" === typeof newChild.then)
        return createChild(returnFiber, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return createChild(
          returnFiber,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    return null;
  }
  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
    var key = null !== oldFiber ? oldFiber.key : null;
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return null !== key
        ? null
        : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return newChild.key === key
            ? updateElement(returnFiber, oldFiber, newChild, lanes)
            : null;
        case REACT_PORTAL_TYPE:
          return newChild.key === key
            ? updatePortal(returnFiber, oldFiber, newChild, lanes)
            : null;
        case REACT_LAZY_TYPE:
          return (
            (newChild = resolveLazy(newChild)),
            updateSlot(returnFiber, oldFiber, newChild, lanes)
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return null !== key
          ? null
          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
      if ("function" === typeof newChild.then)
        return updateSlot(
          returnFiber,
          oldFiber,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return updateSlot(
          returnFiber,
          oldFiber,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    return null;
  }
  function updateFromMap(
    existingChildren,
    returnFiber,
    newIdx,
    newChild,
    lanes
  ) {
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return (
        (existingChildren = existingChildren.get(newIdx) || null),
        updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
      );
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return (
            (existingChildren =
              existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null),
            updateElement(returnFiber, existingChildren, newChild, lanes)
          );
        case REACT_PORTAL_TYPE:
          return (
            (existingChildren =
              existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null),
            updatePortal(returnFiber, existingChildren, newChild, lanes)
          );
        case REACT_LAZY_TYPE:
          return (
            (newChild = resolveLazy(newChild)),
            updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              newChild,
              lanes
            )
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return (
          (existingChildren = existingChildren.get(newIdx) || null),
          updateFragment(returnFiber, existingChildren, newChild, lanes, null)
        );
      if ("function" === typeof newChild.then)
        return updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    return null;
  }
  function reconcileChildrenArray(
    returnFiber,
    currentFirstChild,
    newChildren,
    lanes
  ) {
    for (
      var resultingFirstChild = null,
        previousNewFiber = null,
        oldFiber = currentFirstChild,
        newIdx = (currentFirstChild = 0),
        nextOldFiber = null;
      null !== oldFiber && newIdx < newChildren.length;
      newIdx++
    ) {
      oldFiber.index > newIdx
        ? ((nextOldFiber = oldFiber), (oldFiber = null))
        : (nextOldFiber = oldFiber.sibling);
      var newFiber = updateSlot(
        returnFiber,
        oldFiber,
        newChildren[newIdx],
        lanes
      );
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects &&
        oldFiber &&
        null === newFiber.alternate &&
        deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber
        ? (resultingFirstChild = newFiber)
        : (previousNewFiber.sibling = newFiber);
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (newIdx === newChildren.length)
      return (
        deleteRemainingChildren(returnFiber, oldFiber),
        isHydrating && pushTreeFork(returnFiber, newIdx),
        resultingFirstChild
      );
    if (null === oldFiber) {
      for (; newIdx < newChildren.length; newIdx++)
        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
          null !== oldFiber &&
            ((currentFirstChild = placeChild(
              oldFiber,
              currentFirstChild,
              newIdx
            )),
            null === previousNewFiber
              ? (resultingFirstChild = oldFiber)
              : (previousNewFiber.sibling = oldFiber),
            (previousNewFiber = oldFiber));
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (
      oldFiber = mapRemainingChildren(oldFiber);
      newIdx < newChildren.length;
      newIdx++
    )
      (nextOldFiber = updateFromMap(
        oldFiber,
        returnFiber,
        newIdx,
        newChildren[newIdx],
        lanes
      )),
        null !== nextOldFiber &&
          (shouldTrackSideEffects &&
            null !== nextOldFiber.alternate &&
            oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ),
          (currentFirstChild = placeChild(
            nextOldFiber,
            currentFirstChild,
            newIdx
          )),
          null === previousNewFiber
            ? (resultingFirstChild = nextOldFiber)
            : (previousNewFiber.sibling = nextOldFiber),
          (previousNewFiber = nextOldFiber));
    shouldTrackSideEffects &&
      oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildrenIterator(
    returnFiber,
    currentFirstChild,
    newChildren,
    lanes
  ) {
    if (null == newChildren) throw Error(formatProdErrorMessage(151));
    for (
      var resultingFirstChild = null,
        previousNewFiber = null,
        oldFiber = currentFirstChild,
        newIdx = (currentFirstChild = 0),
        nextOldFiber = null,
        step = newChildren.next();
      null !== oldFiber && !step.done;
      newIdx++, step = newChildren.next()
    ) {
      oldFiber.index > newIdx
        ? ((nextOldFiber = oldFiber), (oldFiber = null))
        : (nextOldFiber = oldFiber.sibling);
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects &&
        oldFiber &&
        null === newFiber.alternate &&
        deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber
        ? (resultingFirstChild = newFiber)
        : (previousNewFiber.sibling = newFiber);
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (step.done)
      return (
        deleteRemainingChildren(returnFiber, oldFiber),
        isHydrating && pushTreeFork(returnFiber, newIdx),
        resultingFirstChild
      );
    if (null === oldFiber) {
      for (; !step.done; newIdx++, step = newChildren.next())
        (step = createChild(returnFiber, step.value, lanes)),
          null !== step &&
            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
            null === previousNewFiber
              ? (resultingFirstChild = step)
              : (previousNewFiber.sibling = step),
            (previousNewFiber = step));
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (
      oldFiber = mapRemainingChildren(oldFiber);
      !step.done;
      newIdx++, step = newChildren.next()
    )
      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),
        null !== step &&
          (shouldTrackSideEffects &&
            null !== step.alternate &&
            oldFiber.delete(null === step.key ? newIdx : step.key),
          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
          null === previousNewFiber
            ? (resultingFirstChild = step)
            : (previousNewFiber.sibling = step),
          (previousNewFiber = step));
    shouldTrackSideEffects &&
      oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildFibersImpl(
    returnFiber,
    currentFirstChild,
    newChild,
    lanes
  ) {
    "object" === typeof newChild &&
      null !== newChild &&
      newChild.type === REACT_FRAGMENT_TYPE &&
      null === newChild.key &&
      (newChild = newChild.props.children);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          a: {
            for (var key = newChild.key; null !== currentFirstChild; ) {
              if (currentFirstChild.key === key) {
                key = newChild.type;
                if (key === REACT_FRAGMENT_TYPE) {
                  if (7 === currentFirstChild.tag) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    lanes = useFiber(
                      currentFirstChild,
                      newChild.props.children
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  }
                } else if (
                  currentFirstChild.elementType === key ||
                  ("object" === typeof key &&
                    null !== key &&
                    key.$$typeof === REACT_LAZY_TYPE &&
                    resolveLazy(key) === currentFirstChild.type)
                ) {
                  deleteRemainingChildren(
                    returnFiber,
                    currentFirstChild.sibling
                  );
                  lanes = useFiber(currentFirstChild, newChild.props);
                  coerceRef(lanes, newChild);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                }
                deleteRemainingChildren(returnFiber, currentFirstChild);
                break;
              } else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            newChild.type === REACT_FRAGMENT_TYPE
              ? ((lanes = createFiberFromFragment(
                  newChild.props.children,
                  returnFiber.mode,
                  lanes,
                  newChild.key
                )),
                (lanes.return = returnFiber),
                (returnFiber = lanes))
              : ((lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                )),
                coerceRef(lanes, newChild),
                (lanes.return = returnFiber),
                (returnFiber = lanes));
          }
          return placeSingleChild(returnFiber);
        case REACT_PORTAL_TYPE:
          a: {
            for (key = newChild.key; null !== currentFirstChild; ) {
              if (currentFirstChild.key === key)
                if (
                  4 === currentFirstChild.tag &&
                  currentFirstChild.stateNode.containerInfo ===
                    newChild.containerInfo &&
                  currentFirstChild.stateNode.implementation ===
                    newChild.implementation
                ) {
                  deleteRemainingChildren(
                    returnFiber,
                    currentFirstChild.sibling
                  );
                  lanes = useFiber(currentFirstChild, newChild.children || []);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                }
              else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
            lanes.return = returnFiber;
            returnFiber = lanes;
          }
          return placeSingleChild(returnFiber);
        case REACT_LAZY_TYPE:
          return (
            (newChild = resolveLazy(newChild)),
            reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            )
          );
      }
      if (isArrayImpl(newChild))
        return reconcileChildrenArray(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
      if (getIteratorFn(newChild)) {
        key = getIteratorFn(newChild);
        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
        newChild = key.call(newChild);
        return reconcileChildrenIterator(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
      }
      if ("function" === typeof newChild.then)
        return reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    return ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
      ? ((newChild = "" + newChild),
        null !== currentFirstChild && 6 === currentFirstChild.tag
          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
            (lanes = useFiber(currentFirstChild, newChild)),
            (lanes.return = returnFiber),
            (returnFiber = lanes))
          : (deleteRemainingChildren(returnFiber, currentFirstChild),
            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),
            (lanes.return = returnFiber),
            (returnFiber = lanes)),
        placeSingleChild(returnFiber))
      : deleteRemainingChildren(returnFiber, currentFirstChild);
  }
  return function (returnFiber, currentFirstChild, newChild, lanes) {
    try {
      thenableIndexCounter$1 = 0;
      var firstChildFiber = reconcileChildFibersImpl(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes
      );
      thenableState$1 = null;
      return firstChildFiber;
    } catch (x) {
      if (x === SuspenseException || x === SuspenseActionException) throw x;
      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
      fiber.lanes = lanes;
      fiber.return = returnFiber;
      return fiber;
    } finally {
    }
  };
}
var reconcileChildFibers = createChildReconciler(!0),
  mountChildFibers = createChildReconciler(!1),
  hasForceUpdate = !1;
function initializeUpdateQueue(fiber) {
  fiber.updateQueue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, lanes: 0, hiddenCallbacks: null },
    callbacks: null
  };
}
function cloneUpdateQueue(current, workInProgress) {
  current = current.updateQueue;
  workInProgress.updateQueue === current &&
    (workInProgress.updateQueue = {
      baseState: current.baseState,
      firstBaseUpdate: current.firstBaseUpdate,
      lastBaseUpdate: current.lastBaseUpdate,
      shared: current.shared,
      callbacks: null
    });
}
function createUpdate(lane) {
  return { lane: lane, tag: 0, payload: null, callback: null, next: null };
}
function enqueueUpdate(fiber, update, lane) {
  var updateQueue = fiber.updateQueue;
  if (null === updateQueue) return null;
  updateQueue = updateQueue.shared;
  if (0 !== (executionContext & 2)) {
    var pending = updateQueue.pending;
    null === pending
      ? (update.next = update)
      : ((update.next = pending.next), (pending.next = update));
    updateQueue.pending = update;
    update = getRootForUpdatedFiber(fiber);
    markUpdateLaneFromFiberToRoot(fiber, null, lane);
    return update;
  }
  enqueueUpdate$1(fiber, updateQueue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function entangleTransitions(root, fiber, lane) {
  fiber = fiber.updateQueue;
  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {
    var queueLanes = fiber.lanes;
    queueLanes &= root.pendingLanes;
    lane |= queueLanes;
    fiber.lanes = lane;
    markRootEntangled(root, lane);
  }
}
function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
  var queue = workInProgress.updateQueue,
    current = workInProgress.alternate;
  if (
    null !== current &&
    ((current = current.updateQueue), queue === current)
  ) {
    var newFirst = null,
      newLast = null;
    queue = queue.firstBaseUpdate;
    if (null !== queue) {
      do {
        var clone = {
          lane: queue.lane,
          tag: queue.tag,
          payload: queue.payload,
          callback: null,
          next: null
        };
        null === newLast
          ? (newFirst = newLast = clone)
          : (newLast = newLast.next = clone);
        queue = queue.next;
      } while (null !== queue);
      null === newLast
        ? (newFirst = newLast = capturedUpdate)
        : (newLast = newLast.next = capturedUpdate);
    } else newFirst = newLast = capturedUpdate;
    queue = {
      baseState: current.baseState,
      firstBaseUpdate: newFirst,
      lastBaseUpdate: newLast,
      shared: current.shared,
      callbacks: current.callbacks
    };
    workInProgress.updateQueue = queue;
    return;
  }
  workInProgress = queue.lastBaseUpdate;
  null === workInProgress
    ? (queue.firstBaseUpdate = capturedUpdate)
    : (workInProgress.next = capturedUpdate);
  queue.lastBaseUpdate = capturedUpdate;
}
var didReadFromEntangledAsyncAction = !1;
function suspendIfUpdateReadFromEntangledAsyncAction() {
  if (didReadFromEntangledAsyncAction) {
    var entangledActionThenable = currentEntangledActionThenable;
    if (null !== entangledActionThenable) throw entangledActionThenable;
  }
}
function processUpdateQueue(
  workInProgress$jscomp$0,
  props,
  instance$jscomp$0,
  renderLanes
) {
  didReadFromEntangledAsyncAction = !1;
  var queue = workInProgress$jscomp$0.updateQueue;
  hasForceUpdate = !1;
  var firstBaseUpdate = queue.firstBaseUpdate,
    lastBaseUpdate = queue.lastBaseUpdate,
    pendingQueue = queue.shared.pending;
  if (null !== pendingQueue) {
    queue.shared.pending = null;
    var lastPendingUpdate = pendingQueue,
      firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null;
    null === lastBaseUpdate
      ? (firstBaseUpdate = firstPendingUpdate)
      : (lastBaseUpdate.next = firstPendingUpdate);
    lastBaseUpdate = lastPendingUpdate;
    var current = workInProgress$jscomp$0.alternate;
    null !== current &&
      ((current = current.updateQueue),
      (pendingQueue = current.lastBaseUpdate),
      pendingQueue !== lastBaseUpdate &&
        (null === pendingQueue
          ? (current.firstBaseUpdate = firstPendingUpdate)
          : (pendingQueue.next = firstPendingUpdate),
        (current.lastBaseUpdate = lastPendingUpdate)));
  }
  if (null !== firstBaseUpdate) {
    var newState = queue.baseState;
    lastBaseUpdate = 0;
    current = firstPendingUpdate = lastPendingUpdate = null;
    pendingQueue = firstBaseUpdate;
    do {
      var updateLane = pendingQueue.lane & -536870913,
        isHiddenUpdate = updateLane !== pendingQueue.lane;
      if (
        isHiddenUpdate
          ? (workInProgressRootRenderLanes & updateLane) === updateLane
          : (renderLanes & updateLane) === updateLane
      ) {
        0 !== updateLane &&
          updateLane === currentEntangledLane &&
          (didReadFromEntangledAsyncAction = !0);
        null !== current &&
          (current = current.next =
            {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
        a: {
          var workInProgress = workInProgress$jscomp$0,
            update = pendingQueue;
          updateLane = props;
          var instance = instance$jscomp$0;
          switch (update.tag) {
            case 1:
              workInProgress = update.payload;
              if ("function" === typeof workInProgress) {
                newState = workInProgress.call(instance, newState, updateLane);
                break a;
              }
              newState = workInProgress;
              break a;
            case 3:
              workInProgress.flags = (workInProgress.flags & -65537) | 128;
            case 0:
              workInProgress = update.payload;
              updateLane =
                "function" === typeof workInProgress
                  ? workInProgress.call(instance, newState, updateLane)
                  : workInProgress;
              if (null === updateLane || void 0 === updateLane) break a;
              newState = assign({}, newState, updateLane);
              break a;
            case 2:
              hasForceUpdate = !0;
          }
        }
        updateLane = pendingQueue.callback;
        null !== updateLane &&
          ((workInProgress$jscomp$0.flags |= 64),
          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
          (isHiddenUpdate = queue.callbacks),
          null === isHiddenUpdate
            ? (queue.callbacks = [updateLane])
            : isHiddenUpdate.push(updateLane));
      } else
        (isHiddenUpdate = {
          lane: updateLane,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: pendingQueue.callback,
          next: null
        }),
          null === current
            ? ((firstPendingUpdate = current = isHiddenUpdate),
              (lastPendingUpdate = newState))
            : (current = current.next = isHiddenUpdate),
          (lastBaseUpdate |= updateLane);
      pendingQueue = pendingQueue.next;
      if (null === pendingQueue)
        if (((pendingQueue = queue.shared.pending), null === pendingQueue))
          break;
        else
          (isHiddenUpdate = pendingQueue),
            (pendingQueue = isHiddenUpdate.next),
            (isHiddenUpdate.next = null),
            (queue.lastBaseUpdate = isHiddenUpdate),
            (queue.shared.pending = null);
    } while (1);
    null === current && (lastPendingUpdate = newState);
    queue.baseState = lastPendingUpdate;
    queue.firstBaseUpdate = firstPendingUpdate;
    queue.lastBaseUpdate = current;
    null === firstBaseUpdate && (queue.shared.lanes = 0);
    workInProgressRootSkippedLanes |= lastBaseUpdate;
    workInProgress$jscomp$0.lanes = lastBaseUpdate;
    workInProgress$jscomp$0.memoizedState = newState;
  }
}
function callCallback(callback, context) {
  if ("function" !== typeof callback)
    throw Error(formatProdErrorMessage(191, callback));
  callback.call(context);
}
function commitCallbacks(updateQueue, context) {
  var callbacks = updateQueue.callbacks;
  if (null !== callbacks)
    for (
      updateQueue.callbacks = null, updateQueue = 0;
      updateQueue < callbacks.length;
      updateQueue++
    )
      callCallback(callbacks[updateQueue], context);
}
var currentTreeHiddenStackCursor = createCursor(null),
  prevEntangledRenderLanesCursor = createCursor(0);
function pushHiddenContext(fiber, context) {
  fiber = entangledRenderLanes;
  push(prevEntangledRenderLanesCursor, fiber);
  push(currentTreeHiddenStackCursor, context);
  entangledRenderLanes = fiber | context.baseLanes;
}
function reuseHiddenContextOnStack() {
  push(prevEntangledRenderLanesCursor, entangledRenderLanes);
  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
}
function popHiddenContext() {
  entangledRenderLanes = prevEntangledRenderLanesCursor.current;
  pop(currentTreeHiddenStackCursor);
  pop(prevEntangledRenderLanesCursor);
}
var suspenseHandlerStackCursor = createCursor(null),
  shellBoundary = null;
function pushPrimaryTreeSuspenseHandler(handler) {
  var current = handler.alternate;
  push(suspenseStackCursor, suspenseStackCursor.current & 1);
  push(suspenseHandlerStackCursor, handler);
  null === shellBoundary &&
    (null === current || null !== currentTreeHiddenStackCursor.current
      ? (shellBoundary = handler)
      : null !== current.memoizedState && (shellBoundary = handler));
}
function pushDehydratedActivitySuspenseHandler(fiber) {
  push(suspenseStackCursor, suspenseStackCursor.current);
  push(suspenseHandlerStackCursor, fiber);
  null === shellBoundary && (shellBoundary = fiber);
}
function pushOffscreenSuspenseHandler(fiber) {
  22 === fiber.tag
    ? (push(suspenseStackCursor, suspenseStackCursor.current),
      push(suspenseHandlerStackCursor, fiber),
      null === shellBoundary && (shellBoundary = fiber))
    : reuseSuspenseHandlerOnStack(fiber);
}
function reuseSuspenseHandlerOnStack() {
  push(suspenseStackCursor, suspenseStackCursor.current);
  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
}
function popSuspenseHandler(fiber) {
  pop(suspenseHandlerStackCursor);
  shellBoundary === fiber && (shellBoundary = null);
  pop(suspenseStackCursor);
}
var suspenseStackCursor = createCursor(0);
function findFirstSuspended(row) {
  for (var node = row; null !== node; ) {
    if (13 === node.tag) {
      var state = node.memoizedState;
      if (
        null !== state &&
        ((state = state.dehydrated),
        null === state ||
          isSuspenseInstancePending(state) ||
          isSuspenseInstanceFallback(state))
      )
        return node;
    } else if (
      19 === node.tag &&
      ("forwards" === node.memoizedProps.revealOrder ||
        "backwards" === node.memoizedProps.revealOrder ||
        "unstable_legacy-backwards" === node.memoizedProps.revealOrder ||
        "together" === node.memoizedProps.revealOrder)
    ) {
      if (0 !== (node.flags & 128)) return node;
    } else if (null !== node.child) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === row) break;
    for (; null === node.sibling; ) {
      if (null === node.return || node.return === row) return null;
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  return null;
}
var renderLanes = 0,
  currentlyRenderingFiber = null,
  currentHook = null,
  workInProgressHook = null,
  didScheduleRenderPhaseUpdate = !1,
  didScheduleRenderPhaseUpdateDuringThisPass = !1,
  shouldDoubleInvokeUserFnsInHooksDEV = !1,
  localIdCounter = 0,
  thenableIndexCounter = 0,
  thenableState = null,
  globalClientIdCounter = 0;
function throwInvalidHookError() {
  throw Error(formatProdErrorMessage(321));
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (null === prevDeps) return !1;
  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
    if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
  return !0;
}
function renderWithHooks(
  current,
  workInProgress,
  Component,
  props,
  secondArg,
  nextRenderLanes
) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;
  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = 0;
  ReactSharedInternals.H =
    null === current || null === current.memoizedState
      ? HooksDispatcherOnMount
      : HooksDispatcherOnUpdate;
  shouldDoubleInvokeUserFnsInHooksDEV = !1;
  nextRenderLanes = Component(props, secondArg);
  shouldDoubleInvokeUserFnsInHooksDEV = !1;
  didScheduleRenderPhaseUpdateDuringThisPass &&
    (nextRenderLanes = renderWithHooksAgain(
      workInProgress,
      Component,
      props,
      secondArg
    ));
  finishRenderingHooks(current);
  return nextRenderLanes;
}
function finishRenderingHooks(current) {
  ReactSharedInternals.H = ContextOnlyDispatcher;
  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber = null;
  didScheduleRenderPhaseUpdate = !1;
  thenableIndexCounter = 0;
  thenableState = null;
  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
  null === current ||
    didReceiveUpdate ||
    ((current = current.dependencies),
    null !== current &&
      checkIfContextChanged(current) &&
      (didReceiveUpdate = !0));
}
function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
  currentlyRenderingFiber = workInProgress;
  var numberOfReRenders = 0;
  do {
    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
    thenableIndexCounter = 0;
    didScheduleRenderPhaseUpdateDuringThisPass = !1;
    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
    numberOfReRenders += 1;
    workInProgressHook = currentHook = null;
    if (null != workInProgress.updateQueue) {
      var children = workInProgress.updateQueue;
      children.lastEffect = null;
      children.events = null;
      children.stores = null;
      null != children.memoCache && (children.memoCache.index = 0);
    }
    ReactSharedInternals.H = HooksDispatcherOnRerender;
    children = Component(props, secondArg);
  } while (didScheduleRenderPhaseUpdateDuringThisPass);
  return children;
}
function TransitionAwareHostComponent() {
  var dispatcher = ReactSharedInternals.H,
    maybeThenable = dispatcher.useState()[0];
  maybeThenable =
    "function" === typeof maybeThenable.then
      ? useThenable(maybeThenable)
      : maybeThenable;
  dispatcher = dispatcher.useState()[0];
  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&
    (currentlyRenderingFiber.flags |= 1024);
  return maybeThenable;
}
function checkDidRenderIdHook() {
  var didRenderIdHook = 0 !== localIdCounter;
  localIdCounter = 0;
  return didRenderIdHook;
}
function bailoutHooks(current, workInProgress, lanes) {
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.flags &= -2053;
  current.lanes &= ~lanes;
}
function resetHooksOnUnwind(workInProgress) {
  if (didScheduleRenderPhaseUpdate) {
    for (
      workInProgress = workInProgress.memoizedState;
      null !== workInProgress;

    ) {
      var queue = workInProgress.queue;
      null !== queue && (queue.pending = null);
      workInProgress = workInProgress.next;
    }
    didScheduleRenderPhaseUpdate = !1;
  }
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber = null;
  didScheduleRenderPhaseUpdateDuringThisPass = !1;
  thenableIndexCounter = localIdCounter = 0;
  thenableState = null;
}
function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  null === workInProgressHook
    ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)
    : (workInProgressHook = workInProgressHook.next = hook);
  return workInProgressHook;
}
function updateWorkInProgressHook() {
  if (null === currentHook) {
    var nextCurrentHook = currentlyRenderingFiber.alternate;
    nextCurrentHook =
      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
  } else nextCurrentHook = currentHook.next;
  var nextWorkInProgressHook =
    null === workInProgressHook
      ? currentlyRenderingFiber.memoizedState
      : workInProgressHook.next;
  if (null !== nextWorkInProgressHook)
    (workInProgressHook = nextWorkInProgressHook),
      (currentHook = nextCurrentHook);
  else {
    if (null === nextCurrentHook) {
      if (null === currentlyRenderingFiber.alternate)
        throw Error(formatProdErrorMessage(467));
      throw Error(formatProdErrorMessage(310));
    }
    currentHook = nextCurrentHook;
    nextCurrentHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null
    };
    null === workInProgressHook
      ? (currentlyRenderingFiber.memoizedState = workInProgressHook =
          nextCurrentHook)
      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
  }
  return workInProgressHook;
}
function createFunctionComponentUpdateQueue() {
  return { lastEffect: null, events: null, stores: null, memoCache: null };
}
function useThenable(thenable) {
  var index = thenableIndexCounter;
  thenableIndexCounter += 1;
  null === thenableState && (thenableState = []);
  thenable = trackUsedThenable(thenableState, thenable, index);
  index = currentlyRenderingFiber;
  null ===
    (null === workInProgressHook
      ? index.memoizedState
      : workInProgressHook.next) &&
    ((index = index.alternate),
    (ReactSharedInternals.H =
      null === index || null === index.memoizedState
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate));
  return thenable;
}
function use(usable) {
  if (null !== usable && "object" === typeof usable) {
    if ("function" === typeof usable.then) return useThenable(usable);
    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
  }
  throw Error(formatProdErrorMessage(438, String(usable)));
}
function useMemoCache(size) {
  var memoCache = null,
    updateQueue = currentlyRenderingFiber.updateQueue;
  null !== updateQueue && (memoCache = updateQueue.memoCache);
  if (null == memoCache) {
    var current = currentlyRenderingFiber.alternate;
    null !== current &&
      ((current = current.updateQueue),
      null !== current &&
        ((current = current.memoCache),
        null != current &&
          (memoCache = {
            data: current.data.map(function (array) {
              return array.slice();
            }),
            index: 0
          })));
  }
  null == memoCache && (memoCache = { data: [], index: 0 });
  null === updateQueue &&
    ((updateQueue = createFunctionComponentUpdateQueue()),
    (currentlyRenderingFiber.updateQueue = updateQueue));
  updateQueue.memoCache = memoCache;
  updateQueue = memoCache.data[memoCache.index];
  if (void 0 === updateQueue)
    for (
      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;
      current < size;
      current++
    )
      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
  memoCache.index++;
  return updateQueue;
}
function basicStateReducer(state, action) {
  return "function" === typeof action ? action(state) : action;
}
function updateReducer(reducer) {
  var hook = updateWorkInProgressHook();
  return updateReducerImpl(hook, currentHook, reducer);
}
function updateReducerImpl(hook, current, reducer) {
  var queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var baseQueue = hook.baseQueue,
    pendingQueue = queue.pending;
  if (null !== pendingQueue) {
    if (null !== baseQueue) {
      var baseFirst = baseQueue.next;
      baseQueue.next = pendingQueue.next;
      pendingQueue.next = baseFirst;
    }
    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }
  pendingQueue = hook.baseState;
  if (null === baseQueue) hook.memoizedState = pendingQueue;
  else {
    current = baseQueue.next;
    var newBaseQueueFirst = (baseFirst = null),
      newBaseQueueLast = null,
      update = current,
      didReadFromEntangledAsyncAction$60 = !1;
    do {
      var updateLane = update.lane & -536870913;
      if (
        updateLane !== update.lane
          ? (workInProgressRootRenderLanes & updateLane) === updateLane
          : (renderLanes & updateLane) === updateLane
      ) {
        var revertLane = update.revertLane;
        if (0 === revertLane)
          null !== newBaseQueueLast &&
            (newBaseQueueLast = newBaseQueueLast.next =
              {
                lane: 0,
                revertLane: 0,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }),
            updateLane === currentEntangledLane &&
              (didReadFromEntangledAsyncAction$60 = !0);
        else if ((renderLanes & revertLane) === revertLane) {
          update = update.next;
          revertLane === currentEntangledLane &&
            (didReadFromEntangledAsyncAction$60 = !0);
          continue;
        } else
          (updateLane = {
            lane: 0,
            revertLane: update.revertLane,
            gesture: null,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }),
            null === newBaseQueueLast
              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
                (baseFirst = pendingQueue))
              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
            (currentlyRenderingFiber.lanes |= revertLane),
            (workInProgressRootSkippedLanes |= revertLane);
        updateLane = update.action;
        shouldDoubleInvokeUserFnsInHooksDEV &&
          reducer(pendingQueue, updateLane);
        pendingQueue = update.hasEagerState
          ? update.eagerState
          : reducer(pendingQueue, updateLane);
      } else
        (revertLane = {
          lane: updateLane,
          revertLane: update.revertLane,
          gesture: update.gesture,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null
        }),
          null === newBaseQueueLast
            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
              (baseFirst = pendingQueue))
            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
          (currentlyRenderingFiber.lanes |= updateLane),
          (workInProgressRootSkippedLanes |= updateLane);
      update = update.next;
    } while (null !== update && update !== current);
    null === newBaseQueueLast
      ? (baseFirst = pendingQueue)
      : (newBaseQueueLast.next = newBaseQueueFirst);
    if (
      !objectIs(pendingQueue, hook.memoizedState) &&
      ((didReceiveUpdate = !0),
      didReadFromEntangledAsyncAction$60 &&
        ((reducer = currentEntangledActionThenable), null !== reducer))
    )
      throw reducer;
    hook.memoizedState = pendingQueue;
    hook.baseState = baseFirst;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = pendingQueue;
  }
  null === baseQueue && (queue.lanes = 0);
  return [hook.memoizedState, queue.dispatch];
}
function rerenderReducer(reducer) {
  var hook = updateWorkInProgressHook(),
    queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var dispatch = queue.dispatch,
    lastRenderPhaseUpdate = queue.pending,
    newState = hook.memoizedState;
  if (null !== lastRenderPhaseUpdate) {
    queue.pending = null;
    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
    do (newState = reducer(newState, update.action)), (update = update.next);
    while (update !== lastRenderPhaseUpdate);
    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
    hook.memoizedState = newState;
    null === hook.baseQueue && (hook.baseState = newState);
    queue.lastRenderedState = newState;
  }
  return [newState, dispatch];
}
function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
  var fiber = currentlyRenderingFiber,
    hook = updateWorkInProgressHook(),
    isHydrating$jscomp$0 = isHydrating;
  if (isHydrating$jscomp$0) {
    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
    getServerSnapshot = getServerSnapshot();
  } else getServerSnapshot = getSnapshot();
  var snapshotChanged = !objectIs(
    (currentHook || hook).memoizedState,
    getServerSnapshot
  );
  snapshotChanged &&
    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));
  hook = hook.queue;
  updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
    subscribe
  ]);
  if (
    hook.getSnapshot !== getSnapshot ||
    snapshotChanged ||
    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)
  ) {
    fiber.flags |= 2048;
    pushSimpleEffect(
      9,
      { destroy: void 0 },
      updateStoreInstance.bind(
        null,
        fiber,
        hook,
        getServerSnapshot,
        getSnapshot
      ),
      null
    );
    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
    isHydrating$jscomp$0 ||
      0 !== (renderLanes & 127) ||
      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
  }
  return getServerSnapshot;
}
function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
  fiber.flags |= 16384;
  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
  getSnapshot = currentlyRenderingFiber.updateQueue;
  null === getSnapshot
    ? ((getSnapshot = createFunctionComponentUpdateQueue()),
      (currentlyRenderingFiber.updateQueue = getSnapshot),
      (getSnapshot.stores = [fiber]))
    : ((renderedSnapshot = getSnapshot.stores),
      null === renderedSnapshot
        ? (getSnapshot.stores = [fiber])
        : renderedSnapshot.push(fiber));
}
function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
  inst.value = nextSnapshot;
  inst.getSnapshot = getSnapshot;
  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
}
function subscribeToStore(fiber, inst, subscribe) {
  return subscribe(function () {
    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
  });
}
function checkIfSnapshotChanged(inst) {
  var latestGetSnapshot = inst.getSnapshot;
  inst = inst.value;
  try {
    var nextValue = latestGetSnapshot();
    return !objectIs(inst, nextValue);
  } catch (error) {
    return !0;
  }
}
function forceStoreRerender(fiber) {
  var root = enqueueConcurrentRenderForLane(fiber, 2);
  null !== root && scheduleUpdateOnFiber(root, fiber, 2);
}
function mountStateImpl(initialState) {
  var hook = mountWorkInProgressHook();
  if ("function" === typeof initialState) {
    var initialStateInitializer = initialState;
    initialState = initialStateInitializer();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(!0);
      try {
        initialStateInitializer();
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
  }
  hook.memoizedState = hook.baseState = initialState;
  hook.queue = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState
  };
  return hook;
}
function updateOptimisticImpl(hook, current, passthrough, reducer) {
  hook.baseState = passthrough;
  return updateReducerImpl(
    hook,
    currentHook,
    "function" === typeof reducer ? reducer : basicStateReducer
  );
}
function dispatchActionState(
  fiber,
  actionQueue,
  setPendingState,
  setState,
  payload
) {
  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
  fiber = actionQueue.action;
  if (null !== fiber) {
    var actionNode = {
      payload: payload,
      action: fiber,
      next: null,
      isTransition: !0,
      status: "pending",
      value: null,
      reason: null,
      listeners: [],
      then: function (listener) {
        actionNode.listeners.push(listener);
      }
    };
    null !== ReactSharedInternals.T
      ? setPendingState(!0)
      : (actionNode.isTransition = !1);
    setState(actionNode);
    setPendingState = actionQueue.pending;
    null === setPendingState
      ? ((actionNode.next = actionQueue.pending = actionNode),
        runActionStateAction(actionQueue, actionNode))
      : ((actionNode.next = setPendingState.next),
        (actionQueue.pending = setPendingState.next = actionNode));
  }
}
function runActionStateAction(actionQueue, node) {
  var action = node.action,
    payload = node.payload,
    prevState = actionQueue.state;
  if (node.isTransition) {
    var prevTransition = ReactSharedInternals.T,
      currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    try {
      var returnValue = action(prevState, payload),
        onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish &&
        onStartTransitionFinish(currentTransition, returnValue);
      handleActionReturnValue(actionQueue, node, returnValue);
    } catch (error) {
      onActionError(actionQueue, node, error);
    } finally {
      null !== prevTransition &&
        null !== currentTransition.types &&
        (prevTransition.types = currentTransition.types),
        (ReactSharedInternals.T = prevTransition);
    }
  } else
    try {
      (prevTransition = action(prevState, payload)),
        handleActionReturnValue(actionQueue, node, prevTransition);
    } catch (error$66) {
      onActionError(actionQueue, node, error$66);
    }
}
function handleActionReturnValue(actionQueue, node, returnValue) {
  null !== returnValue &&
  "object" === typeof returnValue &&
  "function" === typeof returnValue.then
    ? returnValue.then(
        function (nextState) {
          onActionSuccess(actionQueue, node, nextState);
        },
        function (error) {
          return onActionError(actionQueue, node, error);
        }
      )
    : onActionSuccess(actionQueue, node, returnValue);
}
function onActionSuccess(actionQueue, actionNode, nextState) {
  actionNode.status = "fulfilled";
  actionNode.value = nextState;
  notifyActionListeners(actionNode);
  actionQueue.state = nextState;
  actionNode = actionQueue.pending;
  null !== actionNode &&
    ((nextState = actionNode.next),
    nextState === actionNode
      ? (actionQueue.pending = null)
      : ((nextState = nextState.next),
        (actionNode.next = nextState),
        runActionStateAction(actionQueue, nextState)));
}
function onActionError(actionQueue, actionNode, error) {
  var last = actionQueue.pending;
  actionQueue.pending = null;
  if (null !== last) {
    last = last.next;
    do
      (actionNode.status = "rejected"),
        (actionNode.reason = error),
        notifyActionListeners(actionNode),
        (actionNode = actionNode.next);
    while (actionNode !== last);
  }
  actionQueue.action = null;
}
function notifyActionListeners(actionNode) {
  actionNode = actionNode.listeners;
  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
}
function actionStateReducer(oldState, newState) {
  return newState;
}
function mountActionState(action, initialStateProp) {
  if (isHydrating) {
    var ssrFormState = workInProgressRoot.formState;
    if (null !== ssrFormState) {
      a: {
        var JSCompiler_inline_result = currentlyRenderingFiber;
        if (isHydrating) {
          if (nextHydratableInstance) {
            b: {
              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
              for (
                var inRootOrSingleton = rootOrSingletonContext;
                8 !== JSCompiler_inline_result$jscomp$0.nodeType;

              ) {
                if (!inRootOrSingleton) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
                JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                  JSCompiler_inline_result$jscomp$0.nextSibling
                );
                if (null === JSCompiler_inline_result$jscomp$0) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
              }
              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
              JSCompiler_inline_result$jscomp$0 =
                "F!" === inRootOrSingleton || "F" === inRootOrSingleton
                  ? JSCompiler_inline_result$jscomp$0
                  : null;
            }
            if (JSCompiler_inline_result$jscomp$0) {
              nextHydratableInstance = getNextHydratable(
                JSCompiler_inline_result$jscomp$0.nextSibling
              );
              JSCompiler_inline_result =
                "F!" === JSCompiler_inline_result$jscomp$0.data;
              break a;
            }
          }
          throwOnHydrationMismatch(JSCompiler_inline_result);
        }
        JSCompiler_inline_result = !1;
      }
      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
    }
  }
  ssrFormState = mountWorkInProgressHook();
  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
  JSCompiler_inline_result = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: actionStateReducer,
    lastRenderedState: initialStateProp
  };
  ssrFormState.queue = JSCompiler_inline_result;
  ssrFormState = dispatchSetState.bind(
    null,
    currentlyRenderingFiber,
    JSCompiler_inline_result
  );
  JSCompiler_inline_result.dispatch = ssrFormState;
  JSCompiler_inline_result = mountStateImpl(!1);
  inRootOrSingleton = dispatchOptimisticSetState.bind(
    null,
    currentlyRenderingFiber,
    !1,
    JSCompiler_inline_result.queue
  );
  JSCompiler_inline_result = mountWorkInProgressHook();
  JSCompiler_inline_result$jscomp$0 = {
    state: initialStateProp,
    dispatch: null,
    action: action,
    pending: null
  };
  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
  ssrFormState = dispatchActionState.bind(
    null,
    currentlyRenderingFiber,
    JSCompiler_inline_result$jscomp$0,
    inRootOrSingleton,
    ssrFormState
  );
  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
  JSCompiler_inline_result.memoizedState = action;
  return [initialStateProp, ssrFormState, !1];
}
function updateActionState(action) {
  var stateHook = updateWorkInProgressHook();
  return updateActionStateImpl(stateHook, currentHook, action);
}
function updateActionStateImpl(stateHook, currentStateHook, action) {
  currentStateHook = updateReducerImpl(
    stateHook,
    currentStateHook,
    actionStateReducer
  )[0];
  stateHook = updateReducer(basicStateReducer)[0];
  if (
    "object" === typeof currentStateHook &&
    null !== currentStateHook &&
    "function" === typeof currentStateHook.then
  )
    try {
      var state = useThenable(currentStateHook);
    } catch (x) {
      if (x === SuspenseException) throw SuspenseActionException;
      throw x;
    }
  else state = currentStateHook;
  currentStateHook = updateWorkInProgressHook();
  var actionQueue = currentStateHook.queue,
    dispatch = actionQueue.dispatch;
  action !== currentStateHook.memoizedState &&
    ((currentlyRenderingFiber.flags |= 2048),
    pushSimpleEffect(
      9,
      { destroy: void 0 },
      actionStateActionEffect.bind(null, actionQueue, action),
      null
    ));
  return [state, dispatch, stateHook];
}
function actionStateActionEffect(actionQueue, action) {
  actionQueue.action = action;
}
function rerenderActionState(action) {
  var stateHook = updateWorkInProgressHook(),
    currentStateHook = currentHook;
  if (null !== currentStateHook)
    return updateActionStateImpl(stateHook, currentStateHook, action);
  updateWorkInProgressHook();
  stateHook = stateHook.memoizedState;
  currentStateHook = updateWorkInProgressHook();
  var dispatch = currentStateHook.queue.dispatch;
  currentStateHook.memoizedState = action;
  return [stateHook, dispatch, !1];
}
function pushSimpleEffect(tag, inst, create, deps) {
  tag = { tag: tag, create: create, deps: deps, inst: inst, next: null };
  inst = currentlyRenderingFiber.updateQueue;
  null === inst &&
    ((inst = createFunctionComponentUpdateQueue()),
    (currentlyRenderingFiber.updateQueue = inst));
  create = inst.lastEffect;
  null === create
    ? (inst.lastEffect = tag.next = tag)
    : ((deps = create.next),
      (create.next = tag),
      (tag.next = deps),
      (inst.lastEffect = tag));
  return tag;
}
function updateRef() {
  return updateWorkInProgressHook().memoizedState;
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = mountWorkInProgressHook();
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushSimpleEffect(
    1 | hookFlags,
    { destroy: void 0 },
    create,
    void 0 === deps ? null : deps
  );
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var inst = hook.memoizedState.inst;
  null !== currentHook &&
  null !== deps &&
  areHookInputsEqual(deps, currentHook.memoizedState.deps)
    ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))
    : ((currentlyRenderingFiber.flags |= fiberFlags),
      (hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        inst,
        create,
        deps
      )));
}
function mountEffect(create, deps) {
  mountEffectImpl(8390656, 8, create, deps);
}
function updateEffect(create, deps) {
  updateEffectImpl(2048, 8, create, deps);
}
function useEffectEventImpl(payload) {
  currentlyRenderingFiber.flags |= 4;
  var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (null === componentUpdateQueue)
    (componentUpdateQueue = createFunctionComponentUpdateQueue()),
      (currentlyRenderingFiber.updateQueue = componentUpdateQueue),
      (componentUpdateQueue.events = [payload]);
  else {
    var events = componentUpdateQueue.events;
    null === events
      ? (componentUpdateQueue.events = [payload])
      : events.push(payload);
  }
}
function updateEvent(callback) {
  var ref = updateWorkInProgressHook().memoizedState;
  useEffectEventImpl({ ref: ref, nextImpl: callback });
  return function () {
    if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
    return ref.impl.apply(void 0, arguments);
  };
}
function updateInsertionEffect(create, deps) {
  return updateEffectImpl(4, 2, create, deps);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(4, 4, create, deps);
}
function imperativeHandleEffect(create, ref) {
  if ("function" === typeof ref) {
    create = create();
    var refCleanup = ref(create);
    return function () {
      "function" === typeof refCleanup ? refCleanup() : ref(null);
    };
  }
  if (null !== ref && void 0 !== ref)
    return (
      (create = create()),
      (ref.current = create),
      function () {
        ref.current = null;
      }
    );
}
function updateImperativeHandle(ref, create, deps) {
  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
}
function mountDebugValue() {}
function updateCallback(callback, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  hook.memoizedState = [callback, deps];
  return callback;
}
function updateMemo(nextCreate, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  prevState = nextCreate();
  if (shouldDoubleInvokeUserFnsInHooksDEV) {
    setIsStrictModeForDevtools(!0);
    try {
      nextCreate();
    } finally {
      setIsStrictModeForDevtools(!1);
    }
  }
  hook.memoizedState = [prevState, deps];
  return prevState;
}
function mountDeferredValueImpl(hook, value, initialValue) {
  if (
    void 0 === initialValue ||
    (0 !== (renderLanes & 1073741824) &&
      0 === (workInProgressRootRenderLanes & 261930))
  )
    return (hook.memoizedState = value);
  hook.memoizedState = initialValue;
  hook = requestDeferredLane();
  currentlyRenderingFiber.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return initialValue;
}
function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
  if (objectIs(value, prevValue)) return value;
  if (null !== currentTreeHiddenStackCursor.current)
    return (
      (hook = mountDeferredValueImpl(hook, value, initialValue)),
      objectIs(hook, prevValue) || (didReceiveUpdate = !0),
      hook
    );
  if (
    0 === (renderLanes & 42) ||
    (0 !== (renderLanes & 1073741824) &&
      0 === (workInProgressRootRenderLanes & 261930))
  )
    return (didReceiveUpdate = !0), (hook.memoizedState = value);
  hook = requestDeferredLane();
  currentlyRenderingFiber.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return prevValue;
}
function startTransition(fiber, queue, pendingState, finishedState, callback) {
  var previousPriority = ReactDOMSharedInternals.p;
  ReactDOMSharedInternals.p =
    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
  var prevTransition = ReactSharedInternals.T,
    currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  dispatchOptimisticSetState(fiber, !1, queue, pendingState);
  try {
    var returnValue = callback(),
      onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish &&
      onStartTransitionFinish(currentTransition, returnValue);
    if (
      null !== returnValue &&
      "object" === typeof returnValue &&
      "function" === typeof returnValue.then
    ) {
      var thenableForFinishedState = chainThenableValue(
        returnValue,
        finishedState
      );
      dispatchSetStateInternal(
        fiber,
        queue,
        thenableForFinishedState,
        requestUpdateLane(fiber)
      );
    } else
      dispatchSetStateInternal(
        fiber,
        queue,
        finishedState,
        requestUpdateLane(fiber)
      );
  } catch (error) {
    dispatchSetStateInternal(
      fiber,
      queue,
      { then: function () {}, status: "rejected", reason: error },
      requestUpdateLane()
    );
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      null !== prevTransition &&
        null !== currentTransition.types &&
        (prevTransition.types = currentTransition.types),
      (ReactSharedInternals.T = prevTransition);
  }
}
function noop() {}
function startHostTransition(formFiber, pendingState, action, formData) {
  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
  var queue = ensureFormComponentIsStateful(formFiber).queue;
  startTransition(
    formFiber,
    queue,
    pendingState,
    sharedNotPendingObject,
    null === action
      ? noop
      : function () {
          requestFormReset$1(formFiber);
          return action(formData);
        }
  );
}
function ensureFormComponentIsStateful(formFiber) {
  var existingStateHook = formFiber.memoizedState;
  if (null !== existingStateHook) return existingStateHook;
  existingStateHook = {
    memoizedState: sharedNotPendingObject,
    baseState: sharedNotPendingObject,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: sharedNotPendingObject
    },
    next: null
  };
  var initialResetState = {};
  existingStateHook.next = {
    memoizedState: initialResetState,
    baseState: initialResetState,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialResetState
    },
    next: null
  };
  formFiber.memoizedState = existingStateHook;
  formFiber = formFiber.alternate;
  null !== formFiber && (formFiber.memoizedState = existingStateHook);
  return existingStateHook;
}
function requestFormReset$1(formFiber) {
  var stateHook = ensureFormComponentIsStateful(formFiber);
  null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
  dispatchSetStateInternal(
    formFiber,
    stateHook.next.queue,
    {},
    requestUpdateLane()
  );
}
function useHostTransitionStatus() {
  return readContext(HostTransitionContext);
}
function updateId() {
  return updateWorkInProgressHook().memoizedState;
}
function updateRefresh() {
  return updateWorkInProgressHook().memoizedState;
}
function refreshCache(fiber) {
  for (var provider = fiber.return; null !== provider; ) {
    switch (provider.tag) {
      case 24:
      case 3:
        var lane = requestUpdateLane();
        fiber = createUpdate(lane);
        var root$69 = enqueueUpdate(provider, fiber, lane);
        null !== root$69 &&
          (scheduleUpdateOnFiber(root$69, provider, lane),
          entangleTransitions(root$69, provider, lane));
        provider = { cache: createCache() };
        fiber.payload = provider;
        return;
    }
    provider = provider.return;
  }
}
function dispatchReducerAction(fiber, queue, action) {
  var lane = requestUpdateLane();
  action = {
    lane: lane,
    revertLane: 0,
    gesture: null,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  isRenderPhaseUpdate(fiber)
    ? enqueueRenderPhaseUpdate(queue, action)
    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),
      null !== action &&
        (scheduleUpdateOnFiber(action, fiber, lane),
        entangleTransitionUpdate(action, queue, lane)));
}
function dispatchSetState(fiber, queue, action) {
  var lane = requestUpdateLane();
  dispatchSetStateInternal(fiber, queue, action, lane);
}
function dispatchSetStateInternal(fiber, queue, action, lane) {
  var update = {
    lane: lane,
    revertLane: 0,
    gesture: null,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
  else {
    var alternate = fiber.alternate;
    if (
      0 === fiber.lanes &&
      (null === alternate || 0 === alternate.lanes) &&
      ((alternate = queue.lastRenderedReducer), null !== alternate)
    )
      try {
        var currentState = queue.lastRenderedState,
          eagerState = alternate(currentState, action);
        update.hasEagerState = !0;
        update.eagerState = eagerState;
        if (objectIs(eagerState, currentState))
          return (
            enqueueUpdate$1(fiber, queue, update, 0),
            null === workInProgressRoot && finishQueueingConcurrentUpdates(),
            !1
          );
      } catch (error) {
      } finally {
      }
    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (null !== action)
      return (
        scheduleUpdateOnFiber(action, fiber, lane),
        entangleTransitionUpdate(action, queue, lane),
        !0
      );
  }
  return !1;
}
function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
  action = {
    lane: 2,
    revertLane: requestTransitionLane(),
    gesture: null,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) {
    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
  } else
    (throwIfDuringRender = enqueueConcurrentHookUpdate(
      fiber,
      queue,
      action,
      2
    )),
      null !== throwIfDuringRender &&
        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
}
function isRenderPhaseUpdate(fiber) {
  var alternate = fiber.alternate;
  return (
    fiber === currentlyRenderingFiber ||
    (null !== alternate && alternate === currentlyRenderingFiber)
  );
}
function enqueueRenderPhaseUpdate(queue, update) {
  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =
    !0;
  var pending = queue.pending;
  null === pending
    ? (update.next = update)
    : ((update.next = pending.next), (pending.next = update));
  queue.pending = update;
}
function entangleTransitionUpdate(root, queue, lane) {
  if (0 !== (lane & 4194048)) {
    var queueLanes = queue.lanes;
    queueLanes &= root.pendingLanes;
    lane |= queueLanes;
    queue.lanes = lane;
    markRootEntangled(root, lane);
  }
}
var ContextOnlyDispatcher = {
  readContext: readContext,
  use: use,
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useInsertionEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useDebugValue: throwInvalidHookError,
  useDeferredValue: throwInvalidHookError,
  useTransition: throwInvalidHookError,
  useSyncExternalStore: throwInvalidHookError,
  useId: throwInvalidHookError,
  useHostTransitionStatus: throwInvalidHookError,
  useFormState: throwInvalidHookError,
  useActionState: throwInvalidHookError,
  useOptimistic: throwInvalidHookError,
  useMemoCache: throwInvalidHookError,
  useCacheRefresh: throwInvalidHookError
};
ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
var HooksDispatcherOnMount = {
    readContext: readContext,
    use: use,
    useCallback: function (callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        void 0 === deps ? null : deps
      ];
      return callback;
    },
    useContext: readContext,
    useEffect: mountEffect,
    useImperativeHandle: function (ref, create, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      mountEffectImpl(
        4194308,
        4,
        imperativeHandleEffect.bind(null, create, ref),
        deps
      );
    },
    useLayoutEffect: function (create, deps) {
      return mountEffectImpl(4194308, 4, create, deps);
    },
    useInsertionEffect: function (create, deps) {
      mountEffectImpl(4, 2, create, deps);
    },
    useMemo: function (nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    },
    useReducer: function (reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (void 0 !== init) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
      } else initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(
        null,
        currentlyRenderingFiber,
        reducer
      );
      return [hook.memoizedState, reducer];
    },
    useRef: function (initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return (hook.memoizedState = initialValue);
    },
    useState: function (initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue,
        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function (value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    },
    useTransition: function () {
      var stateHook = mountStateImpl(!1);
      stateHook = startTransition.bind(
        null,
        currentlyRenderingFiber,
        stateHook.queue,
        !0,
        !1
      );
      mountWorkInProgressHook().memoizedState = stateHook;
      return [!1, stateHook];
    },
    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber,
        hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (void 0 === getServerSnapshot)
          throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else {
        getServerSnapshot = getSnapshot();
        if (null === workInProgressRoot)
          throw Error(formatProdErrorMessage(349));
        0 !== (workInProgressRootRenderLanes & 127) ||
          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      hook.memoizedState = getServerSnapshot;
      var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };
      hook.queue = inst;
      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
        subscribe
      ]);
      fiber.flags |= 2048;
      pushSimpleEffect(
        9,
        { destroy: void 0 },
        updateStoreInstance.bind(
          null,
          fiber,
          inst,
          getServerSnapshot,
          getSnapshot
        ),
        null
      );
      return getServerSnapshot;
    },
    useId: function () {
      var hook = mountWorkInProgressHook(),
        identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var JSCompiler_inline_result = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        JSCompiler_inline_result =
          (
            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
          ).toString(32) + JSCompiler_inline_result;
        identifierPrefix =
          "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
        JSCompiler_inline_result = localIdCounter++;
        0 < JSCompiler_inline_result &&
          (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
        identifierPrefix += "_";
      } else
        (JSCompiler_inline_result = globalClientIdCounter++),
          (identifierPrefix =
            "_" +
            identifierPrefix +
            "r_" +
            JSCompiler_inline_result.toString(32) +
            "_");
      return (hook.memoizedState = identifierPrefix);
    },
    useHostTransitionStatus: useHostTransitionStatus,
    useFormState: mountActionState,
    useActionState: mountActionState,
    useOptimistic: function (passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        !0,
        queue
      );
      queue.dispatch = hook;
      return [passthrough, hook];
    },
    useMemoCache: useMemoCache,
    useCacheRefresh: function () {
      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
        null,
        currentlyRenderingFiber
      ));
    },
    useEffectEvent: function (callback) {
      var hook = mountWorkInProgressHook(),
        ref = { impl: callback };
      hook.memoizedState = ref;
      return function () {
        if (0 !== (executionContext & 2))
          throw Error(formatProdErrorMessage(440));
        return ref.impl.apply(void 0, arguments);
      };
    }
  },
  HooksDispatcherOnUpdate = {
    readContext: readContext,
    use: use,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useInsertionEffect: updateInsertionEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: updateReducer,
    useRef: updateRef,
    useState: function () {
      return updateReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function (value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(
        hook,
        currentHook.memoizedState,
        value,
        initialValue
      );
    },
    useTransition: function () {
      var booleanOrThenable = updateReducer(basicStateReducer)[0],
        start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable
          ? booleanOrThenable
          : useThenable(booleanOrThenable),
        start
      ];
    },
    useSyncExternalStore: updateSyncExternalStore,
    useId: updateId,
    useHostTransitionStatus: useHostTransitionStatus,
    useFormState: updateActionState,
    useActionState: updateActionState,
    useOptimistic: function (passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    },
    useMemoCache: useMemoCache,
    useCacheRefresh: updateRefresh
  };
HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
var HooksDispatcherOnRerender = {
  readContext: readContext,
  use: use,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: rerenderReducer,
  useRef: updateRef,
  useState: function () {
    return rerenderReducer(basicStateReducer);
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function (value, initialValue) {
    var hook = updateWorkInProgressHook();
    return null === currentHook
      ? mountDeferredValueImpl(hook, value, initialValue)
      : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
  },
  useTransition: function () {
    var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
      start = updateWorkInProgressHook().memoizedState;
    return [
      "boolean" === typeof booleanOrThenable
        ? booleanOrThenable
        : useThenable(booleanOrThenable),
      start
    ];
  },
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId,
  useHostTransitionStatus: useHostTransitionStatus,
  useFormState: rerenderActionState,
  useActionState: rerenderActionState,
  useOptimistic: function (passthrough, reducer) {
    var hook = updateWorkInProgressHook();
    if (null !== currentHook)
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    hook.baseState = passthrough;
    return [passthrough, hook.queue.dispatch];
  },
  useMemoCache: useMemoCache,
  useCacheRefresh: updateRefresh
};
HooksDispatcherOnRerender.useEffectEvent = updateEvent;
function applyDerivedStateFromProps(
  workInProgress,
  ctor,
  getDerivedStateFromProps,
  nextProps
) {
  ctor = workInProgress.memoizedState;
  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
  getDerivedStateFromProps =
    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
      ? ctor
      : assign({}, ctor, getDerivedStateFromProps);
  workInProgress.memoizedState = getDerivedStateFromProps;
  0 === workInProgress.lanes &&
    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
}
var classComponentUpdater = {
  enqueueSetState: function (inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload &&
      (scheduleUpdateOnFiber(payload, inst, lane),
      entangleTransitions(payload, inst, lane));
  },
  enqueueReplaceState: function (inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.tag = 1;
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload &&
      (scheduleUpdateOnFiber(payload, inst, lane),
      entangleTransitions(payload, inst, lane));
  },
  enqueueForceUpdate: function (inst, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.tag = 2;
    void 0 !== callback && null !== callback && (update.callback = callback);
    callback = enqueueUpdate(inst, update, lane);
    null !== callback &&
      (scheduleUpdateOnFiber(callback, inst, lane),
      entangleTransitions(callback, inst, lane));
  }
};
function checkShouldComponentUpdate(
  workInProgress,
  ctor,
  oldProps,
  newProps,
  oldState,
  newState,
  nextContext
) {
  workInProgress = workInProgress.stateNode;
  return "function" === typeof workInProgress.shouldComponentUpdate
    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)
    : ctor.prototype && ctor.prototype.isPureReactComponent
      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
      : !0;
}
function callComponentWillReceiveProps(
  workInProgress,
  instance,
  newProps,
  nextContext
) {
  workInProgress = instance.state;
  "function" === typeof instance.componentWillReceiveProps &&
    instance.componentWillReceiveProps(newProps, nextContext);
  "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  instance.state !== workInProgress &&
    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
}
function resolveClassComponentProps(Component, baseProps) {
  var newProps = baseProps;
  if ("ref" in baseProps) {
    newProps = {};
    for (var propName in baseProps)
      "ref" !== propName && (newProps[propName] = baseProps[propName]);
  }
  if ((Component = Component.defaultProps)) {
    newProps === baseProps && (newProps = assign({}, newProps));
    for (var propName$73 in Component)
      void 0 === newProps[propName$73] &&
        (newProps[propName$73] = Component[propName$73]);
  }
  return newProps;
}
function defaultOnUncaughtError(error) {
  reportGlobalError(error);
}
function defaultOnCaughtError(error) {
  console.error(error);
}
function defaultOnRecoverableError(error) {
  reportGlobalError(error);
}
function logUncaughtError(root, errorInfo) {
  try {
    var onUncaughtError = root.onUncaughtError;
    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
  } catch (e$74) {
    setTimeout(function () {
      throw e$74;
    });
  }
}
function logCaughtError(root, boundary, errorInfo) {
  try {
    var onCaughtError = root.onCaughtError;
    onCaughtError(errorInfo.value, {
      componentStack: errorInfo.stack,
      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
    });
  } catch (e$75) {
    setTimeout(function () {
      throw e$75;
    });
  }
}
function createRootErrorUpdate(root, errorInfo, lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  lane.payload = { element: null };
  lane.callback = function () {
    logUncaughtError(root, errorInfo);
  };
  return lane;
}
function createClassErrorUpdate(lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  return lane;
}
function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
  if ("function" === typeof getDerivedStateFromError) {
    var error = errorInfo.value;
    update.payload = function () {
      return getDerivedStateFromError(error);
    };
    update.callback = function () {
      logCaughtError(root, fiber, errorInfo);
    };
  }
  var inst = fiber.stateNode;
  null !== inst &&
    "function" === typeof inst.componentDidCatch &&
    (update.callback = function () {
      logCaughtError(root, fiber, errorInfo);
      "function" !== typeof getDerivedStateFromError &&
        (null === legacyErrorBoundariesThatAlreadyFailed
          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
          : legacyErrorBoundariesThatAlreadyFailed.add(this));
      var stack = errorInfo.stack;
      this.componentDidCatch(errorInfo.value, {
        componentStack: null !== stack ? stack : ""
      });
    });
}
function throwException(
  root,
  returnFiber,
  sourceFiber,
  value,
  rootRenderLanes
) {
  sourceFiber.flags |= 32768;
  if (
    null !== value &&
    "object" === typeof value &&
    "function" === typeof value.then
  ) {
    returnFiber = sourceFiber.alternate;
    null !== returnFiber &&
      propagateParentContextChanges(
        returnFiber,
        sourceFiber,
        rootRenderLanes,
        !0
      );
    sourceFiber = suspenseHandlerStackCursor.current;
    if (null !== sourceFiber) {
      switch (sourceFiber.tag) {
        case 31:
        case 13:
          return (
            null === shellBoundary
              ? renderDidSuspendDelayIfPossible()
              : null === sourceFiber.alternate &&
                0 === workInProgressRootExitStatus &&
                (workInProgressRootExitStatus = 3),
            (sourceFiber.flags &= -257),
            (sourceFiber.flags |= 65536),
            (sourceFiber.lanes = rootRenderLanes),
            value === noopSuspenseyCommitThenable
              ? (sourceFiber.flags |= 16384)
              : ((returnFiber = sourceFiber.updateQueue),
                null === returnFiber
                  ? (sourceFiber.updateQueue = new Set([value]))
                  : returnFiber.add(value),
                attachPingListener(root, value, rootRenderLanes)),
            !1
          );
        case 22:
          return (
            (sourceFiber.flags |= 65536),
            value === noopSuspenseyCommitThenable
              ? (sourceFiber.flags |= 16384)
              : ((returnFiber = sourceFiber.updateQueue),
                null === returnFiber
                  ? ((returnFiber = {
                      transitions: null,
                      markerInstances: null,
                      retryQueue: new Set([value])
                    }),
                    (sourceFiber.updateQueue = returnFiber))
                  : ((sourceFiber = returnFiber.retryQueue),
                    null === sourceFiber
                      ? (returnFiber.retryQueue = new Set([value]))
                      : sourceFiber.add(value)),
                attachPingListener(root, value, rootRenderLanes)),
            !1
          );
      }
      throw Error(formatProdErrorMessage(435, sourceFiber.tag));
    }
    attachPingListener(root, value, rootRenderLanes);
    renderDidSuspendDelayIfPossible();
    return !1;
  }
  if (isHydrating)
    return (
      (returnFiber = suspenseHandlerStackCursor.current),
      null !== returnFiber
        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
          (returnFiber.flags |= 65536),
          (returnFiber.lanes = rootRenderLanes),
          value !== HydrationMismatchException &&
            ((root = Error(formatProdErrorMessage(422), { cause: value })),
            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))
        : (value !== HydrationMismatchException &&
            ((returnFiber = Error(formatProdErrorMessage(423), {
              cause: value
            })),
            queueHydrationError(
              createCapturedValueAtFiber(returnFiber, sourceFiber)
            )),
          (root = root.current.alternate),
          (root.flags |= 65536),
          (rootRenderLanes &= -rootRenderLanes),
          (root.lanes |= rootRenderLanes),
          (value = createCapturedValueAtFiber(value, sourceFiber)),
          (rootRenderLanes = createRootErrorUpdate(
            root.stateNode,
            value,
            rootRenderLanes
          )),
          enqueueCapturedUpdate(root, rootRenderLanes),
          4 !== workInProgressRootExitStatus &&
            (workInProgressRootExitStatus = 2)),
      !1
    );
  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
  null === workInProgressRootConcurrentErrors
    ? (workInProgressRootConcurrentErrors = [wrapperError])
    : workInProgressRootConcurrentErrors.push(wrapperError);
  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
  if (null === returnFiber) return !0;
  value = createCapturedValueAtFiber(value, sourceFiber);
  sourceFiber = returnFiber;
  do {
    switch (sourceFiber.tag) {
      case 3:
        return (
          (sourceFiber.flags |= 65536),
          (root = rootRenderLanes & -rootRenderLanes),
          (sourceFiber.lanes |= root),
          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),
          enqueueCapturedUpdate(sourceFiber, root),
          !1
        );
      case 1:
        if (
          ((returnFiber = sourceFiber.type),
          (wrapperError = sourceFiber.stateNode),
          0 === (sourceFiber.flags & 128) &&
            ("function" === typeof returnFiber.getDerivedStateFromError ||
              (null !== wrapperError &&
                "function" === typeof wrapperError.componentDidCatch &&
                (null === legacyErrorBoundariesThatAlreadyFailed ||
                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))
        )
          return (
            (sourceFiber.flags |= 65536),
            (rootRenderLanes &= -rootRenderLanes),
            (sourceFiber.lanes |= rootRenderLanes),
            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
            initializeClassErrorUpdate(
              rootRenderLanes,
              root,
              sourceFiber,
              value
            ),
            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
            !1
          );
    }
    sourceFiber = sourceFiber.return;
  } while (null !== sourceFiber);
  return !1;
}
var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
  didReceiveUpdate = !1;
function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  workInProgress.child =
    null === current
      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
      : reconcileChildFibers(
          workInProgress,
          current.child,
          nextChildren,
          renderLanes
        );
}
function updateForwardRef(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  Component = Component.render;
  var ref = workInProgress.ref;
  if ("ref" in nextProps) {
    var propsWithoutRef = {};
    for (var key in nextProps)
      "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
  } else propsWithoutRef = nextProps;
  prepareToReadContext(workInProgress);
  nextProps = renderWithHooks(
    current,
    workInProgress,
    Component,
    propsWithoutRef,
    ref,
    renderLanes
  );
  key = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && key && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  return workInProgress.child;
}
function updateMemoComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  if (null === current) {
    var type = Component.type;
    if (
      "function" === typeof type &&
      !shouldConstruct(type) &&
      void 0 === type.defaultProps &&
      null === Component.compare
    )
      return (
        (workInProgress.tag = 15),
        (workInProgress.type = type),
        updateSimpleMemoComponent(
          current,
          workInProgress,
          type,
          nextProps,
          renderLanes
        )
      );
    current = createFiberFromTypeAndProps(
      Component.type,
      null,
      nextProps,
      workInProgress,
      workInProgress.mode,
      renderLanes
    );
    current.ref = workInProgress.ref;
    current.return = workInProgress;
    return (workInProgress.child = current);
  }
  type = current.child;
  if (!checkScheduledUpdateOrContext(current, renderLanes)) {
    var prevProps = type.memoizedProps;
    Component = Component.compare;
    Component = null !== Component ? Component : shallowEqual;
    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  workInProgress.flags |= 1;
  current = createWorkInProgress(type, nextProps);
  current.ref = workInProgress.ref;
  current.return = workInProgress;
  return (workInProgress.child = current);
}
function updateSimpleMemoComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  if (null !== current) {
    var prevProps = current.memoizedProps;
    if (
      shallowEqual(prevProps, nextProps) &&
      current.ref === workInProgress.ref
    )
      if (
        ((didReceiveUpdate = !1),
        (workInProgress.pendingProps = nextProps = prevProps),
        checkScheduledUpdateOrContext(current, renderLanes))
      )
        0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
      else
        return (
          (workInProgress.lanes = current.lanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
  }
  return updateFunctionComponent(
    current,
    workInProgress,
    Component,
    nextProps,
    renderLanes
  );
}
function updateOffscreenComponent(
  current,
  workInProgress,
  renderLanes,
  nextProps
) {
  var nextChildren = nextProps.children,
    prevState = null !== current ? current.memoizedState : null;
  null === current &&
    null === workInProgress.stateNode &&
    (workInProgress.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    });
  if ("hidden" === nextProps.mode) {
    if (0 !== (workInProgress.flags & 128)) {
      prevState =
        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
      if (null !== current) {
        nextProps = workInProgress.child = current.child;
        for (nextChildren = 0; null !== nextProps; )
          (nextChildren =
            nextChildren | nextProps.lanes | nextProps.childLanes),
            (nextProps = nextProps.sibling);
        nextProps = nextChildren & ~prevState;
      } else (nextProps = 0), (workInProgress.child = null);
      return deferHiddenOffscreenComponent(
        current,
        workInProgress,
        prevState,
        renderLanes,
        nextProps
      );
    }
    if (0 !== (renderLanes & 536870912))
      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
        null !== current &&
          pushTransition(
            workInProgress,
            null !== prevState ? prevState.cachePool : null
          ),
        null !== prevState
          ? pushHiddenContext(workInProgress, prevState)
          : reuseHiddenContextOnStack(),
        pushOffscreenSuspenseHandler(workInProgress);
    else
      return (
        (nextProps = workInProgress.lanes = 536870912),
        deferHiddenOffscreenComponent(
          current,
          workInProgress,
          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,
          renderLanes,
          nextProps
        )
      );
  } else
    null !== prevState
      ? (pushTransition(workInProgress, prevState.cachePool),
        pushHiddenContext(workInProgress, prevState),
        reuseSuspenseHandlerOnStack(workInProgress),
        (workInProgress.memoizedState = null))
      : (null !== current && pushTransition(workInProgress, null),
        reuseHiddenContextOnStack(),
        reuseSuspenseHandlerOnStack(workInProgress));
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
function bailoutOffscreenComponent(current, workInProgress) {
  (null !== current && 22 === current.tag) ||
    null !== workInProgress.stateNode ||
    (workInProgress.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    });
  return workInProgress.sibling;
}
function deferHiddenOffscreenComponent(
  current,
  workInProgress,
  nextBaseLanes,
  renderLanes,
  remainingChildLanes
) {
  var JSCompiler_inline_result = peekCacheFromPool();
  JSCompiler_inline_result =
    null === JSCompiler_inline_result
      ? null
      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
  workInProgress.memoizedState = {
    baseLanes: nextBaseLanes,
    cachePool: JSCompiler_inline_result
  };
  null !== current && pushTransition(workInProgress, null);
  reuseHiddenContextOnStack();
  pushOffscreenSuspenseHandler(workInProgress);
  null !== current &&
    propagateParentContextChanges(current, workInProgress, renderLanes, !0);
  workInProgress.childLanes = remainingChildLanes;
  return null;
}
function mountActivityChildren(workInProgress, nextProps) {
  nextProps = mountWorkInProgressOffscreenFiber(
    { mode: nextProps.mode, children: nextProps.children },
    workInProgress.mode
  );
  nextProps.ref = workInProgress.ref;
  workInProgress.child = nextProps;
  nextProps.return = workInProgress;
  return nextProps;
}
function retryActivityComponentWithoutHydrating(
  current,
  workInProgress,
  renderLanes
) {
  reconcileChildFibers(workInProgress, current.child, null, renderLanes);
  current = mountActivityChildren(workInProgress, workInProgress.pendingProps);
  current.flags |= 2;
  popSuspenseHandler(workInProgress);
  workInProgress.memoizedState = null;
  return current;
}
function updateActivityComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    didSuspend = 0 !== (workInProgress.flags & 128);
  workInProgress.flags &= -129;
  if (null === current) {
    if (isHydrating) {
      if ("hidden" === nextProps.mode)
        return (
          (current = mountActivityChildren(workInProgress, nextProps)),
          (workInProgress.lanes = 536870912),
          bailoutOffscreenComponent(null, current)
        );
      pushDehydratedActivitySuspenseHandler(workInProgress);
      (current = nextHydratableInstance)
        ? ((current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          )),
          (current = null !== current && "&" === current.data ? current : null),
          null !== current &&
            ((workInProgress.memoizedState = {
              dehydrated: current,
              treeContext:
                null !== treeContextProvider
                  ? { id: treeContextId, overflow: treeContextOverflow }
                  : null,
              retryLane: 536870912,
              hydrationErrors: null
            }),
            (renderLanes = createFiberFromDehydratedFragment(current)),
            (renderLanes.return = workInProgress),
            (workInProgress.child = renderLanes),
            (hydrationParentFiber = workInProgress),
            (nextHydratableInstance = null)))
        : (current = null);
      if (null === current) throw throwOnHydrationMismatch(workInProgress);
      workInProgress.lanes = 536870912;
      return null;
    }
    return mountActivityChildren(workInProgress, nextProps);
  }
  var prevState = current.memoizedState;
  if (null !== prevState) {
    var dehydrated = prevState.dehydrated;
    pushDehydratedActivitySuspenseHandler(workInProgress);
    if (didSuspend)
      if (workInProgress.flags & 256)
        (workInProgress.flags &= -257),
          (workInProgress = retryActivityComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes
          ));
      else if (null !== workInProgress.memoizedState)
        (workInProgress.child = current.child),
          (workInProgress.flags |= 128),
          (workInProgress = null);
      else throw Error(formatProdErrorMessage(558));
    else if (
      (didReceiveUpdate ||
        propagateParentContextChanges(current, workInProgress, renderLanes, !1),
      (didSuspend = 0 !== (renderLanes & current.childLanes)),
      didReceiveUpdate || didSuspend)
    ) {
      nextProps = workInProgressRoot;
      if (
        null !== nextProps &&
        ((dehydrated = getBumpedLaneForHydration(nextProps, renderLanes)),
        0 !== dehydrated && dehydrated !== prevState.retryLane)
      )
        throw (
          ((prevState.retryLane = dehydrated),
          enqueueConcurrentRenderForLane(current, dehydrated),
          scheduleUpdateOnFiber(nextProps, current, dehydrated),
          SelectiveHydrationException)
        );
      renderDidSuspendDelayIfPossible();
      workInProgress = retryActivityComponentWithoutHydrating(
        current,
        workInProgress,
        renderLanes
      );
    } else
      (current = prevState.treeContext),
        (nextHydratableInstance = getNextHydratable(dehydrated.nextSibling)),
        (hydrationParentFiber = workInProgress),
        (isHydrating = !0),
        (hydrationErrors = null),
        (rootOrSingletonContext = !1),
        null !== current &&
          restoreSuspendedTreeContext(workInProgress, current),
        (workInProgress = mountActivityChildren(workInProgress, nextProps)),
        (workInProgress.flags |= 4096);
    return workInProgress;
  }
  current = createWorkInProgress(current.child, {
    mode: nextProps.mode,
    children: nextProps.children
  });
  current.ref = workInProgress.ref;
  workInProgress.child = current;
  current.return = workInProgress;
  return current;
}
function markRef(current, workInProgress) {
  var ref = workInProgress.ref;
  if (null === ref)
    null !== current &&
      null !== current.ref &&
      (workInProgress.flags |= 4194816);
  else {
    if ("function" !== typeof ref && "object" !== typeof ref)
      throw Error(formatProdErrorMessage(284));
    if (null === current || current.ref !== ref)
      workInProgress.flags |= 4194816;
  }
}
function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  Component = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    void 0,
    renderLanes
  );
  nextProps = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, Component, renderLanes);
  return workInProgress.child;
}
function replayFunctionComponent(
  current,
  workInProgress,
  nextProps,
  Component,
  secondArg,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  workInProgress.updateQueue = null;
  nextProps = renderWithHooksAgain(
    workInProgress,
    Component,
    nextProps,
    secondArg
  );
  finishRenderingHooks(current);
  Component = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && Component && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  return workInProgress.child;
}
function updateClassComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  if (null === workInProgress.stateNode) {
    var context = emptyContextObject,
      contextType = Component.contextType;
    "object" === typeof contextType &&
      null !== contextType &&
      (context = readContext(contextType));
    context = new Component(nextProps, context);
    workInProgress.memoizedState =
      null !== context.state && void 0 !== context.state ? context.state : null;
    context.updater = classComponentUpdater;
    workInProgress.stateNode = context;
    context._reactInternals = workInProgress;
    context = workInProgress.stateNode;
    context.props = nextProps;
    context.state = workInProgress.memoizedState;
    context.refs = {};
    initializeUpdateQueue(workInProgress);
    contextType = Component.contextType;
    context.context =
      "object" === typeof contextType && null !== contextType
        ? readContext(contextType)
        : emptyContextObject;
    context.state = workInProgress.memoizedState;
    contextType = Component.getDerivedStateFromProps;
    "function" === typeof contextType &&
      (applyDerivedStateFromProps(
        workInProgress,
        Component,
        contextType,
        nextProps
      ),
      (context.state = workInProgress.memoizedState));
    "function" === typeof Component.getDerivedStateFromProps ||
      "function" === typeof context.getSnapshotBeforeUpdate ||
      ("function" !== typeof context.UNSAFE_componentWillMount &&
        "function" !== typeof context.componentWillMount) ||
      ((contextType = context.state),
      "function" === typeof context.componentWillMount &&
        context.componentWillMount(),
      "function" === typeof context.UNSAFE_componentWillMount &&
        context.UNSAFE_componentWillMount(),
      contextType !== context.state &&
        classComponentUpdater.enqueueReplaceState(context, context.state, null),
      processUpdateQueue(workInProgress, nextProps, context, renderLanes),
      suspendIfUpdateReadFromEntangledAsyncAction(),
      (context.state = workInProgress.memoizedState));
    "function" === typeof context.componentDidMount &&
      (workInProgress.flags |= 4194308);
    nextProps = !0;
  } else if (null === current) {
    context = workInProgress.stateNode;
    var unresolvedOldProps = workInProgress.memoizedProps,
      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
    context.props = oldProps;
    var oldContext = context.context,
      contextType$jscomp$0 = Component.contextType;
    contextType = emptyContextObject;
    "object" === typeof contextType$jscomp$0 &&
      null !== contextType$jscomp$0 &&
      (contextType = readContext(contextType$jscomp$0));
    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
    contextType$jscomp$0 =
      "function" === typeof getDerivedStateFromProps ||
      "function" === typeof context.getSnapshotBeforeUpdate;
    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
    contextType$jscomp$0 ||
      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
        "function" !== typeof context.componentWillReceiveProps) ||
      ((unresolvedOldProps || oldContext !== contextType) &&
        callComponentWillReceiveProps(
          workInProgress,
          context,
          nextProps,
          contextType
        ));
    hasForceUpdate = !1;
    var oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
    suspendIfUpdateReadFromEntangledAsyncAction();
    oldContext = workInProgress.memoizedState;
    unresolvedOldProps || oldState !== oldContext || hasForceUpdate
      ? ("function" === typeof getDerivedStateFromProps &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            getDerivedStateFromProps,
            nextProps
          ),
          (oldContext = workInProgress.memoizedState)),
        (oldProps =
          hasForceUpdate ||
          checkShouldComponentUpdate(
            workInProgress,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          ))
          ? (contextType$jscomp$0 ||
              ("function" !== typeof context.UNSAFE_componentWillMount &&
                "function" !== typeof context.componentWillMount) ||
              ("function" === typeof context.componentWillMount &&
                context.componentWillMount(),
              "function" === typeof context.UNSAFE_componentWillMount &&
                context.UNSAFE_componentWillMount()),
            "function" === typeof context.componentDidMount &&
              (workInProgress.flags |= 4194308))
          : ("function" === typeof context.componentDidMount &&
              (workInProgress.flags |= 4194308),
            (workInProgress.memoizedProps = nextProps),
            (workInProgress.memoizedState = oldContext)),
        (context.props = nextProps),
        (context.state = oldContext),
        (context.context = contextType),
        (nextProps = oldProps))
      : ("function" === typeof context.componentDidMount &&
          (workInProgress.flags |= 4194308),
        (nextProps = !1));
  } else {
    context = workInProgress.stateNode;
    cloneUpdateQueue(current, workInProgress);
    contextType = workInProgress.memoizedProps;
    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
    context.props = contextType$jscomp$0;
    getDerivedStateFromProps = workInProgress.pendingProps;
    oldState = context.context;
    oldContext = Component.contextType;
    oldProps = emptyContextObject;
    "object" === typeof oldContext &&
      null !== oldContext &&
      (oldProps = readContext(oldContext));
    unresolvedOldProps = Component.getDerivedStateFromProps;
    (oldContext =
      "function" === typeof unresolvedOldProps ||
      "function" === typeof context.getSnapshotBeforeUpdate) ||
      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
        "function" !== typeof context.componentWillReceiveProps) ||
      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&
        callComponentWillReceiveProps(
          workInProgress,
          context,
          nextProps,
          oldProps
        ));
    hasForceUpdate = !1;
    oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
    suspendIfUpdateReadFromEntangledAsyncAction();
    var newState = workInProgress.memoizedState;
    contextType !== getDerivedStateFromProps ||
    oldState !== newState ||
    hasForceUpdate ||
    (null !== current &&
      null !== current.dependencies &&
      checkIfContextChanged(current.dependencies))
      ? ("function" === typeof unresolvedOldProps &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            unresolvedOldProps,
            nextProps
          ),
          (newState = workInProgress.memoizedState)),
        (contextType$jscomp$0 =
          hasForceUpdate ||
          checkShouldComponentUpdate(
            workInProgress,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) ||
          (null !== current &&
            null !== current.dependencies &&
            checkIfContextChanged(current.dependencies)))
          ? (oldContext ||
              ("function" !== typeof context.UNSAFE_componentWillUpdate &&
                "function" !== typeof context.componentWillUpdate) ||
              ("function" === typeof context.componentWillUpdate &&
                context.componentWillUpdate(nextProps, newState, oldProps),
              "function" === typeof context.UNSAFE_componentWillUpdate &&
                context.UNSAFE_componentWillUpdate(
                  nextProps,
                  newState,
                  oldProps
                )),
            "function" === typeof context.componentDidUpdate &&
              (workInProgress.flags |= 4),
            "function" === typeof context.getSnapshotBeforeUpdate &&
              (workInProgress.flags |= 1024))
          : ("function" !== typeof context.componentDidUpdate ||
              (contextType === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 4),
            "function" !== typeof context.getSnapshotBeforeUpdate ||
              (contextType === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 1024),
            (workInProgress.memoizedProps = nextProps),
            (workInProgress.memoizedState = newState)),
        (context.props = nextProps),
        (context.state = newState),
        (context.context = oldProps),
        (nextProps = contextType$jscomp$0))
      : ("function" !== typeof context.componentDidUpdate ||
          (contextType === current.memoizedProps &&
            oldState === current.memoizedState) ||
          (workInProgress.flags |= 4),
        "function" !== typeof context.getSnapshotBeforeUpdate ||
          (contextType === current.memoizedProps &&
            oldState === current.memoizedState) ||
          (workInProgress.flags |= 1024),
        (nextProps = !1));
  }
  context = nextProps;
  markRef(current, workInProgress);
  nextProps = 0 !== (workInProgress.flags & 128);
  context || nextProps
    ? ((context = workInProgress.stateNode),
      (Component =
        nextProps && "function" !== typeof Component.getDerivedStateFromError
          ? null
          : context.render()),
      (workInProgress.flags |= 1),
      null !== current && nextProps
        ? ((workInProgress.child = reconcileChildFibers(
            workInProgress,
            current.child,
            null,
            renderLanes
          )),
          (workInProgress.child = reconcileChildFibers(
            workInProgress,
            null,
            Component,
            renderLanes
          )))
        : reconcileChildren(current, workInProgress, Component, renderLanes),
      (workInProgress.memoizedState = context.state),
      (current = workInProgress.child))
    : (current = bailoutOnAlreadyFinishedWork(
        current,
        workInProgress,
        renderLanes
      ));
  return current;
}
function mountHostRootWithoutHydrating(
  current,
  workInProgress,
  nextChildren,
  renderLanes
) {
  resetHydrationState();
  workInProgress.flags |= 256;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
var SUSPENDED_MARKER = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0,
  hydrationErrors: null
};
function mountSuspenseOffscreenState(renderLanes) {
  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
}
function getRemainingWorkInPrimaryTree(
  current,
  primaryTreeDidDefer,
  renderLanes
) {
  current = null !== current ? current.childLanes & ~renderLanes : 0;
  primaryTreeDidDefer && (current |= workInProgressDeferredLane);
  return current;
}
function updateSuspenseComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    showFallback = !1,
    didSuspend = 0 !== (workInProgress.flags & 128),
    JSCompiler_temp;
  (JSCompiler_temp = didSuspend) ||
    (JSCompiler_temp =
      null !== current && null === current.memoizedState
        ? !1
        : 0 !== (suspenseStackCursor.current & 2));
  JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));
  JSCompiler_temp = 0 !== (workInProgress.flags & 32);
  workInProgress.flags &= -33;
  if (null === current) {
    if (isHydrating) {
      showFallback
        ? pushPrimaryTreeSuspenseHandler(workInProgress)
        : reuseSuspenseHandlerOnStack(workInProgress);
      (current = nextHydratableInstance)
        ? ((current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          )),
          (current = null !== current && "&" !== current.data ? current : null),
          null !== current &&
            ((workInProgress.memoizedState = {
              dehydrated: current,
              treeContext:
                null !== treeContextProvider
                  ? { id: treeContextId, overflow: treeContextOverflow }
                  : null,
              retryLane: 536870912,
              hydrationErrors: null
            }),
            (renderLanes = createFiberFromDehydratedFragment(current)),
            (renderLanes.return = workInProgress),
            (workInProgress.child = renderLanes),
            (hydrationParentFiber = workInProgress),
            (nextHydratableInstance = null)))
        : (current = null);
      if (null === current) throw throwOnHydrationMismatch(workInProgress);
      isSuspenseInstanceFallback(current)
        ? (workInProgress.lanes = 32)
        : (workInProgress.lanes = 536870912);
      return null;
    }
    var nextPrimaryChildren = nextProps.children;
    nextProps = nextProps.fallback;
    if (showFallback)
      return (
        reuseSuspenseHandlerOnStack(workInProgress),
        (showFallback = workInProgress.mode),
        (nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "hidden", children: nextPrimaryChildren },
          showFallback
        )),
        (nextProps = createFiberFromFragment(
          nextProps,
          showFallback,
          renderLanes,
          null
        )),
        (nextPrimaryChildren.return = workInProgress),
        (nextProps.return = workInProgress),
        (nextPrimaryChildren.sibling = nextProps),
        (workInProgress.child = nextPrimaryChildren),
        (nextProps = workInProgress.child),
        (nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes)),
        (nextProps.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes
        )),
        (workInProgress.memoizedState = SUSPENDED_MARKER),
        bailoutOffscreenComponent(null, nextProps)
      );
    pushPrimaryTreeSuspenseHandler(workInProgress);
    return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);
  }
  var prevState = current.memoizedState;
  if (
    null !== prevState &&
    ((nextPrimaryChildren = prevState.dehydrated), null !== nextPrimaryChildren)
  ) {
    if (didSuspend)
      workInProgress.flags & 256
        ? (pushPrimaryTreeSuspenseHandler(workInProgress),
          (workInProgress.flags &= -257),
          (workInProgress = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes
          )))
        : null !== workInProgress.memoizedState
          ? (reuseSuspenseHandlerOnStack(workInProgress),
            (workInProgress.child = current.child),
            (workInProgress.flags |= 128),
            (workInProgress = null))
          : (reuseSuspenseHandlerOnStack(workInProgress),
            (nextPrimaryChildren = nextProps.fallback),
            (showFallback = workInProgress.mode),
            (nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              showFallback
            )),
            (nextPrimaryChildren = createFiberFromFragment(
              nextPrimaryChildren,
              showFallback,
              renderLanes,
              null
            )),
            (nextPrimaryChildren.flags |= 2),
            (nextProps.return = workInProgress),
            (nextPrimaryChildren.return = workInProgress),
            (nextProps.sibling = nextPrimaryChildren),
            (workInProgress.child = nextProps),
            reconcileChildFibers(
              workInProgress,
              current.child,
              null,
              renderLanes
            ),
            (nextProps = workInProgress.child),
            (nextProps.memoizedState =
              mountSuspenseOffscreenState(renderLanes)),
            (nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes
            )),
            (workInProgress.memoizedState = SUSPENDED_MARKER),
            (workInProgress = bailoutOffscreenComponent(null, nextProps)));
    else if (
      (pushPrimaryTreeSuspenseHandler(workInProgress),
      isSuspenseInstanceFallback(nextPrimaryChildren))
    ) {
      JSCompiler_temp =
        nextPrimaryChildren.nextSibling &&
        nextPrimaryChildren.nextSibling.dataset;
      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
      JSCompiler_temp = digest;
      nextProps = Error(formatProdErrorMessage(419));
      nextProps.stack = "";
      nextProps.digest = JSCompiler_temp;
      queueHydrationError({ value: nextProps, source: null, stack: null });
      workInProgress = retrySuspenseComponentWithoutHydrating(
        current,
        workInProgress,
        renderLanes
      );
    } else if (
      (didReceiveUpdate ||
        propagateParentContextChanges(current, workInProgress, renderLanes, !1),
      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
      didReceiveUpdate || JSCompiler_temp)
    ) {
      JSCompiler_temp = workInProgressRoot;
      if (
        null !== JSCompiler_temp &&
        ((nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes)),
        0 !== nextProps && nextProps !== prevState.retryLane)
      )
        throw (
          ((prevState.retryLane = nextProps),
          enqueueConcurrentRenderForLane(current, nextProps),
          scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
          SelectiveHydrationException)
        );
      isSuspenseInstancePending(nextPrimaryChildren) ||
        renderDidSuspendDelayIfPossible();
      workInProgress = retrySuspenseComponentWithoutHydrating(
        current,
        workInProgress,
        renderLanes
      );
    } else
      isSuspenseInstancePending(nextPrimaryChildren)
        ? ((workInProgress.flags |= 192),
          (workInProgress.child = current.child),
          (workInProgress = null))
        : ((current = prevState.treeContext),
          (nextHydratableInstance = getNextHydratable(
            nextPrimaryChildren.nextSibling
          )),
          (hydrationParentFiber = workInProgress),
          (isHydrating = !0),
          (hydrationErrors = null),
          (rootOrSingletonContext = !1),
          null !== current &&
            restoreSuspendedTreeContext(workInProgress, current),
          (workInProgress = mountSuspensePrimaryChildren(
            workInProgress,
            nextProps.children
          )),
          (workInProgress.flags |= 4096));
    return workInProgress;
  }
  if (showFallback)
    return (
      reuseSuspenseHandlerOnStack(workInProgress),
      (nextPrimaryChildren = nextProps.fallback),
      (showFallback = workInProgress.mode),
      (prevState = current.child),
      (digest = prevState.sibling),
      (nextProps = createWorkInProgress(prevState, {
        mode: "hidden",
        children: nextProps.children
      })),
      (nextProps.subtreeFlags = prevState.subtreeFlags & 65011712),
      null !== digest
        ? (nextPrimaryChildren = createWorkInProgress(
            digest,
            nextPrimaryChildren
          ))
        : ((nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            showFallback,
            renderLanes,
            null
          )),
          (nextPrimaryChildren.flags |= 2)),
      (nextPrimaryChildren.return = workInProgress),
      (nextProps.return = workInProgress),
      (nextProps.sibling = nextPrimaryChildren),
      (workInProgress.child = nextProps),
      bailoutOffscreenComponent(null, nextProps),
      (nextProps = workInProgress.child),
      (nextPrimaryChildren = current.child.memoizedState),
      null === nextPrimaryChildren
        ? (nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes))
        : ((showFallback = nextPrimaryChildren.cachePool),
          null !== showFallback
            ? ((prevState = CacheContext._currentValue),
              (showFallback =
                showFallback.parent !== prevState
                  ? { parent: prevState, pool: prevState }
                  : showFallback))
            : (showFallback = getSuspendedCache()),
          (nextPrimaryChildren = {
            baseLanes: nextPrimaryChildren.baseLanes | renderLanes,
            cachePool: showFallback
          })),
      (nextProps.memoizedState = nextPrimaryChildren),
      (nextProps.childLanes = getRemainingWorkInPrimaryTree(
        current,
        JSCompiler_temp,
        renderLanes
      )),
      (workInProgress.memoizedState = SUSPENDED_MARKER),
      bailoutOffscreenComponent(current.child, nextProps)
    );
  pushPrimaryTreeSuspenseHandler(workInProgress);
  renderLanes = current.child;
  current = renderLanes.sibling;
  renderLanes = createWorkInProgress(renderLanes, {
    mode: "visible",
    children: nextProps.children
  });
  renderLanes.return = workInProgress;
  renderLanes.sibling = null;
  null !== current &&
    ((JSCompiler_temp = workInProgress.deletions),
    null === JSCompiler_temp
      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))
      : JSCompiler_temp.push(current));
  workInProgress.child = renderLanes;
  workInProgress.memoizedState = null;
  return renderLanes;
}
function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
  primaryChildren = mountWorkInProgressOffscreenFiber(
    { mode: "visible", children: primaryChildren },
    workInProgress.mode
  );
  primaryChildren.return = workInProgress;
  return (workInProgress.child = primaryChildren);
}
function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
  offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
  offscreenProps.lanes = 0;
  return offscreenProps;
}
function retrySuspenseComponentWithoutHydrating(
  current,
  workInProgress,
  renderLanes
) {
  reconcileChildFibers(workInProgress, current.child, null, renderLanes);
  current = mountSuspensePrimaryChildren(
    workInProgress,
    workInProgress.pendingProps.children
  );
  current.flags |= 2;
  workInProgress.memoizedState = null;
  return current;
}
function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
  fiber.lanes |= renderLanes;
  var alternate = fiber.alternate;
  null !== alternate && (alternate.lanes |= renderLanes);
  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
}
function initSuspenseListRenderState(
  workInProgress,
  isBackwards,
  tail,
  lastContentRow,
  tailMode,
  treeForkCount
) {
  var renderState = workInProgress.memoizedState;
  null === renderState
    ? (workInProgress.memoizedState = {
        isBackwards: isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail: tail,
        tailMode: tailMode,
        treeForkCount: treeForkCount
      })
    : ((renderState.isBackwards = isBackwards),
      (renderState.rendering = null),
      (renderState.renderingStartTime = 0),
      (renderState.last = lastContentRow),
      (renderState.tail = tail),
      (renderState.tailMode = tailMode),
      (renderState.treeForkCount = treeForkCount));
}
function updateSuspenseListComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    revealOrder = nextProps.revealOrder,
    tailMode = nextProps.tail;
  nextProps = nextProps.children;
  var suspenseContext = suspenseStackCursor.current,
    shouldForceFallback = 0 !== (suspenseContext & 2);
  shouldForceFallback
    ? ((suspenseContext = (suspenseContext & 1) | 2),
      (workInProgress.flags |= 128))
    : (suspenseContext &= 1);
  push(suspenseStackCursor, suspenseContext);
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  nextProps = isHydrating ? treeForkCount : 0;
  if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
    a: for (current = workInProgress.child; null !== current; ) {
      if (13 === current.tag)
        null !== current.memoizedState &&
          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
      else if (19 === current.tag)
        scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
      else if (null !== current.child) {
        current.child.return = current;
        current = current.child;
        continue;
      }
      if (current === workInProgress) break a;
      for (; null === current.sibling; ) {
        if (null === current.return || current.return === workInProgress)
          break a;
        current = current.return;
      }
      current.sibling.return = current.return;
      current = current.sibling;
    }
  switch (revealOrder) {
    case "forwards":
      renderLanes = workInProgress.child;
      for (revealOrder = null; null !== renderLanes; )
        (current = renderLanes.alternate),
          null !== current &&
            null === findFirstSuspended(current) &&
            (revealOrder = renderLanes),
          (renderLanes = renderLanes.sibling);
      renderLanes = revealOrder;
      null === renderLanes
        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))
        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
      initSuspenseListRenderState(
        workInProgress,
        !1,
        revealOrder,
        renderLanes,
        tailMode,
        nextProps
      );
      break;
    case "backwards":
    case "unstable_legacy-backwards":
      renderLanes = null;
      revealOrder = workInProgress.child;
      for (workInProgress.child = null; null !== revealOrder; ) {
        current = revealOrder.alternate;
        if (null !== current && null === findFirstSuspended(current)) {
          workInProgress.child = revealOrder;
          break;
        }
        current = revealOrder.sibling;
        revealOrder.sibling = renderLanes;
        renderLanes = revealOrder;
        revealOrder = current;
      }
      initSuspenseListRenderState(
        workInProgress,
        !0,
        renderLanes,
        null,
        tailMode,
        nextProps
      );
      break;
    case "together":
      initSuspenseListRenderState(
        workInProgress,
        !1,
        null,
        null,
        void 0,
        nextProps
      );
      break;
    default:
      workInProgress.memoizedState = null;
  }
  return workInProgress.child;
}
function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
  null !== current && (workInProgress.dependencies = current.dependencies);
  workInProgressRootSkippedLanes |= workInProgress.lanes;
  if (0 === (renderLanes & workInProgress.childLanes))
    if (null !== current) {
      if (
        (propagateParentContextChanges(
          current,
          workInProgress,
          renderLanes,
          !1
        ),
        0 === (renderLanes & workInProgress.childLanes))
      )
        return null;
    } else return null;
  if (null !== current && workInProgress.child !== current.child)
    throw Error(formatProdErrorMessage(153));
  if (null !== workInProgress.child) {
    current = workInProgress.child;
    renderLanes = createWorkInProgress(current, current.pendingProps);
    workInProgress.child = renderLanes;
    for (renderLanes.return = workInProgress; null !== current.sibling; )
      (current = current.sibling),
        (renderLanes = renderLanes.sibling =
          createWorkInProgress(current, current.pendingProps)),
        (renderLanes.return = workInProgress);
    renderLanes.sibling = null;
  }
  return workInProgress.child;
}
function checkScheduledUpdateOrContext(current, renderLanes) {
  if (0 !== (current.lanes & renderLanes)) return !0;
  current = current.dependencies;
  return null !== current && checkIfContextChanged(current) ? !0 : !1;
}
function attemptEarlyBailoutIfNoScheduledUpdate(
  current,
  workInProgress,
  renderLanes
) {
  switch (workInProgress.tag) {
    case 3:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
      resetHydrationState();
      break;
    case 27:
    case 5:
      pushHostContext(workInProgress);
      break;
    case 4:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      break;
    case 10:
      pushProvider(
        workInProgress,
        workInProgress.type,
        workInProgress.memoizedProps.value
      );
      break;
    case 31:
      if (null !== workInProgress.memoizedState)
        return (
          (workInProgress.flags |= 128),
          pushDehydratedActivitySuspenseHandler(workInProgress),
          null
        );
      break;
    case 13:
      var state$102 = workInProgress.memoizedState;
      if (null !== state$102) {
        if (null !== state$102.dehydrated)
          return (
            pushPrimaryTreeSuspenseHandler(workInProgress),
            (workInProgress.flags |= 128),
            null
          );
        if (0 !== (renderLanes & workInProgress.child.childLanes))
          return updateSuspenseComponent(current, workInProgress, renderLanes);
        pushPrimaryTreeSuspenseHandler(workInProgress);
        current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderLanes
        );
        return null !== current ? current.sibling : null;
      }
      pushPrimaryTreeSuspenseHandler(workInProgress);
      break;
    case 19:
      var didSuspendBefore = 0 !== (current.flags & 128);
      state$102 = 0 !== (renderLanes & workInProgress.childLanes);
      state$102 ||
        (propagateParentContextChanges(
          current,
          workInProgress,
          renderLanes,
          !1
        ),
        (state$102 = 0 !== (renderLanes & workInProgress.childLanes)));
      if (didSuspendBefore) {
        if (state$102)
          return updateSuspenseListComponent(
            current,
            workInProgress,
            renderLanes
          );
        workInProgress.flags |= 128;
      }
      didSuspendBefore = workInProgress.memoizedState;
      null !== didSuspendBefore &&
        ((didSuspendBefore.rendering = null),
        (didSuspendBefore.tail = null),
        (didSuspendBefore.lastEffect = null));
      push(suspenseStackCursor, suspenseStackCursor.current);
      if (state$102) break;
      else return null;
    case 22:
      return (
        (workInProgress.lanes = 0),
        updateOffscreenComponent(
          current,
          workInProgress,
          renderLanes,
          workInProgress.pendingProps
        )
      );
    case 24:
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
  }
  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
}
function beginWork(current, workInProgress, renderLanes) {
  if (null !== current)
    if (current.memoizedProps !== workInProgress.pendingProps)
      didReceiveUpdate = !0;
    else {
      if (
        !checkScheduledUpdateOrContext(current, renderLanes) &&
        0 === (workInProgress.flags & 128)
      )
        return (
          (didReceiveUpdate = !1),
          attemptEarlyBailoutIfNoScheduledUpdate(
            current,
            workInProgress,
            renderLanes
          )
        );
      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
    }
  else
    (didReceiveUpdate = !1),
      isHydrating &&
        0 !== (workInProgress.flags & 1048576) &&
        pushTreeId(workInProgress, treeForkCount, workInProgress.index);
  workInProgress.lanes = 0;
  switch (workInProgress.tag) {
    case 16:
      a: {
        var props = workInProgress.pendingProps;
        current = resolveLazy(workInProgress.elementType);
        workInProgress.type = current;
        if ("function" === typeof current)
          shouldConstruct(current)
            ? ((props = resolveClassComponentProps(current, props)),
              (workInProgress.tag = 1),
              (workInProgress = updateClassComponent(
                null,
                workInProgress,
                current,
                props,
                renderLanes
              )))
            : ((workInProgress.tag = 0),
              (workInProgress = updateFunctionComponent(
                null,
                workInProgress,
                current,
                props,
                renderLanes
              )));
        else {
          if (void 0 !== current && null !== current) {
            var $$typeof = current.$$typeof;
            if ($$typeof === REACT_FORWARD_REF_TYPE) {
              workInProgress.tag = 11;
              workInProgress = updateForwardRef(
                null,
                workInProgress,
                current,
                props,
                renderLanes
              );
              break a;
            } else if ($$typeof === REACT_MEMO_TYPE) {
              workInProgress.tag = 14;
              workInProgress = updateMemoComponent(
                null,
                workInProgress,
                current,
                props,
                renderLanes
              );
              break a;
            }
          }
          workInProgress = getComponentNameFromType(current) || current;
          throw Error(formatProdErrorMessage(306, workInProgress, ""));
        }
      }
      return workInProgress;
    case 0:
      return updateFunctionComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 1:
      return (
        (props = workInProgress.type),
        ($$typeof = resolveClassComponentProps(
          props,
          workInProgress.pendingProps
        )),
        updateClassComponent(
          current,
          workInProgress,
          props,
          $$typeof,
          renderLanes
        )
      );
    case 3:
      a: {
        pushHostContainer(
          workInProgress,
          workInProgress.stateNode.containerInfo
        );
        if (null === current) throw Error(formatProdErrorMessage(387));
        props = workInProgress.pendingProps;
        var prevState = workInProgress.memoizedState;
        $$typeof = prevState.element;
        cloneUpdateQueue(current, workInProgress);
        processUpdateQueue(workInProgress, props, null, renderLanes);
        var nextState = workInProgress.memoizedState;
        props = nextState.cache;
        pushProvider(workInProgress, CacheContext, props);
        props !== prevState.cache &&
          propagateContextChanges(
            workInProgress,
            [CacheContext],
            renderLanes,
            !0
          );
        suspendIfUpdateReadFromEntangledAsyncAction();
        props = nextState.element;
        if (prevState.isDehydrated)
          if (
            ((prevState = {
              element: props,
              isDehydrated: !1,
              cache: nextState.cache
            }),
            (workInProgress.updateQueue.baseState = prevState),
            (workInProgress.memoizedState = prevState),
            workInProgress.flags & 256)
          ) {
            workInProgress = mountHostRootWithoutHydrating(
              current,
              workInProgress,
              props,
              renderLanes
            );
            break a;
          } else if (props !== $$typeof) {
            $$typeof = createCapturedValueAtFiber(
              Error(formatProdErrorMessage(424)),
              workInProgress
            );
            queueHydrationError($$typeof);
            workInProgress = mountHostRootWithoutHydrating(
              current,
              workInProgress,
              props,
              renderLanes
            );
            break a;
          } else {
            current = workInProgress.stateNode.containerInfo;
            switch (current.nodeType) {
              case 9:
                current = current.body;
                break;
              default:
                current =
                  "HTML" === current.nodeName
                    ? current.ownerDocument.body
                    : current;
            }
            nextHydratableInstance = getNextHydratable(current.firstChild);
            hydrationParentFiber = workInProgress;
            isHydrating = !0;
            hydrationErrors = null;
            rootOrSingletonContext = !0;
            renderLanes = mountChildFibers(
              workInProgress,
              null,
              props,
              renderLanes
            );
            for (workInProgress.child = renderLanes; renderLanes; )
              (renderLanes.flags = (renderLanes.flags & -3) | 4096),
                (renderLanes = renderLanes.sibling);
          }
        else {
          resetHydrationState();
          if (props === $$typeof) {
            workInProgress = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress,
              renderLanes
            );
            break a;
          }
          reconcileChildren(current, workInProgress, props, renderLanes);
        }
        workInProgress = workInProgress.child;
      }
      return workInProgress;
    case 26:
      return (
        markRef(current, workInProgress),
        null === current
          ? (renderLanes = getResource(
              workInProgress.type,
              null,
              workInProgress.pendingProps,
              null
            ))
            ? (workInProgress.memoizedState = renderLanes)
            : isHydrating ||
              ((renderLanes = workInProgress.type),
              (current = workInProgress.pendingProps),
              (props = getOwnerDocumentFromRootContainer(
                rootInstanceStackCursor.current
              ).createElement(renderLanes)),
              (props[internalInstanceKey] = workInProgress),
              (props[internalPropsKey] = current),
              setInitialProperties(props, renderLanes, current),
              markNodeAsHoistable(props),
              (workInProgress.stateNode = props))
          : (workInProgress.memoizedState = getResource(
              workInProgress.type,
              current.memoizedProps,
              workInProgress.pendingProps,
              current.memoizedState
            )),
        null
      );
    case 27:
      return (
        pushHostContext(workInProgress),
        null === current &&
          isHydrating &&
          ((props = workInProgress.stateNode =
            resolveSingletonInstance(
              workInProgress.type,
              workInProgress.pendingProps,
              rootInstanceStackCursor.current
            )),
          (hydrationParentFiber = workInProgress),
          (rootOrSingletonContext = !0),
          ($$typeof = nextHydratableInstance),
          isSingletonScope(workInProgress.type)
            ? ((previousHydratableOnEnteringScopedSingleton = $$typeof),
              (nextHydratableInstance = getNextHydratable(props.firstChild)))
            : (nextHydratableInstance = $$typeof)),
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        markRef(current, workInProgress),
        null === current && (workInProgress.flags |= 4194304),
        workInProgress.child
      );
    case 5:
      if (null === current && isHydrating) {
        if (($$typeof = props = nextHydratableInstance))
          (props = canHydrateInstance(
            props,
            workInProgress.type,
            workInProgress.pendingProps,
            rootOrSingletonContext
          )),
            null !== props
              ? ((workInProgress.stateNode = props),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = getNextHydratable(props.firstChild)),
                (rootOrSingletonContext = !1),
                ($$typeof = !0))
              : ($$typeof = !1);
        $$typeof || throwOnHydrationMismatch(workInProgress);
      }
      pushHostContext(workInProgress);
      $$typeof = workInProgress.type;
      prevState = workInProgress.pendingProps;
      nextState = null !== current ? current.memoizedProps : null;
      props = prevState.children;
      shouldSetTextContent($$typeof, prevState)
        ? (props = null)
        : null !== nextState &&
          shouldSetTextContent($$typeof, nextState) &&
          (workInProgress.flags |= 32);
      null !== workInProgress.memoizedState &&
        (($$typeof = renderWithHooks(
          current,
          workInProgress,
          TransitionAwareHostComponent,
          null,
          null,
          renderLanes
        )),
        (HostTransitionContext._currentValue = $$typeof));
      markRef(current, workInProgress);
      reconcileChildren(current, workInProgress, props, renderLanes);
      return workInProgress.child;
    case 6:
      if (null === current && isHydrating) {
        if ((current = renderLanes = nextHydratableInstance))
          (renderLanes = canHydrateTextInstance(
            renderLanes,
            workInProgress.pendingProps,
            rootOrSingletonContext
          )),
            null !== renderLanes
              ? ((workInProgress.stateNode = renderLanes),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = null),
                (current = !0))
              : (current = !1);
        current || throwOnHydrationMismatch(workInProgress);
      }
      return null;
    case 13:
      return updateSuspenseComponent(current, workInProgress, renderLanes);
    case 4:
      return (
        pushHostContainer(
          workInProgress,
          workInProgress.stateNode.containerInfo
        ),
        (props = workInProgress.pendingProps),
        null === current
          ? (workInProgress.child = reconcileChildFibers(
              workInProgress,
              null,
              props,
              renderLanes
            ))
          : reconcileChildren(current, workInProgress, props, renderLanes),
        workInProgress.child
      );
    case 11:
      return updateForwardRef(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 7:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps,
          renderLanes
        ),
        workInProgress.child
      );
    case 8:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 12:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 10:
      return (
        (props = workInProgress.pendingProps),
        pushProvider(workInProgress, workInProgress.type, props.value),
        reconcileChildren(current, workInProgress, props.children, renderLanes),
        workInProgress.child
      );
    case 9:
      return (
        ($$typeof = workInProgress.type._context),
        (props = workInProgress.pendingProps.children),
        prepareToReadContext(workInProgress),
        ($$typeof = readContext($$typeof)),
        (props = props($$typeof)),
        (workInProgress.flags |= 1),
        reconcileChildren(current, workInProgress, props, renderLanes),
        workInProgress.child
      );
    case 14:
      return updateMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 15:
      return updateSimpleMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 19:
      return updateSuspenseListComponent(current, workInProgress, renderLanes);
    case 31:
      return updateActivityComponent(current, workInProgress, renderLanes);
    case 22:
      return updateOffscreenComponent(
        current,
        workInProgress,
        renderLanes,
        workInProgress.pendingProps
      );
    case 24:
      return (
        prepareToReadContext(workInProgress),
        (props = readContext(CacheContext)),
        null === current
          ? (($$typeof = peekCacheFromPool()),
            null === $$typeof &&
              (($$typeof = workInProgressRoot),
              (prevState = createCache()),
              ($$typeof.pooledCache = prevState),
              prevState.refCount++,
              null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes),
              ($$typeof = prevState)),
            (workInProgress.memoizedState = { parent: props, cache: $$typeof }),
            initializeUpdateQueue(workInProgress),
            pushProvider(workInProgress, CacheContext, $$typeof))
          : (0 !== (current.lanes & renderLanes) &&
              (cloneUpdateQueue(current, workInProgress),
              processUpdateQueue(workInProgress, null, null, renderLanes),
              suspendIfUpdateReadFromEntangledAsyncAction()),
            ($$typeof = current.memoizedState),
            (prevState = workInProgress.memoizedState),
            $$typeof.parent !== props
              ? (($$typeof = { parent: props, cache: props }),
                (workInProgress.memoizedState = $$typeof),
                0 === workInProgress.lanes &&
                  (workInProgress.memoizedState =
                    workInProgress.updateQueue.baseState =
                      $$typeof),
                pushProvider(workInProgress, CacheContext, props))
              : ((props = prevState.cache),
                pushProvider(workInProgress, CacheContext, props),
                props !== $$typeof.cache &&
                  propagateContextChanges(
                    workInProgress,
                    [CacheContext],
                    renderLanes,
                    !0
                  ))),
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 29:
      throw workInProgress.pendingProps;
  }
  throw Error(formatProdErrorMessage(156, workInProgress.tag));
}
function markUpdate(workInProgress) {
  workInProgress.flags |= 4;
}
function preloadInstanceAndSuspendIfNeeded(
  workInProgress,
  type,
  oldProps,
  newProps,
  renderLanes
) {
  if ((type = 0 !== (workInProgress.mode & 32))) type = !1;
  if (type) {
    if (
      ((workInProgress.flags |= 16777216),
      (renderLanes & 335544128) === renderLanes)
    )
      if (workInProgress.stateNode.complete) workInProgress.flags |= 8192;
      else if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
      else
        throw (
          ((suspendedThenable = noopSuspenseyCommitThenable),
          SuspenseyCommitException)
        );
  } else workInProgress.flags &= -16777217;
}
function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
    workInProgress.flags &= -16777217;
  else if (((workInProgress.flags |= 16777216), !preloadResource(resource)))
    if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
    else
      throw (
        ((suspendedThenable = noopSuspenseyCommitThenable),
        SuspenseyCommitException)
      );
}
function scheduleRetryEffect(workInProgress, retryQueue) {
  null !== retryQueue && (workInProgress.flags |= 4);
  workInProgress.flags & 16384 &&
    ((retryQueue =
      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
    (workInProgress.lanes |= retryQueue),
    (workInProgressSuspendedRetryLanes |= retryQueue));
}
function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
  if (!isHydrating)
    switch (renderState.tailMode) {
      case "hidden":
        hasRenderedATailFallback = renderState.tail;
        for (var lastTailNode = null; null !== hasRenderedATailFallback; )
          null !== hasRenderedATailFallback.alternate &&
            (lastTailNode = hasRenderedATailFallback),
            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
        null === lastTailNode
          ? (renderState.tail = null)
          : (lastTailNode.sibling = null);
        break;
      case "collapsed":
        lastTailNode = renderState.tail;
        for (var lastTailNode$106 = null; null !== lastTailNode; )
          null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode),
            (lastTailNode = lastTailNode.sibling);
        null === lastTailNode$106
          ? hasRenderedATailFallback || null === renderState.tail
            ? (renderState.tail = null)
            : (renderState.tail.sibling = null)
          : (lastTailNode$106.sibling = null);
    }
}
function bubbleProperties(completedWork) {
  var didBailout =
      null !== completedWork.alternate &&
      completedWork.alternate.child === completedWork.child,
    newChildLanes = 0,
    subtreeFlags = 0;
  if (didBailout)
    for (var child$107 = completedWork.child; null !== child$107; )
      (newChildLanes |= child$107.lanes | child$107.childLanes),
        (subtreeFlags |= child$107.subtreeFlags & 65011712),
        (subtreeFlags |= child$107.flags & 65011712),
        (child$107.return = completedWork),
        (child$107 = child$107.sibling);
  else
    for (child$107 = completedWork.child; null !== child$107; )
      (newChildLanes |= child$107.lanes | child$107.childLanes),
        (subtreeFlags |= child$107.subtreeFlags),
        (subtreeFlags |= child$107.flags),
        (child$107.return = completedWork),
        (child$107 = child$107.sibling);
  completedWork.subtreeFlags |= subtreeFlags;
  completedWork.childLanes = newChildLanes;
  return didBailout;
}
function completeWork(current, workInProgress, renderLanes) {
  var newProps = workInProgress.pendingProps;
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return bubbleProperties(workInProgress), null;
    case 1:
      return bubbleProperties(workInProgress), null;
    case 3:
      renderLanes = workInProgress.stateNode;
      newProps = null;
      null !== current && (newProps = current.memoizedState.cache);
      workInProgress.memoizedState.cache !== newProps &&
        (workInProgress.flags |= 2048);
      popProvider(CacheContext);
      popHostContainer();
      renderLanes.pendingContext &&
        ((renderLanes.context = renderLanes.pendingContext),
        (renderLanes.pendingContext = null));
      if (null === current || null === current.child)
        popHydrationState(workInProgress)
          ? markUpdate(workInProgress)
          : null === current ||
            (current.memoizedState.isDehydrated &&
              0 === (workInProgress.flags & 256)) ||
            ((workInProgress.flags |= 1024),
            upgradeHydrationErrorsToRecoverable());
      bubbleProperties(workInProgress);
      return null;
    case 26:
      var type = workInProgress.type,
        nextResource = workInProgress.memoizedState;
      null === current
        ? (markUpdate(workInProgress),
          null !== nextResource
            ? (bubbleProperties(workInProgress),
              preloadResourceAndSuspendIfNeeded(workInProgress, nextResource))
            : (bubbleProperties(workInProgress),
              preloadInstanceAndSuspendIfNeeded(
                workInProgress,
                type,
                null,
                newProps,
                renderLanes
              )))
        : nextResource
          ? nextResource !== current.memoizedState
            ? (markUpdate(workInProgress),
              bubbleProperties(workInProgress),
              preloadResourceAndSuspendIfNeeded(workInProgress, nextResource))
            : (bubbleProperties(workInProgress),
              (workInProgress.flags &= -16777217))
          : ((current = current.memoizedProps),
            current !== newProps && markUpdate(workInProgress),
            bubbleProperties(workInProgress),
            preloadInstanceAndSuspendIfNeeded(
              workInProgress,
              type,
              current,
              newProps,
              renderLanes
            ));
      return null;
    case 27:
      popHostContext(workInProgress);
      renderLanes = rootInstanceStackCursor.current;
      type = workInProgress.type;
      if (null !== current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if (!newProps) {
          if (null === workInProgress.stateNode)
            throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress);
          return null;
        }
        current = contextStackCursor.current;
        popHydrationState(workInProgress)
          ? prepareToHydrateHostInstance(workInProgress, current)
          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),
            (workInProgress.stateNode = current),
            markUpdate(workInProgress));
      }
      bubbleProperties(workInProgress);
      return null;
    case 5:
      popHostContext(workInProgress);
      type = workInProgress.type;
      if (null !== current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if (!newProps) {
          if (null === workInProgress.stateNode)
            throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress);
          return null;
        }
        nextResource = contextStackCursor.current;
        if (popHydrationState(workInProgress))
          prepareToHydrateHostInstance(workInProgress, nextResource);
        else {
          var ownerDocument = getOwnerDocumentFromRootContainer(
            rootInstanceStackCursor.current
          );
          switch (nextResource) {
            case 1:
              nextResource = ownerDocument.createElementNS(
                "http://www.w3.org/2000/svg",
                type
              );
              break;
            case 2:
              nextResource = ownerDocument.createElementNS(
                "http://www.w3.org/1998/Math/MathML",
                type
              );
              break;
            default:
              switch (type) {
                case "svg":
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/2000/svg",
                    type
                  );
                  break;
                case "math":
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    type
                  );
                  break;
                case "script":
                  nextResource = ownerDocument.createElement("div");
                  nextResource.innerHTML = "<script>\x3c/script>";
                  nextResource = nextResource.removeChild(
                    nextResource.firstChild
                  );
                  break;
                case "select":
                  nextResource =
                    "string" === typeof newProps.is
                      ? ownerDocument.createElement("select", {
                          is: newProps.is
                        })
                      : ownerDocument.createElement("select");
                  newProps.multiple
                    ? (nextResource.multiple = !0)
                    : newProps.size && (nextResource.size = newProps.size);
                  break;
                default:
                  nextResource =
                    "string" === typeof newProps.is
                      ? ownerDocument.createElement(type, { is: newProps.is })
                      : ownerDocument.createElement(type);
              }
          }
          nextResource[internalInstanceKey] = workInProgress;
          nextResource[internalPropsKey] = newProps;
          a: for (
            ownerDocument = workInProgress.child;
            null !== ownerDocument;

          ) {
            if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
              nextResource.appendChild(ownerDocument.stateNode);
            else if (
              4 !== ownerDocument.tag &&
              27 !== ownerDocument.tag &&
              null !== ownerDocument.child
            ) {
              ownerDocument.child.return = ownerDocument;
              ownerDocument = ownerDocument.child;
              continue;
            }
            if (ownerDocument === workInProgress) break a;
            for (; null === ownerDocument.sibling; ) {
              if (
                null === ownerDocument.return ||
                ownerDocument.return === workInProgress
              )
                break a;
              ownerDocument = ownerDocument.return;
            }
            ownerDocument.sibling.return = ownerDocument.return;
            ownerDocument = ownerDocument.sibling;
          }
          workInProgress.stateNode = nextResource;
          a: switch (
            (setInitialProperties(nextResource, type, newProps), type)
          ) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              newProps = !!newProps.autoFocus;
              break a;
            case "img":
              newProps = !0;
              break a;
            default:
              newProps = !1;
          }
          newProps && markUpdate(workInProgress);
        }
      }
      bubbleProperties(workInProgress);
      preloadInstanceAndSuspendIfNeeded(
        workInProgress,
        workInProgress.type,
        null === current ? null : current.memoizedProps,
        workInProgress.pendingProps,
        renderLanes
      );
      return null;
    case 6:
      if (current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if ("string" !== typeof newProps && null === workInProgress.stateNode)
          throw Error(formatProdErrorMessage(166));
        current = rootInstanceStackCursor.current;
        if (popHydrationState(workInProgress)) {
          current = workInProgress.stateNode;
          renderLanes = workInProgress.memoizedProps;
          newProps = null;
          type = hydrationParentFiber;
          if (null !== type)
            switch (type.tag) {
              case 27:
              case 5:
                newProps = type.memoizedProps;
            }
          current[internalInstanceKey] = workInProgress;
          current =
            current.nodeValue === renderLanes ||
            (null !== newProps && !0 === newProps.suppressHydrationWarning) ||
            checkForUnmatchedText(current.nodeValue, renderLanes)
              ? !0
              : !1;
          current || throwOnHydrationMismatch(workInProgress, !0);
        } else
          (current =
            getOwnerDocumentFromRootContainer(current).createTextNode(
              newProps
            )),
            (current[internalInstanceKey] = workInProgress),
            (workInProgress.stateNode = current);
      }
      bubbleProperties(workInProgress);
      return null;
    case 31:
      renderLanes = workInProgress.memoizedState;
      if (null === current || null !== current.memoizedState) {
        newProps = popHydrationState(workInProgress);
        if (null !== renderLanes) {
          if (null === current) {
            if (!newProps) throw Error(formatProdErrorMessage(318));
            current = workInProgress.memoizedState;
            current = null !== current ? current.dehydrated : null;
            if (!current) throw Error(formatProdErrorMessage(557));
            current[internalInstanceKey] = workInProgress;
          } else
            resetHydrationState(),
              0 === (workInProgress.flags & 128) &&
                (workInProgress.memoizedState = null),
              (workInProgress.flags |= 4);
          bubbleProperties(workInProgress);
          current = !1;
        } else
          (renderLanes = upgradeHydrationErrorsToRecoverable()),
            null !== current &&
              null !== current.memoizedState &&
              (current.memoizedState.hydrationErrors = renderLanes),
            (current = !0);
        if (!current) {
          if (workInProgress.flags & 256)
            return popSuspenseHandler(workInProgress), workInProgress;
          popSuspenseHandler(workInProgress);
          return null;
        }
        if (0 !== (workInProgress.flags & 128))
          throw Error(formatProdErrorMessage(558));
      }
      bubbleProperties(workInProgress);
      return null;
    case 13:
      newProps = workInProgress.memoizedState;
      if (
        null === current ||
        (null !== current.memoizedState &&
          null !== current.memoizedState.dehydrated)
      ) {
        type = popHydrationState(workInProgress);
        if (null !== newProps && null !== newProps.dehydrated) {
          if (null === current) {
            if (!type) throw Error(formatProdErrorMessage(318));
            type = workInProgress.memoizedState;
            type = null !== type ? type.dehydrated : null;
            if (!type) throw Error(formatProdErrorMessage(317));
            type[internalInstanceKey] = workInProgress;
          } else
            resetHydrationState(),
              0 === (workInProgress.flags & 128) &&
                (workInProgress.memoizedState = null),
              (workInProgress.flags |= 4);
          bubbleProperties(workInProgress);
          type = !1;
        } else
          (type = upgradeHydrationErrorsToRecoverable()),
            null !== current &&
              null !== current.memoizedState &&
              (current.memoizedState.hydrationErrors = type),
            (type = !0);
        if (!type) {
          if (workInProgress.flags & 256)
            return popSuspenseHandler(workInProgress), workInProgress;
          popSuspenseHandler(workInProgress);
          return null;
        }
      }
      popSuspenseHandler(workInProgress);
      if (0 !== (workInProgress.flags & 128))
        return (workInProgress.lanes = renderLanes), workInProgress;
      renderLanes = null !== newProps;
      current = null !== current && null !== current.memoizedState;
      renderLanes &&
        ((newProps = workInProgress.child),
        (type = null),
        null !== newProps.alternate &&
          null !== newProps.alternate.memoizedState &&
          null !== newProps.alternate.memoizedState.cachePool &&
          (type = newProps.alternate.memoizedState.cachePool.pool),
        (nextResource = null),
        null !== newProps.memoizedState &&
          null !== newProps.memoizedState.cachePool &&
          (nextResource = newProps.memoizedState.cachePool.pool),
        nextResource !== type && (newProps.flags |= 2048));
      renderLanes !== current &&
        renderLanes &&
        (workInProgress.child.flags |= 8192);
      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
      bubbleProperties(workInProgress);
      return null;
    case 4:
      return (
        popHostContainer(),
        null === current &&
          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),
        bubbleProperties(workInProgress),
        null
      );
    case 10:
      return (
        popProvider(workInProgress.type), bubbleProperties(workInProgress), null
      );
    case 19:
      pop(suspenseStackCursor);
      newProps = workInProgress.memoizedState;
      if (null === newProps) return bubbleProperties(workInProgress), null;
      type = 0 !== (workInProgress.flags & 128);
      nextResource = newProps.rendering;
      if (null === nextResource)
        if (type) cutOffTailIfNeeded(newProps, !1);
        else {
          if (
            0 !== workInProgressRootExitStatus ||
            (null !== current && 0 !== (current.flags & 128))
          )
            for (current = workInProgress.child; null !== current; ) {
              nextResource = findFirstSuspended(current);
              if (null !== nextResource) {
                workInProgress.flags |= 128;
                cutOffTailIfNeeded(newProps, !1);
                current = nextResource.updateQueue;
                workInProgress.updateQueue = current;
                scheduleRetryEffect(workInProgress, current);
                workInProgress.subtreeFlags = 0;
                current = renderLanes;
                for (renderLanes = workInProgress.child; null !== renderLanes; )
                  resetWorkInProgress(renderLanes, current),
                    (renderLanes = renderLanes.sibling);
                push(
                  suspenseStackCursor,
                  (suspenseStackCursor.current & 1) | 2
                );
                isHydrating &&
                  pushTreeFork(workInProgress, newProps.treeForkCount);
                return workInProgress.child;
              }
              current = current.sibling;
            }
          null !== newProps.tail &&
            now() > workInProgressRootRenderTargetTime &&
            ((workInProgress.flags |= 128),
            (type = !0),
            cutOffTailIfNeeded(newProps, !1),
            (workInProgress.lanes = 4194304));
        }
      else {
        if (!type)
          if (
            ((current = findFirstSuspended(nextResource)), null !== current)
          ) {
            if (
              ((workInProgress.flags |= 128),
              (type = !0),
              (current = current.updateQueue),
              (workInProgress.updateQueue = current),
              scheduleRetryEffect(workInProgress, current),
              cutOffTailIfNeeded(newProps, !0),
              null === newProps.tail &&
                "hidden" === newProps.tailMode &&
                !nextResource.alternate &&
                !isHydrating)
            )
              return bubbleProperties(workInProgress), null;
          } else
            2 * now() - newProps.renderingStartTime >
              workInProgressRootRenderTargetTime &&
              536870912 !== renderLanes &&
              ((workInProgress.flags |= 128),
              (type = !0),
              cutOffTailIfNeeded(newProps, !1),
              (workInProgress.lanes = 4194304));
        newProps.isBackwards
          ? ((nextResource.sibling = workInProgress.child),
            (workInProgress.child = nextResource))
          : ((current = newProps.last),
            null !== current
              ? (current.sibling = nextResource)
              : (workInProgress.child = nextResource),
            (newProps.last = nextResource));
      }
      if (null !== newProps.tail)
        return (
          (current = newProps.tail),
          (newProps.rendering = current),
          (newProps.tail = current.sibling),
          (newProps.renderingStartTime = now()),
          (current.sibling = null),
          (renderLanes = suspenseStackCursor.current),
          push(
            suspenseStackCursor,
            type ? (renderLanes & 1) | 2 : renderLanes & 1
          ),
          isHydrating && pushTreeFork(workInProgress, newProps.treeForkCount),
          current
        );
      bubbleProperties(workInProgress);
      return null;
    case 22:
    case 23:
      return (
        popSuspenseHandler(workInProgress),
        popHiddenContext(),
        (newProps = null !== workInProgress.memoizedState),
        null !== current
          ? (null !== current.memoizedState) !== newProps &&
            (workInProgress.flags |= 8192)
          : newProps && (workInProgress.flags |= 8192),
        newProps
          ? 0 !== (renderLanes & 536870912) &&
            0 === (workInProgress.flags & 128) &&
            (bubbleProperties(workInProgress),
            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
          : bubbleProperties(workInProgress),
        (renderLanes = workInProgress.updateQueue),
        null !== renderLanes &&
          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
        (renderLanes = null),
        null !== current &&
          null !== current.memoizedState &&
          null !== current.memoizedState.cachePool &&
          (renderLanes = current.memoizedState.cachePool.pool),
        (newProps = null),
        null !== workInProgress.memoizedState &&
          null !== workInProgress.memoizedState.cachePool &&
          (newProps = workInProgress.memoizedState.cachePool.pool),
        newProps !== renderLanes && (workInProgress.flags |= 2048),
        null !== current && pop(resumedCache),
        null
      );
    case 24:
      return (
        (renderLanes = null),
        null !== current && (renderLanes = current.memoizedState.cache),
        workInProgress.memoizedState.cache !== renderLanes &&
          (workInProgress.flags |= 2048),
        popProvider(CacheContext),
        bubbleProperties(workInProgress),
        null
      );
    case 25:
      return null;
    case 30:
      return null;
  }
  throw Error(formatProdErrorMessage(156, workInProgress.tag));
}
function unwindWork(current, workInProgress) {
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 1:
      return (
        (current = workInProgress.flags),
        current & 65536
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 3:
      return (
        popProvider(CacheContext),
        popHostContainer(),
        (current = workInProgress.flags),
        0 !== (current & 65536) && 0 === (current & 128)
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 26:
    case 27:
    case 5:
      return popHostContext(workInProgress), null;
    case 31:
      if (null !== workInProgress.memoizedState) {
        popSuspenseHandler(workInProgress);
        if (null === workInProgress.alternate)
          throw Error(formatProdErrorMessage(340));
        resetHydrationState();
      }
      current = workInProgress.flags;
      return current & 65536
        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
        : null;
    case 13:
      popSuspenseHandler(workInProgress);
      current = workInProgress.memoizedState;
      if (null !== current && null !== current.dehydrated) {
        if (null === workInProgress.alternate)
          throw Error(formatProdErrorMessage(340));
        resetHydrationState();
      }
      current = workInProgress.flags;
      return current & 65536
        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
        : null;
    case 19:
      return pop(suspenseStackCursor), null;
    case 4:
      return popHostContainer(), null;
    case 10:
      return popProvider(workInProgress.type), null;
    case 22:
    case 23:
      return (
        popSuspenseHandler(workInProgress),
        popHiddenContext(),
        null !== current && pop(resumedCache),
        (current = workInProgress.flags),
        current & 65536
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 24:
      return popProvider(CacheContext), null;
    case 25:
      return null;
    default:
      return null;
  }
}
function unwindInterruptedWork(current, interruptedWork) {
  popTreeContext(interruptedWork);
  switch (interruptedWork.tag) {
    case 3:
      popProvider(CacheContext);
      popHostContainer();
      break;
    case 26:
    case 27:
    case 5:
      popHostContext(interruptedWork);
      break;
    case 4:
      popHostContainer();
      break;
    case 31:
      null !== interruptedWork.memoizedState &&
        popSuspenseHandler(interruptedWork);
      break;
    case 13:
      popSuspenseHandler(interruptedWork);
      break;
    case 19:
      pop(suspenseStackCursor);
      break;
    case 10:
      popProvider(interruptedWork.type);
      break;
    case 22:
    case 23:
      popSuspenseHandler(interruptedWork);
      popHiddenContext();
      null !== current && pop(resumedCache);
      break;
    case 24:
      popProvider(CacheContext);
  }
}
function commitHookEffectListMount(flags, finishedWork) {
  try {
    var updateQueue = finishedWork.updateQueue,
      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          lastEffect = void 0;
          var create = updateQueue.create,
            inst = updateQueue.inst;
          lastEffect = create();
          inst.destroy = lastEffect;
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHookEffectListUnmount(
  flags,
  finishedWork,
  nearestMountedAncestor$jscomp$0
) {
  try {
    var updateQueue = finishedWork.updateQueue,
      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          var inst = updateQueue.inst,
            destroy = inst.destroy;
          if (void 0 !== destroy) {
            inst.destroy = void 0;
            lastEffect = finishedWork;
            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
              destroy_ = destroy;
            try {
              destroy_();
            } catch (error) {
              captureCommitPhaseError(
                lastEffect,
                nearestMountedAncestor,
                error
              );
            }
          }
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitClassCallbacks(finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  if (null !== updateQueue) {
    var instance = finishedWork.stateNode;
    try {
      commitCallbacks(updateQueue, instance);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function safelyCallComponentWillUnmount(
  current,
  nearestMountedAncestor,
  instance
) {
  instance.props = resolveClassComponentProps(
    current.type,
    current.memoizedProps
  );
  instance.state = current.memoizedState;
  try {
    instance.componentWillUnmount();
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyAttachRef(current, nearestMountedAncestor) {
  try {
    var ref = current.ref;
    if (null !== ref) {
      switch (current.tag) {
        case 26:
        case 27:
        case 5:
          var instanceToUse = current.stateNode;
          break;
        case 30:
          instanceToUse = current.stateNode;
          break;
        default:
          instanceToUse = current.stateNode;
      }
      "function" === typeof ref
        ? (current.refCleanup = ref(instanceToUse))
        : (ref.current = instanceToUse);
    }
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyDetachRef(current, nearestMountedAncestor) {
  var ref = current.ref,
    refCleanup = current.refCleanup;
  if (null !== ref)
    if ("function" === typeof refCleanup)
      try {
        refCleanup();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      } finally {
        (current.refCleanup = null),
          (current = current.alternate),
          null != current && (current.refCleanup = null);
      }
    else if ("function" === typeof ref)
      try {
        ref(null);
      } catch (error$140) {
        captureCommitPhaseError(current, nearestMountedAncestor, error$140);
      }
    else ref.current = null;
}
function commitHostMount(finishedWork) {
  var type = finishedWork.type,
    props = finishedWork.memoizedProps,
    instance = finishedWork.stateNode;
  try {
    a: switch (type) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        props.autoFocus && instance.focus();
        break a;
      case "img":
        props.src
          ? (instance.src = props.src)
          : props.srcSet && (instance.srcset = props.srcSet);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostUpdate(finishedWork, newProps, oldProps) {
  try {
    var domElement = finishedWork.stateNode;
    updateProperties(domElement, finishedWork.type, oldProps, newProps);
    domElement[internalPropsKey] = newProps;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function isHostParent(fiber) {
  return (
    5 === fiber.tag ||
    3 === fiber.tag ||
    26 === fiber.tag ||
    (27 === fiber.tag && isSingletonScope(fiber.type)) ||
    4 === fiber.tag
  );
}
function getHostSibling(fiber) {
  a: for (;;) {
    for (; null === fiber.sibling; ) {
      if (null === fiber.return || isHostParent(fiber.return)) return null;
      fiber = fiber.return;
    }
    fiber.sibling.return = fiber.return;
    for (
      fiber = fiber.sibling;
      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;

    ) {
      if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
      if (fiber.flags & 2) continue a;
      if (null === fiber.child || 4 === fiber.tag) continue a;
      else (fiber.child.return = fiber), (fiber = fiber.child);
    }
    if (!(fiber.flags & 2)) return fiber.stateNode;
  }
}
function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag)
    (node = node.stateNode),
      before
        ? (9 === parent.nodeType
            ? parent.body
            : "HTML" === parent.nodeName
              ? parent.ownerDocument.body
              : parent
          ).insertBefore(node, before)
        : ((before =
            9 === parent.nodeType
              ? parent.body
              : "HTML" === parent.nodeName
                ? parent.ownerDocument.body
                : parent),
          before.appendChild(node),
          (parent = parent._reactRootContainer),
          (null !== parent && void 0 !== parent) ||
            null !== before.onclick ||
            (before.onclick = noop$1));
  else if (
    4 !== tag &&
    (27 === tag &&
      isSingletonScope(node.type) &&
      ((parent = node.stateNode), (before = null)),
    (node = node.child),
    null !== node)
  )
    for (
      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
        node = node.sibling;
      null !== node;

    )
      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
        (node = node.sibling);
}
function insertOrAppendPlacementNode(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag)
    (node = node.stateNode),
      before ? parent.insertBefore(node, before) : parent.appendChild(node);
  else if (
    4 !== tag &&
    (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),
    (node = node.child),
    null !== node)
  )
    for (
      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      null !== node;

    )
      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
}
function commitHostSingletonAcquisition(finishedWork) {
  var singleton = finishedWork.stateNode,
    props = finishedWork.memoizedProps;
  try {
    for (
      var type = finishedWork.type, attributes = singleton.attributes;
      attributes.length;

    )
      singleton.removeAttributeNode(attributes[0]);
    setInitialProperties(singleton, type, props);
    singleton[internalInstanceKey] = finishedWork;
    singleton[internalPropsKey] = props;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
var offscreenSubtreeIsHidden = !1,
  offscreenSubtreeWasHidden = !1,
  needsFormReset = !1,
  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
  nextEffect = null;
function commitBeforeMutationEffects(root, firstChild) {
  root = root.containerInfo;
  eventsEnabled = _enabled;
  root = getActiveElementDeep(root);
  if (hasSelectionCapabilities(root)) {
    if ("selectionStart" in root)
      var JSCompiler_temp = {
        start: root.selectionStart,
        end: root.selectionEnd
      };
    else
      a: {
        JSCompiler_temp =
          ((JSCompiler_temp = root.ownerDocument) &&
            JSCompiler_temp.defaultView) ||
          window;
        var selection =
          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
        if (selection && 0 !== selection.rangeCount) {
          JSCompiler_temp = selection.anchorNode;
          var anchorOffset = selection.anchorOffset,
            focusNode = selection.focusNode;
          selection = selection.focusOffset;
          try {
            JSCompiler_temp.nodeType, focusNode.nodeType;
          } catch (e$20) {
            JSCompiler_temp = null;
            break a;
          }
          var length = 0,
            start = -1,
            end = -1,
            indexWithinAnchor = 0,
            indexWithinFocus = 0,
            node = root,
            parentNode = null;
          b: for (;;) {
            for (var next; ; ) {
              node !== JSCompiler_temp ||
                (0 !== anchorOffset && 3 !== node.nodeType) ||
                (start = length + anchorOffset);
              node !== focusNode ||
                (0 !== selection && 3 !== node.nodeType) ||
                (end = length + selection);
              3 === node.nodeType && (length += node.nodeValue.length);
              if (null === (next = node.firstChild)) break;
              parentNode = node;
              node = next;
            }
            for (;;) {
              if (node === root) break b;
              parentNode === JSCompiler_temp &&
                ++indexWithinAnchor === anchorOffset &&
                (start = length);
              parentNode === focusNode &&
                ++indexWithinFocus === selection &&
                (end = length);
              if (null !== (next = node.nextSibling)) break;
              node = parentNode;
              parentNode = node.parentNode;
            }
            node = next;
          }
          JSCompiler_temp =
            -1 === start || -1 === end ? null : { start: start, end: end };
        } else JSCompiler_temp = null;
      }
    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
  } else JSCompiler_temp = null;
  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };
  _enabled = !1;
  for (nextEffect = firstChild; null !== nextEffect; )
    if (
      ((firstChild = nextEffect),
      (root = firstChild.child),
      0 !== (firstChild.subtreeFlags & 1028) && null !== root)
    )
      (root.return = firstChild), (nextEffect = root);
    else
      for (; null !== nextEffect; ) {
        firstChild = nextEffect;
        focusNode = firstChild.alternate;
        root = firstChild.flags;
        switch (firstChild.tag) {
          case 0:
            if (
              0 !== (root & 4) &&
              ((root = firstChild.updateQueue),
              (root = null !== root ? root.events : null),
              null !== root)
            )
              for (
                JSCompiler_temp = 0;
                JSCompiler_temp < root.length;
                JSCompiler_temp++
              )
                (anchorOffset = root[JSCompiler_temp]),
                  (anchorOffset.ref.impl = anchorOffset.nextImpl);
            break;
          case 11:
          case 15:
            break;
          case 1:
            if (0 !== (root & 1024) && null !== focusNode) {
              root = void 0;
              JSCompiler_temp = firstChild;
              anchorOffset = focusNode.memoizedProps;
              focusNode = focusNode.memoizedState;
              selection = JSCompiler_temp.stateNode;
              try {
                var resolvedPrevProps = resolveClassComponentProps(
                  JSCompiler_temp.type,
                  anchorOffset
                );
                root = selection.getSnapshotBeforeUpdate(
                  resolvedPrevProps,
                  focusNode
                );
                selection.__reactInternalSnapshotBeforeUpdate = root;
              } catch (error) {
                captureCommitPhaseError(
                  JSCompiler_temp,
                  JSCompiler_temp.return,
                  error
                );
              }
            }
            break;
          case 3:
            if (0 !== (root & 1024))
              if (
                ((root = firstChild.stateNode.containerInfo),
                (JSCompiler_temp = root.nodeType),
                9 === JSCompiler_temp)
              )
                clearContainerSparingly(root);
              else if (1 === JSCompiler_temp)
                switch (root.nodeName) {
                  case "HEAD":
                  case "HTML":
                  case "BODY":
                    clearContainerSparingly(root);
                    break;
                  default:
                    root.textContent = "";
                }
            break;
          case 5:
          case 26:
          case 27:
          case 6:
          case 4:
          case 17:
            break;
          default:
            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
        }
        root = firstChild.sibling;
        if (null !== root) {
          root.return = firstChild.return;
          nextEffect = root;
          break;
        }
        nextEffect = firstChild.return;
      }
}
function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitHookEffectListMount(5, finishedWork);
      break;
    case 1:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags & 4)
        if (((finishedRoot = finishedWork.stateNode), null === current))
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        else {
          var prevProps = resolveClassComponentProps(
            finishedWork.type,
            current.memoizedProps
          );
          current = current.memoizedState;
          try {
            finishedRoot.componentDidUpdate(
              prevProps,
              current,
              finishedRoot.__reactInternalSnapshotBeforeUpdate
            );
          } catch (error$139) {
            captureCommitPhaseError(
              finishedWork,
              finishedWork.return,
              error$139
            );
          }
        }
      flags & 64 && commitClassCallbacks(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (
        flags & 64 &&
        ((finishedRoot = finishedWork.updateQueue), null !== finishedRoot)
      ) {
        current = null;
        if (null !== finishedWork.child)
          switch (finishedWork.child.tag) {
            case 27:
            case 5:
              current = finishedWork.child.stateNode;
              break;
            case 1:
              current = finishedWork.child.stateNode;
          }
        try {
          commitCallbacks(finishedRoot, current);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 27:
      null === current &&
        flags & 4 &&
        commitHostSingletonAcquisition(finishedWork);
    case 26:
    case 5:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      null === current && flags & 4 && commitHostMount(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 12:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      break;
    case 31:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
      break;
    case 13:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
      flags & 64 &&
        ((finishedRoot = finishedWork.memoizedState),
        null !== finishedRoot &&
          ((finishedRoot = finishedRoot.dehydrated),
          null !== finishedRoot &&
            ((finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            )),
            registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
      break;
    case 22:
      flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
      if (!flags) {
        current =
          (null !== current && null !== current.memoizedState) ||
          offscreenSubtreeWasHidden;
        prevProps = offscreenSubtreeIsHidden;
        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = flags;
        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden
          ? recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              0 !== (finishedWork.subtreeFlags & 8772)
            )
          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        offscreenSubtreeIsHidden = prevProps;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      }
      break;
    case 30:
      break;
    default:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
  }
}
function detachFiberAfterEffects(fiber) {
  var alternate = fiber.alternate;
  null !== alternate &&
    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
  fiber.child = null;
  fiber.deletions = null;
  fiber.sibling = null;
  5 === fiber.tag &&
    ((alternate = fiber.stateNode),
    null !== alternate && detachDeletedInstance(alternate));
  fiber.stateNode = null;
  fiber.return = null;
  fiber.dependencies = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.stateNode = null;
  fiber.updateQueue = null;
}
var hostParent = null,
  hostParentIsContainer = !1;
function recursivelyTraverseDeletionEffects(
  finishedRoot,
  nearestMountedAncestor,
  parent
) {
  for (parent = parent.child; null !== parent; )
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
      (parent = parent.sibling);
}
function commitDeletionEffectsOnFiber(
  finishedRoot,
  nearestMountedAncestor,
  deletedFiber
) {
  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
    try {
      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
    } catch (err) {}
  switch (deletedFiber.tag) {
    case 26:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      deletedFiber.memoizedState
        ? deletedFiber.memoizedState.count--
        : deletedFiber.stateNode &&
          ((deletedFiber = deletedFiber.stateNode),
          deletedFiber.parentNode.removeChild(deletedFiber));
      break;
    case 27:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
      var prevHostParent = hostParent,
        prevHostParentIsContainer = hostParentIsContainer;
      isSingletonScope(deletedFiber.type) &&
        ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = !1));
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      releaseSingletonInstance(deletedFiber.stateNode);
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 5:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
    case 6:
      prevHostParent = hostParent;
      prevHostParentIsContainer = hostParentIsContainer;
      hostParent = null;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      if (null !== hostParent)
        if (hostParentIsContainer)
          try {
            (9 === hostParent.nodeType
              ? hostParent.body
              : "HTML" === hostParent.nodeName
                ? hostParent.ownerDocument.body
                : hostParent
            ).removeChild(deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(
              deletedFiber,
              nearestMountedAncestor,
              error
            );
          }
        else
          try {
            hostParent.removeChild(deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(
              deletedFiber,
              nearestMountedAncestor,
              error
            );
          }
      break;
    case 18:
      null !== hostParent &&
        (hostParentIsContainer
          ? ((finishedRoot = hostParent),
            clearHydrationBoundary(
              9 === finishedRoot.nodeType
                ? finishedRoot.body
                : "HTML" === finishedRoot.nodeName
                  ? finishedRoot.ownerDocument.body
                  : finishedRoot,
              deletedFiber.stateNode
            ),
            retryIfBlockedOn(finishedRoot))
          : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
      break;
    case 4:
      prevHostParent = hostParent;
      prevHostParentIsContainer = hostParentIsContainer;
      hostParent = deletedFiber.stateNode.containerInfo;
      hostParentIsContainer = !0;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
      offscreenSubtreeWasHidden ||
        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 1:
      offscreenSubtreeWasHidden ||
        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
        (prevHostParent = deletedFiber.stateNode),
        "function" === typeof prevHostParent.componentWillUnmount &&
          safelyCallComponentWillUnmount(
            deletedFiber,
            nearestMountedAncestor,
            prevHostParent
          ));
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 21:
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 22:
      offscreenSubtreeWasHidden =
        (prevHostParent = offscreenSubtreeWasHidden) ||
        null !== deletedFiber.memoizedState;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      offscreenSubtreeWasHidden = prevHostParent;
      break;
    default:
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
  }
}
function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
  if (
    null === finishedWork.memoizedState &&
    ((finishedRoot = finishedWork.alternate),
    null !== finishedRoot &&
      ((finishedRoot = finishedRoot.memoizedState), null !== finishedRoot))
  ) {
    finishedRoot = finishedRoot.dehydrated;
    try {
      retryIfBlockedOn(finishedRoot);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
  if (
    null === finishedWork.memoizedState &&
    ((finishedRoot = finishedWork.alternate),
    null !== finishedRoot &&
      ((finishedRoot = finishedRoot.memoizedState),
      null !== finishedRoot &&
        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
  )
    try {
      retryIfBlockedOn(finishedRoot);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
}
function getRetryCache(finishedWork) {
  switch (finishedWork.tag) {
    case 31:
    case 13:
    case 19:
      var retryCache = finishedWork.stateNode;
      null === retryCache &&
        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
      return retryCache;
    case 22:
      return (
        (finishedWork = finishedWork.stateNode),
        (retryCache = finishedWork._retryCache),
        null === retryCache &&
          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
        retryCache
      );
    default:
      throw Error(formatProdErrorMessage(435, finishedWork.tag));
  }
}
function attachSuspenseRetryListeners(finishedWork, wakeables) {
  var retryCache = getRetryCache(finishedWork);
  wakeables.forEach(function (wakeable) {
    if (!retryCache.has(wakeable)) {
      retryCache.add(wakeable);
      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
      wakeable.then(retry, retry);
    }
  });
}
function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
  var deletions = parentFiber.deletions;
  if (null !== deletions)
    for (var i = 0; i < deletions.length; i++) {
      var childToDelete = deletions[i],
        root = root$jscomp$0,
        returnFiber = parentFiber,
        parent = returnFiber;
      a: for (; null !== parent; ) {
        switch (parent.tag) {
          case 27:
            if (isSingletonScope(parent.type)) {
              hostParent = parent.stateNode;
              hostParentIsContainer = !1;
              break a;
            }
            break;
          case 5:
            hostParent = parent.stateNode;
            hostParentIsContainer = !1;
            break a;
          case 3:
          case 4:
            hostParent = parent.stateNode.containerInfo;
            hostParentIsContainer = !0;
            break a;
        }
        parent = parent.return;
      }
      if (null === hostParent) throw Error(formatProdErrorMessage(160));
      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
      hostParent = null;
      hostParentIsContainer = !1;
      root = childToDelete.alternate;
      null !== root && (root.return = null);
      childToDelete.return = null;
    }
  if (parentFiber.subtreeFlags & 13886)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
        (parentFiber = parentFiber.sibling);
}
var currentHoistableRoot = null;
function commitMutationEffectsOnFiber(finishedWork, root) {
  var current = finishedWork.alternate,
    flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 &&
        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
        commitHookEffectListMount(3, finishedWork),
        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
      break;
    case 1:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      flags & 64 &&
        offscreenSubtreeIsHidden &&
        ((finishedWork = finishedWork.updateQueue),
        null !== finishedWork &&
          ((flags = finishedWork.callbacks),
          null !== flags &&
            ((current = finishedWork.shared.hiddenCallbacks),
            (finishedWork.shared.hiddenCallbacks =
              null === current ? flags : current.concat(flags)))));
      break;
    case 26:
      var hoistableRoot = currentHoistableRoot;
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      if (flags & 4) {
        var currentResource = null !== current ? current.memoizedState : null;
        flags = finishedWork.memoizedState;
        if (null === current)
          if (null === flags)
            if (null === finishedWork.stateNode) {
              a: {
                flags = finishedWork.type;
                current = finishedWork.memoizedProps;
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                b: switch (flags) {
                  case "title":
                    currentResource =
                      hoistableRoot.getElementsByTagName("title")[0];
                    if (
                      !currentResource ||
                      currentResource[internalHoistableMarker] ||
                      currentResource[internalInstanceKey] ||
                      "http://www.w3.org/2000/svg" ===
                        currentResource.namespaceURI ||
                      currentResource.hasAttribute("itemprop")
                    )
                      (currentResource = hoistableRoot.createElement(flags)),
                        hoistableRoot.head.insertBefore(
                          currentResource,
                          hoistableRoot.querySelector("head > title")
                        );
                    setInitialProperties(currentResource, flags, current);
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                    break a;
                  case "link":
                    var maybeNodes = getHydratableHoistableCache(
                      "link",
                      "href",
                      hoistableRoot
                    ).get(flags + (current.href || ""));
                    if (maybeNodes)
                      for (var i = 0; i < maybeNodes.length; i++)
                        if (
                          ((currentResource = maybeNodes[i]),
                          currentResource.getAttribute("href") ===
                            (null == current.href || "" === current.href
                              ? null
                              : current.href) &&
                            currentResource.getAttribute("rel") ===
                              (null == current.rel ? null : current.rel) &&
                            currentResource.getAttribute("title") ===
                              (null == current.title ? null : current.title) &&
                            currentResource.getAttribute("crossorigin") ===
                              (null == current.crossOrigin
                                ? null
                                : current.crossOrigin))
                        ) {
                          maybeNodes.splice(i, 1);
                          break b;
                        }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  case "meta":
                    if (
                      (maybeNodes = getHydratableHoistableCache(
                        "meta",
                        "content",
                        hoistableRoot
                      ).get(flags + (current.content || "")))
                    )
                      for (i = 0; i < maybeNodes.length; i++)
                        if (
                          ((currentResource = maybeNodes[i]),
                          currentResource.getAttribute("content") ===
                            (null == current.content
                              ? null
                              : "" + current.content) &&
                            currentResource.getAttribute("name") ===
                              (null == current.name ? null : current.name) &&
                            currentResource.getAttribute("property") ===
                              (null == current.property
                                ? null
                                : current.property) &&
                            currentResource.getAttribute("http-equiv") ===
                              (null == current.httpEquiv
                                ? null
                                : current.httpEquiv) &&
                            currentResource.getAttribute("charset") ===
                              (null == current.charSet
                                ? null
                                : current.charSet))
                        ) {
                          maybeNodes.splice(i, 1);
                          break b;
                        }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  default:
                    throw Error(formatProdErrorMessage(468, flags));
                }
                currentResource[internalInstanceKey] = finishedWork;
                markNodeAsHoistable(currentResource);
                flags = currentResource;
              }
              finishedWork.stateNode = flags;
            } else
              mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              );
          else
            finishedWork.stateNode = acquireResource(
              hoistableRoot,
              flags,
              finishedWork.memoizedProps
            );
        else
          currentResource !== flags
            ? (null === currentResource
                ? null !== current.stateNode &&
                  ((current = current.stateNode),
                  current.parentNode.removeChild(current))
                : currentResource.count--,
              null === flags
                ? mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  )
                : acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  ))
            : null === flags &&
              null !== finishedWork.stateNode &&
              commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current.memoizedProps
              );
      }
      break;
    case 27:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      null !== current &&
        flags & 4 &&
        commitHostUpdate(
          finishedWork,
          finishedWork.memoizedProps,
          current.memoizedProps
        );
      break;
    case 5:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      if (finishedWork.flags & 32) {
        hoistableRoot = finishedWork.stateNode;
        try {
          setTextContent(hoistableRoot, "");
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      flags & 4 &&
        null != finishedWork.stateNode &&
        ((hoistableRoot = finishedWork.memoizedProps),
        commitHostUpdate(
          finishedWork,
          hoistableRoot,
          null !== current ? current.memoizedProps : hoistableRoot
        ));
      flags & 1024 && (needsFormReset = !0);
      break;
    case 6:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags & 4) {
        if (null === finishedWork.stateNode)
          throw Error(formatProdErrorMessage(162));
        flags = finishedWork.memoizedProps;
        current = finishedWork.stateNode;
        try {
          current.nodeValue = flags;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 3:
      tagCaches = null;
      hoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(root.containerInfo);
      recursivelyTraverseMutationEffects(root, finishedWork);
      currentHoistableRoot = hoistableRoot;
      commitReconciliationEffects(finishedWork);
      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
        try {
          retryIfBlockedOn(root.containerInfo);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      needsFormReset &&
        ((needsFormReset = !1), recursivelyResetForms(finishedWork));
      break;
    case 4:
      flags = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(
        finishedWork.stateNode.containerInfo
      );
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      currentHoistableRoot = flags;
      break;
    case 12:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    case 31:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((finishedWork.updateQueue = null),
          attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 13:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      finishedWork.child.flags & 8192 &&
        (null !== finishedWork.memoizedState) !==
          (null !== current && null !== current.memoizedState) &&
        (globalMostRecentFallbackTime = now());
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((finishedWork.updateQueue = null),
          attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 22:
      hoistableRoot = null !== finishedWork.memoizedState;
      var wasHidden = null !== current && null !== current.memoizedState,
        prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
        prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
      recursivelyTraverseMutationEffects(root, finishedWork);
      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
      commitReconciliationEffects(finishedWork);
      if (flags & 8192)
        a: for (
          root = finishedWork.stateNode,
            root._visibility = hoistableRoot
              ? root._visibility & -2
              : root._visibility | 1,
            hoistableRoot &&
              (null === current ||
                wasHidden ||
                offscreenSubtreeIsHidden ||
                offscreenSubtreeWasHidden ||
                recursivelyTraverseDisappearLayoutEffects(finishedWork)),
            current = null,
            root = finishedWork;
          ;

        ) {
          if (5 === root.tag || 26 === root.tag) {
            if (null === current) {
              wasHidden = current = root;
              try {
                if (((currentResource = wasHidden.stateNode), hoistableRoot))
                  (maybeNodes = currentResource.style),
                    "function" === typeof maybeNodes.setProperty
                      ? maybeNodes.setProperty("display", "none", "important")
                      : (maybeNodes.display = "none");
                else {
                  i = wasHidden.stateNode;
                  var styleProp = wasHidden.memoizedProps.style,
                    display =
                      void 0 !== styleProp &&
                      null !== styleProp &&
                      styleProp.hasOwnProperty("display")
                        ? styleProp.display
                        : null;
                  i.style.display =
                    null == display || "boolean" === typeof display
                      ? ""
                      : ("" + display).trim();
                }
              } catch (error) {
                captureCommitPhaseError(wasHidden, wasHidden.return, error);
              }
            }
          } else if (6 === root.tag) {
            if (null === current) {
              wasHidden = root;
              try {
                wasHidden.stateNode.nodeValue = hoistableRoot
                  ? ""
                  : wasHidden.memoizedProps;
              } catch (error) {
                captureCommitPhaseError(wasHidden, wasHidden.return, error);
              }
            }
          } else if (18 === root.tag) {
            if (null === current) {
              wasHidden = root;
              try {
                var instance = wasHidden.stateNode;
                hoistableRoot
                  ? hideOrUnhideDehydratedBoundary(instance, !0)
                  : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, !1);
              } catch (error) {
                captureCommitPhaseError(wasHidden, wasHidden.return, error);
              }
            }
          } else if (
            ((22 !== root.tag && 23 !== root.tag) ||
              null === root.memoizedState ||
              root === finishedWork) &&
            null !== root.child
          ) {
            root.child.return = root;
            root = root.child;
            continue;
          }
          if (root === finishedWork) break a;
          for (; null === root.sibling; ) {
            if (null === root.return || root.return === finishedWork) break a;
            current === root && (current = null);
            root = root.return;
          }
          current === root && (current = null);
          root.sibling.return = root.return;
          root = root.sibling;
        }
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((current = flags.retryQueue),
          null !== current &&
            ((flags.retryQueue = null),
            attachSuspenseRetryListeners(finishedWork, current))));
      break;
    case 19:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((finishedWork.updateQueue = null),
          attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 30:
      break;
    case 21:
      break;
    default:
      recursivelyTraverseMutationEffects(root, finishedWork),
        commitReconciliationEffects(finishedWork);
  }
}
function commitReconciliationEffects(finishedWork) {
  var flags = finishedWork.flags;
  if (flags & 2) {
    try {
      for (
        var hostParentFiber, parentFiber = finishedWork.return;
        null !== parentFiber;

      ) {
        if (isHostParent(parentFiber)) {
          hostParentFiber = parentFiber;
          break;
        }
        parentFiber = parentFiber.return;
      }
      if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
      switch (hostParentFiber.tag) {
        case 27:
          var parent = hostParentFiber.stateNode,
            before = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, before, parent);
          break;
        case 5:
          var parent$141 = hostParentFiber.stateNode;
          hostParentFiber.flags & 32 &&
            (setTextContent(parent$141, ""), (hostParentFiber.flags &= -33));
          var before$142 = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
          break;
        case 3:
        case 4:
          var parent$143 = hostParentFiber.stateNode.containerInfo,
            before$144 = getHostSibling(finishedWork);
          insertOrAppendPlacementNodeIntoContainer(
            finishedWork,
            before$144,
            parent$143
          );
          break;
        default:
          throw Error(formatProdErrorMessage(161));
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
    finishedWork.flags &= -3;
  }
  flags & 4096 && (finishedWork.flags &= -4097);
}
function recursivelyResetForms(parentFiber) {
  if (parentFiber.subtreeFlags & 1024)
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var fiber = parentFiber;
      recursivelyResetForms(fiber);
      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
      parentFiber = parentFiber.sibling;
    }
}
function recursivelyTraverseLayoutEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags & 8772)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
        (parentFiber = parentFiber.sibling);
}
function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var finishedWork = parentFiber;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 1:
        safelyDetachRef(finishedWork, finishedWork.return);
        var instance = finishedWork.stateNode;
        "function" === typeof instance.componentWillUnmount &&
          safelyCallComponentWillUnmount(
            finishedWork,
            finishedWork.return,
            instance
          );
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 27:
        releaseSingletonInstance(finishedWork.stateNode);
      case 26:
      case 5:
        safelyDetachRef(finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 22:
        null === finishedWork.memoizedState &&
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 30:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      default:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseReappearLayoutEffects(
  finishedRoot$jscomp$0,
  parentFiber,
  includeWorkInProgressEffects
) {
  includeWorkInProgressEffects =
    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var current = parentFiber.alternate,
      finishedRoot = finishedRoot$jscomp$0,
      finishedWork = parentFiber,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        commitHookEffectListMount(4, finishedWork);
        break;
      case 1:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        current = finishedWork;
        finishedRoot = current.stateNode;
        if ("function" === typeof finishedRoot.componentDidMount)
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        current = finishedWork;
        finishedRoot = current.updateQueue;
        if (null !== finishedRoot) {
          var instance = current.stateNode;
          try {
            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
            if (null !== hiddenCallbacks)
              for (
                finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
                finishedRoot < hiddenCallbacks.length;
                finishedRoot++
              )
                callCallback(hiddenCallbacks[finishedRoot], instance);
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        }
        includeWorkInProgressEffects &&
          flags & 64 &&
          commitClassCallbacks(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 27:
        commitHostSingletonAcquisition(finishedWork);
      case 26:
      case 5:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          null === current &&
          flags & 4 &&
          commitHostMount(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        break;
      case 31:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          flags & 4 &&
          commitActivityHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 13:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          flags & 4 &&
          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 22:
        null === finishedWork.memoizedState &&
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 30:
        break;
      default:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitOffscreenPassiveMountEffects(current, finishedWork) {
  var previousCache = null;
  null !== current &&
    null !== current.memoizedState &&
    null !== current.memoizedState.cachePool &&
    (previousCache = current.memoizedState.cachePool.pool);
  current = null;
  null !== finishedWork.memoizedState &&
    null !== finishedWork.memoizedState.cachePool &&
    (current = finishedWork.memoizedState.cachePool.pool);
  current !== previousCache &&
    (null != current && current.refCount++,
    null != previousCache && releaseCache(previousCache));
}
function commitCachePassiveMountEffect(current, finishedWork) {
  current = null;
  null !== finishedWork.alternate &&
    (current = finishedWork.alternate.memoizedState.cache);
  finishedWork = finishedWork.memoizedState.cache;
  finishedWork !== current &&
    (finishedWork.refCount++, null != current && releaseCache(current));
}
function recursivelyTraversePassiveMountEffects(
  root,
  parentFiber,
  committedLanes,
  committedTransitions
) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitPassiveMountOnFiber(
        root,
        parentFiber,
        committedLanes,
        committedTransitions
      ),
        (parentFiber = parentFiber.sibling);
}
function commitPassiveMountOnFiber(
  finishedRoot,
  finishedWork,
  committedLanes,
  committedTransitions
) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 && commitHookEffectListMount(9, finishedWork);
      break;
    case 1:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      break;
    case 3:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 &&
        ((finishedRoot = null),
        null !== finishedWork.alternate &&
          (finishedRoot = finishedWork.alternate.memoizedState.cache),
        (finishedWork = finishedWork.memoizedState.cache),
        finishedWork !== finishedRoot &&
          (finishedWork.refCount++,
          null != finishedRoot && releaseCache(finishedRoot)));
      break;
    case 12:
      if (flags & 2048) {
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        finishedRoot = finishedWork.stateNode;
        try {
          var _finishedWork$memoize2 = finishedWork.memoizedProps,
            id = _finishedWork$memoize2.id,
            onPostCommit = _finishedWork$memoize2.onPostCommit;
          "function" === typeof onPostCommit &&
            onPostCommit(
              id,
              null === finishedWork.alternate ? "mount" : "update",
              finishedRoot.passiveEffectDuration,
              -0
            );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      } else
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
      break;
    case 31:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      break;
    case 13:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      break;
    case 23:
      break;
    case 22:
      _finishedWork$memoize2 = finishedWork.stateNode;
      id = finishedWork.alternate;
      null !== finishedWork.memoizedState
        ? _finishedWork$memoize2._visibility & 2
          ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            )
          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)
        : _finishedWork$memoize2._visibility & 2
          ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            )
          : ((_finishedWork$memoize2._visibility |= 2),
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256) || !1
            ));
      flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
      break;
    case 24:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 &&
        commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
      break;
    default:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
  }
}
function recursivelyTraverseReconnectPassiveEffects(
  finishedRoot$jscomp$0,
  parentFiber,
  committedLanes$jscomp$0,
  committedTransitions$jscomp$0,
  includeWorkInProgressEffects
) {
  includeWorkInProgressEffects =
    includeWorkInProgressEffects &&
    (0 !== (parentFiber.subtreeFlags & 10256) || !1);
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var finishedRoot = finishedRoot$jscomp$0,
      finishedWork = parentFiber,
      committedLanes = committedLanes$jscomp$0,
      committedTransitions = committedTransitions$jscomp$0,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
        commitHookEffectListMount(8, finishedWork);
        break;
      case 23:
        break;
      case 22:
        var instance = finishedWork.stateNode;
        null !== finishedWork.memoizedState
          ? instance._visibility & 2
            ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              )
            : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              )
          : ((instance._visibility |= 2),
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ));
        includeWorkInProgressEffects &&
          flags & 2048 &&
          commitOffscreenPassiveMountEffects(
            finishedWork.alternate,
            finishedWork
          );
        break;
      case 24:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          flags & 2048 &&
          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseAtomicPassiveEffects(
  finishedRoot$jscomp$0,
  parentFiber
) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var finishedRoot = finishedRoot$jscomp$0,
        finishedWork = parentFiber,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 22:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 &&
            commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
          break;
        case 24:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 &&
            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
      }
      parentFiber = parentFiber.sibling;
    }
}
var suspenseyCommitFlag = 8192;
function recursivelyAccumulateSuspenseyCommit(
  parentFiber,
  committedLanes,
  suspendedState
) {
  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      accumulateSuspenseyCommitOnFiber(
        parentFiber,
        committedLanes,
        suspendedState
      ),
        (parentFiber = parentFiber.sibling);
}
function accumulateSuspenseyCommitOnFiber(
  fiber,
  committedLanes,
  suspendedState
) {
  switch (fiber.tag) {
    case 26:
      recursivelyAccumulateSuspenseyCommit(
        fiber,
        committedLanes,
        suspendedState
      );
      fiber.flags & suspenseyCommitFlag &&
        null !== fiber.memoizedState &&
        suspendResource(
          suspendedState,
          currentHoistableRoot,
          fiber.memoizedState,
          fiber.memoizedProps
        );
      break;
    case 5:
      recursivelyAccumulateSuspenseyCommit(
        fiber,
        committedLanes,
        suspendedState
      );
      break;
    case 3:
    case 4:
      var previousHoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
      recursivelyAccumulateSuspenseyCommit(
        fiber,
        committedLanes,
        suspendedState
      );
      currentHoistableRoot = previousHoistableRoot;
      break;
    case 22:
      null === fiber.memoizedState &&
        ((previousHoistableRoot = fiber.alternate),
        null !== previousHoistableRoot &&
        null !== previousHoistableRoot.memoizedState
          ? ((previousHoistableRoot = suspenseyCommitFlag),
            (suspenseyCommitFlag = 16777216),
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ),
            (suspenseyCommitFlag = previousHoistableRoot))
          : recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ));
      break;
    default:
      recursivelyAccumulateSuspenseyCommit(
        fiber,
        committedLanes,
        suspendedState
      );
  }
}
function detachAlternateSiblings(parentFiber) {
  var previousFiber = parentFiber.alternate;
  if (
    null !== previousFiber &&
    ((parentFiber = previousFiber.child), null !== parentFiber)
  ) {
    previousFiber.child = null;
    do
      (previousFiber = parentFiber.sibling),
        (parentFiber.sibling = null),
        (parentFiber = previousFiber);
    while (null !== parentFiber);
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions)
      for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
      }
    detachAlternateSiblings(parentFiber);
  }
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitPassiveUnmountOnFiber(parentFiber),
        (parentFiber = parentFiber.sibling);
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      finishedWork.flags & 2048 &&
        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 12:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 22:
      var instance = finishedWork.stateNode;
      null !== finishedWork.memoizedState &&
      instance._visibility & 2 &&
      (null === finishedWork.return || 13 !== finishedWork.return.tag)
        ? ((instance._visibility &= -3),
          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
        : recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    default:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
  }
}
function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions)
      for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
      }
    detachAlternateSiblings(parentFiber);
  }
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    deletions = parentFiber;
    switch (deletions.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, deletions, deletions.return);
        recursivelyTraverseDisconnectPassiveEffects(deletions);
        break;
      case 22:
        i = deletions.stateNode;
        i._visibility & 2 &&
          ((i._visibility &= -3),
          recursivelyTraverseDisconnectPassiveEffects(deletions));
        break;
      default:
        recursivelyTraverseDisconnectPassiveEffects(deletions);
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
  deletedSubtreeRoot,
  nearestMountedAncestor
) {
  for (; null !== nextEffect; ) {
    var fiber = nextEffect;
    switch (fiber.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
        break;
      case 23:
      case 22:
        if (
          null !== fiber.memoizedState &&
          null !== fiber.memoizedState.cachePool
        ) {
          var cache = fiber.memoizedState.cachePool.pool;
          null != cache && cache.refCount++;
        }
        break;
      case 24:
        releaseCache(fiber.memoizedState.cache);
    }
    cache = fiber.child;
    if (null !== cache) (cache.return = fiber), (nextEffect = cache);
    else
      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
        cache = nextEffect;
        var sibling = cache.sibling,
          returnFiber = cache.return;
        detachFiberAfterEffects(cache);
        if (cache === fiber) {
          nextEffect = null;
          break a;
        }
        if (null !== sibling) {
          sibling.return = returnFiber;
          nextEffect = sibling;
          break a;
        }
        nextEffect = returnFiber;
      }
  }
}
var DefaultAsyncDispatcher = {
    getCacheForType: function (resourceType) {
      var cache = readContext(CacheContext),
        cacheForType = cache.data.get(resourceType);
      void 0 === cacheForType &&
        ((cacheForType = resourceType()),
        cache.data.set(resourceType, cacheForType));
      return cacheForType;
    },
    cacheSignal: function () {
      return readContext(CacheContext).controller.signal;
    }
  },
  PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
  executionContext = 0,
  workInProgressRoot = null,
  workInProgress = null,
  workInProgressRootRenderLanes = 0,
  workInProgressSuspendedReason = 0,
  workInProgressThrownValue = null,
  workInProgressRootDidSkipSuspendedSiblings = !1,
  workInProgressRootIsPrerendering = !1,
  workInProgressRootDidAttachPingListener = !1,
  entangledRenderLanes = 0,
  workInProgressRootExitStatus = 0,
  workInProgressRootSkippedLanes = 0,
  workInProgressRootInterleavedUpdatedLanes = 0,
  workInProgressRootPingedLanes = 0,
  workInProgressDeferredLane = 0,
  workInProgressSuspendedRetryLanes = 0,
  workInProgressRootConcurrentErrors = null,
  workInProgressRootRecoverableErrors = null,
  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
  globalMostRecentFallbackTime = 0,
  globalMostRecentTransitionTime = 0,
  workInProgressRootRenderTargetTime = Infinity,
  workInProgressTransitions = null,
  legacyErrorBoundariesThatAlreadyFailed = null,
  pendingEffectsStatus = 0,
  pendingEffectsRoot = null,
  pendingFinishedWork = null,
  pendingEffectsLanes = 0,
  pendingEffectsRemainingLanes = 0,
  pendingPassiveTransitions = null,
  pendingRecoverableErrors = null,
  nestedUpdateCount = 0,
  rootWithNestedUpdates = null;
function requestUpdateLane() {
  return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes
    ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes
    : null !== ReactSharedInternals.T
      ? requestTransitionLane()
      : resolveUpdatePriority();
}
function requestDeferredLane() {
  if (0 === workInProgressDeferredLane)
    if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
      var lane = nextTransitionDeferredLane;
      nextTransitionDeferredLane <<= 1;
      0 === (nextTransitionDeferredLane & 3932160) &&
        (nextTransitionDeferredLane = 262144);
      workInProgressDeferredLane = lane;
    } else workInProgressDeferredLane = 536870912;
  lane = suspenseHandlerStackCursor.current;
  null !== lane && (lane.flags |= 32);
  return workInProgressDeferredLane;
}
function scheduleUpdateOnFiber(root, fiber, lane) {
  if (
    (root === workInProgressRoot &&
      (2 === workInProgressSuspendedReason ||
        9 === workInProgressSuspendedReason)) ||
    null !== root.cancelPendingCommit
  )
    prepareFreshStack(root, 0),
      markRootSuspended(
        root,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        !1
      );
  markRootUpdated$1(root, lane);
  if (0 === (executionContext & 2) || root !== workInProgressRoot)
    root === workInProgressRoot &&
      (0 === (executionContext & 2) &&
        (workInProgressRootInterleavedUpdatedLanes |= lane),
      4 === workInProgressRootExitStatus &&
        markRootSuspended(
          root,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          !1
        )),
      ensureRootIsScheduled(root);
}
function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  var shouldTimeSlice =
      (!forceSync &&
        0 === (lanes & 127) &&
        0 === (lanes & root$jscomp$0.expiredLanes)) ||
      checkIfRootIsPrerendering(root$jscomp$0, lanes),
    exitStatus = shouldTimeSlice
      ? renderRootConcurrent(root$jscomp$0, lanes)
      : renderRootSync(root$jscomp$0, lanes, !0),
    renderWasConcurrent = shouldTimeSlice;
  do {
    if (0 === exitStatus) {
      workInProgressRootIsPrerendering &&
        !shouldTimeSlice &&
        markRootSuspended(root$jscomp$0, lanes, 0, !1);
      break;
    } else {
      forceSync = root$jscomp$0.current.alternate;
      if (
        renderWasConcurrent &&
        !isRenderConsistentWithExternalStores(forceSync)
      ) {
        exitStatus = renderRootSync(root$jscomp$0, lanes, !1);
        renderWasConcurrent = !1;
        continue;
      }
      if (2 === exitStatus) {
        renderWasConcurrent = lanes;
        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
          var JSCompiler_inline_result = 0;
        else
          (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),
            (JSCompiler_inline_result =
              0 !== JSCompiler_inline_result
                ? JSCompiler_inline_result
                : JSCompiler_inline_result & 536870912
                  ? 536870912
                  : 0);
        if (0 !== JSCompiler_inline_result) {
          lanes = JSCompiler_inline_result;
          a: {
            var root = root$jscomp$0;
            exitStatus = workInProgressRootConcurrentErrors;
            var wasRootDehydrated = root.current.memoizedState.isDehydrated;
            wasRootDehydrated &&
              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
            JSCompiler_inline_result = renderRootSync(
              root,
              JSCompiler_inline_result,
              !1
            );
            if (2 !== JSCompiler_inline_result) {
              if (
                workInProgressRootDidAttachPingListener &&
                !wasRootDehydrated
              ) {
                root.errorRecoveryDisabledLanes |= renderWasConcurrent;
                workInProgressRootInterleavedUpdatedLanes |=
                  renderWasConcurrent;
                exitStatus = 4;
                break a;
              }
              renderWasConcurrent = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = exitStatus;
              null !== renderWasConcurrent &&
                (null === workInProgressRootRecoverableErrors
                  ? (workInProgressRootRecoverableErrors = renderWasConcurrent)
                  : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
            }
            exitStatus = JSCompiler_inline_result;
          }
          renderWasConcurrent = !1;
          if (2 !== exitStatus) continue;
        }
      }
      if (1 === exitStatus) {
        prepareFreshStack(root$jscomp$0, 0);
        markRootSuspended(root$jscomp$0, lanes, 0, !0);
        break;
      }
      a: {
        shouldTimeSlice = root$jscomp$0;
        renderWasConcurrent = exitStatus;
        switch (renderWasConcurrent) {
          case 0:
          case 1:
            throw Error(formatProdErrorMessage(345));
          case 4:
            if ((lanes & 4194048) !== lanes) break;
          case 6:
            markRootSuspended(
              shouldTimeSlice,
              lanes,
              workInProgressDeferredLane,
              !workInProgressRootDidSkipSuspendedSiblings
            );
            break a;
          case 2:
            workInProgressRootRecoverableErrors = null;
            break;
          case 3:
          case 5:
            break;
          default:
            throw Error(formatProdErrorMessage(329));
        }
        if (
          (lanes & 62914560) === lanes &&
          ((exitStatus = globalMostRecentFallbackTime + 300 - now()),
          10 < exitStatus)
        ) {
          markRootSuspended(
            shouldTimeSlice,
            lanes,
            workInProgressDeferredLane,
            !workInProgressRootDidSkipSuspendedSiblings
          );
          if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
          pendingEffectsLanes = lanes;
          shouldTimeSlice.timeoutHandle = scheduleTimeout(
            commitRootWhenReady.bind(
              null,
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              renderWasConcurrent,
              "Throttled",
              -0,
              0
            ),
            exitStatus
          );
          break a;
        }
        commitRootWhenReady(
          shouldTimeSlice,
          forceSync,
          workInProgressRootRecoverableErrors,
          workInProgressTransitions,
          workInProgressRootDidIncludeRecursiveRenderUpdate,
          lanes,
          workInProgressDeferredLane,
          workInProgressRootInterleavedUpdatedLanes,
          workInProgressSuspendedRetryLanes,
          workInProgressRootDidSkipSuspendedSiblings,
          renderWasConcurrent,
          null,
          -0,
          0
        );
      }
    }
    break;
  } while (1);
  ensureRootIsScheduled(root$jscomp$0);
}
function commitRootWhenReady(
  root,
  finishedWork,
  recoverableErrors,
  transitions,
  didIncludeRenderPhaseUpdate,
  lanes,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes,
  didSkipSuspendedSiblings,
  exitStatus,
  suspendedCommitReason,
  completedRenderStartTime,
  completedRenderEndTime
) {
  root.timeoutHandle = -1;
  suspendedCommitReason = finishedWork.subtreeFlags;
  if (
    suspendedCommitReason & 8192 ||
    16785408 === (suspendedCommitReason & 16785408)
  ) {
    suspendedCommitReason = {
      stylesheets: null,
      count: 0,
      imgCount: 0,
      imgBytes: 0,
      suspenseyImages: [],
      waitingForImages: !0,
      waitingForViewTransition: !1,
      unsuspend: noop$1
    };
    accumulateSuspenseyCommitOnFiber(
      finishedWork,
      lanes,
      suspendedCommitReason
    );
    var timeoutOffset =
      (lanes & 62914560) === lanes
        ? globalMostRecentFallbackTime - now()
        : (lanes & 4194048) === lanes
          ? globalMostRecentTransitionTime - now()
          : 0;
    timeoutOffset = waitForCommitToBeReady(
      suspendedCommitReason,
      timeoutOffset
    );
    if (null !== timeoutOffset) {
      pendingEffectsLanes = lanes;
      root.cancelPendingCommit = timeoutOffset(
        commitRoot.bind(
          null,
          root,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes,
          exitStatus,
          suspendedCommitReason,
          null,
          completedRenderStartTime,
          completedRenderEndTime
        )
      );
      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
      return;
    }
  }
  commitRoot(
    root,
    finishedWork,
    lanes,
    recoverableErrors,
    transitions,
    didIncludeRenderPhaseUpdate,
    spawnedLane,
    updatedLanes,
    suspendedRetryLanes
  );
}
function isRenderConsistentWithExternalStores(finishedWork) {
  for (var node = finishedWork; ; ) {
    var tag = node.tag;
    if (
      (0 === tag || 11 === tag || 15 === tag) &&
      node.flags & 16384 &&
      ((tag = node.updateQueue),
      null !== tag && ((tag = tag.stores), null !== tag))
    )
      for (var i = 0; i < tag.length; i++) {
        var check = tag[i],
          getSnapshot = check.getSnapshot;
        check = check.value;
        try {
          if (!objectIs(getSnapshot(), check)) return !1;
        } catch (error) {
          return !1;
        }
      }
    tag = node.child;
    if (node.subtreeFlags & 16384 && null !== tag)
      (tag.return = node), (node = tag);
    else {
      if (node === finishedWork) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === finishedWork) return !0;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  return !0;
}
function markRootSuspended(
  root,
  suspendedLanes,
  spawnedLane,
  didAttemptEntireTree
) {
  suspendedLanes &= ~workInProgressRootPingedLanes;
  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
  root.suspendedLanes |= suspendedLanes;
  root.pingedLanes &= ~suspendedLanes;
  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
  didAttemptEntireTree = root.expirationTimes;
  for (var lanes = suspendedLanes; 0 < lanes; ) {
    var index$6 = 31 - clz32(lanes),
      lane = 1 << index$6;
    didAttemptEntireTree[index$6] = -1;
    lanes &= ~lane;
  }
  0 !== spawnedLane &&
    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
}
function flushSyncWork$1() {
  return 0 === (executionContext & 6)
    ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)
    : !0;
}
function resetWorkInProgressStack() {
  if (null !== workInProgress) {
    if (0 === workInProgressSuspendedReason)
      var interruptedWork = workInProgress.return;
    else
      (interruptedWork = workInProgress),
        (lastContextDependency = currentlyRenderingFiber$1 = null),
        resetHooksOnUnwind(interruptedWork),
        (thenableState$1 = null),
        (thenableIndexCounter$1 = 0),
        (interruptedWork = workInProgress);
    for (; null !== interruptedWork; )
      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
        (interruptedWork = interruptedWork.return);
    workInProgress = null;
  }
}
function prepareFreshStack(root, lanes) {
  var timeoutHandle = root.timeoutHandle;
  -1 !== timeoutHandle &&
    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
  timeoutHandle = root.cancelPendingCommit;
  null !== timeoutHandle &&
    ((root.cancelPendingCommit = null), timeoutHandle());
  pendingEffectsLanes = 0;
  resetWorkInProgressStack();
  workInProgressRoot = root;
  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  workInProgressSuspendedReason = 0;
  workInProgressThrownValue = null;
  workInProgressRootDidSkipSuspendedSiblings = !1;
  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
  workInProgressRootDidAttachPingListener = !1;
  workInProgressSuspendedRetryLanes =
    workInProgressDeferredLane =
    workInProgressRootPingedLanes =
    workInProgressRootInterleavedUpdatedLanes =
    workInProgressRootSkippedLanes =
    workInProgressRootExitStatus =
      0;
  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
    null;
  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
  0 !== (lanes & 8) && (lanes |= lanes & 32);
  var allEntangledLanes = root.entangledLanes;
  if (0 !== allEntangledLanes)
    for (
      root = root.entanglements, allEntangledLanes &= lanes;
      0 < allEntangledLanes;

    ) {
      var index$4 = 31 - clz32(allEntangledLanes),
        lane = 1 << index$4;
      lanes |= root[index$4];
      allEntangledLanes &= ~lane;
    }
  entangledRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
  return timeoutHandle;
}
function handleThrow(root, thrownValue) {
  currentlyRenderingFiber = null;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  thrownValue === SuspenseException || thrownValue === SuspenseActionException
    ? ((thrownValue = getSuspendedThenable()),
      (workInProgressSuspendedReason = 3))
    : thrownValue === SuspenseyCommitException
      ? ((thrownValue = getSuspendedThenable()),
        (workInProgressSuspendedReason = 4))
      : (workInProgressSuspendedReason =
          thrownValue === SelectiveHydrationException
            ? 8
            : null !== thrownValue &&
                "object" === typeof thrownValue &&
                "function" === typeof thrownValue.then
              ? 6
              : 1);
  workInProgressThrownValue = thrownValue;
  null === workInProgress &&
    ((workInProgressRootExitStatus = 1),
    logUncaughtError(
      root,
      createCapturedValueAtFiber(thrownValue, root.current)
    ));
}
function shouldRemainOnPreviousScreen() {
  var handler = suspenseHandlerStackCursor.current;
  return null === handler
    ? !0
    : (workInProgressRootRenderLanes & 4194048) ===
        workInProgressRootRenderLanes
      ? null === shellBoundary
        ? !0
        : !1
      : (workInProgressRootRenderLanes & 62914560) ===
            workInProgressRootRenderLanes ||
          0 !== (workInProgressRootRenderLanes & 536870912)
        ? handler === shellBoundary
        : !1;
}
function pushDispatcher() {
  var prevDispatcher = ReactSharedInternals.H;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
}
function pushAsyncDispatcher() {
  var prevAsyncDispatcher = ReactSharedInternals.A;
  ReactSharedInternals.A = DefaultAsyncDispatcher;
  return prevAsyncDispatcher;
}
function renderDidSuspendDelayIfPossible() {
  workInProgressRootExitStatus = 4;
  workInProgressRootDidSkipSuspendedSiblings ||
    ((workInProgressRootRenderLanes & 4194048) !==
      workInProgressRootRenderLanes &&
      null !== suspenseHandlerStackCursor.current) ||
    (workInProgressRootIsPrerendering = !0);
  (0 === (workInProgressRootSkippedLanes & 134217727) &&
    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
    null === workInProgressRoot ||
    markRootSuspended(
      workInProgressRoot,
      workInProgressRootRenderLanes,
      workInProgressDeferredLane,
      !1
    );
}
function renderRootSync(root, lanes, shouldYieldForPrerendering) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(),
    prevAsyncDispatcher = pushAsyncDispatcher();
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
    (workInProgressTransitions = null), prepareFreshStack(root, lanes);
  lanes = !1;
  var exitStatus = workInProgressRootExitStatus;
  a: do
    try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        var unitOfWork = workInProgress,
          thrownValue = workInProgressThrownValue;
        switch (workInProgressSuspendedReason) {
          case 8:
            resetWorkInProgressStack();
            exitStatus = 6;
            break a;
          case 3:
          case 2:
          case 9:
          case 6:
            null === suspenseHandlerStackCursor.current && (lanes = !0);
            var reason = workInProgressSuspendedReason;
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
            if (
              shouldYieldForPrerendering &&
              workInProgressRootIsPrerendering
            ) {
              exitStatus = 0;
              break a;
            }
            break;
          default:
            (reason = workInProgressSuspendedReason),
              (workInProgressSuspendedReason = 0),
              (workInProgressThrownValue = null),
              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
        }
      }
      workLoopSync();
      exitStatus = workInProgressRootExitStatus;
      break;
    } catch (thrownValue$165) {
      handleThrow(root, thrownValue$165);
    }
  while (1);
  lanes && root.shellSuspendCounter++;
  lastContextDependency = currentlyRenderingFiber$1 = null;
  executionContext = prevExecutionContext;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  null === workInProgress &&
    ((workInProgressRoot = null),
    (workInProgressRootRenderLanes = 0),
    finishQueueingConcurrentUpdates());
  return exitStatus;
}
function workLoopSync() {
  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
}
function renderRootConcurrent(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(),
    prevAsyncDispatcher = pushAsyncDispatcher();
  workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes
    ? ((workInProgressTransitions = null),
      (workInProgressRootRenderTargetTime = now() + 500),
      prepareFreshStack(root, lanes))
    : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
        root,
        lanes
      ));
  a: do
    try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        lanes = workInProgress;
        var thrownValue = workInProgressThrownValue;
        b: switch (workInProgressSuspendedReason) {
          case 1:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
            break;
          case 2:
          case 9:
            if (isThenableResolved(thrownValue)) {
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              replaySuspendedUnitOfWork(lanes);
              break;
            }
            lanes = function () {
              (2 !== workInProgressSuspendedReason &&
                9 !== workInProgressSuspendedReason) ||
                workInProgressRoot !== root ||
                (workInProgressSuspendedReason = 7);
              ensureRootIsScheduled(root);
            };
            thrownValue.then(lanes, lanes);
            break a;
          case 3:
            workInProgressSuspendedReason = 7;
            break a;
          case 4:
            workInProgressSuspendedReason = 5;
            break a;
          case 7:
            isThenableResolved(thrownValue)
              ? ((workInProgressSuspendedReason = 0),
                (workInProgressThrownValue = null),
                replaySuspendedUnitOfWork(lanes))
              : ((workInProgressSuspendedReason = 0),
                (workInProgressThrownValue = null),
                throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
            break;
          case 5:
            var resource = null;
            switch (workInProgress.tag) {
              case 26:
                resource = workInProgress.memoizedState;
              case 5:
              case 27:
                var hostFiber = workInProgress;
                if (
                  resource
                    ? preloadResource(resource)
                    : hostFiber.stateNode.complete
                ) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  var sibling = hostFiber.sibling;
                  if (null !== sibling) workInProgress = sibling;
                  else {
                    var returnFiber = hostFiber.return;
                    null !== returnFiber
                      ? ((workInProgress = returnFiber),
                        completeUnitOfWork(returnFiber))
                      : (workInProgress = null);
                  }
                  break b;
                }
            }
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
            break;
          case 6:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
            break;
          case 8:
            resetWorkInProgressStack();
            workInProgressRootExitStatus = 6;
            break a;
          default:
            throw Error(formatProdErrorMessage(462));
        }
      }
      workLoopConcurrentByScheduler();
      break;
    } catch (thrownValue$167) {
      handleThrow(root, thrownValue$167);
    }
  while (1);
  lastContextDependency = currentlyRenderingFiber$1 = null;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  executionContext = prevExecutionContext;
  if (null !== workInProgress) return 0;
  workInProgressRoot = null;
  workInProgressRootRenderLanes = 0;
  finishQueueingConcurrentUpdates();
  return workInProgressRootExitStatus;
}
function workLoopConcurrentByScheduler() {
  for (; null !== workInProgress && !shouldYield(); )
    performUnitOfWork(workInProgress);
}
function performUnitOfWork(unitOfWork) {
  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
}
function replaySuspendedUnitOfWork(unitOfWork) {
  var next = unitOfWork;
  var current = next.alternate;
  switch (next.tag) {
    case 15:
    case 0:
      next = replayFunctionComponent(
        current,
        next,
        next.pendingProps,
        next.type,
        void 0,
        workInProgressRootRenderLanes
      );
      break;
    case 11:
      next = replayFunctionComponent(
        current,
        next,
        next.pendingProps,
        next.type.render,
        next.ref,
        workInProgressRootRenderLanes
      );
      break;
    case 5:
      resetHooksOnUnwind(next);
    default:
      unwindInterruptedWork(current, next),
        (next = workInProgress =
          resetWorkInProgress(next, entangledRenderLanes)),
        (next = beginWork(current, next, entangledRenderLanes));
  }
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
}
function throwAndUnwindWorkLoop(
  root,
  unitOfWork,
  thrownValue,
  suspendedReason
) {
  lastContextDependency = currentlyRenderingFiber$1 = null;
  resetHooksOnUnwind(unitOfWork);
  thenableState$1 = null;
  thenableIndexCounter$1 = 0;
  var returnFiber = unitOfWork.return;
  try {
    if (
      throwException(
        root,
        returnFiber,
        unitOfWork,
        thrownValue,
        workInProgressRootRenderLanes
      )
    ) {
      workInProgressRootExitStatus = 1;
      logUncaughtError(
        root,
        createCapturedValueAtFiber(thrownValue, root.current)
      );
      workInProgress = null;
      return;
    }
  } catch (error) {
    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
    workInProgressRootExitStatus = 1;
    logUncaughtError(
      root,
      createCapturedValueAtFiber(thrownValue, root.current)
    );
    workInProgress = null;
    return;
  }
  if (unitOfWork.flags & 32768) {
    if (isHydrating || 1 === suspendedReason) root = !0;
    else if (
      workInProgressRootIsPrerendering ||
      0 !== (workInProgressRootRenderLanes & 536870912)
    )
      root = !1;
    else if (
      ((workInProgressRootDidSkipSuspendedSiblings = root = !0),
      2 === suspendedReason ||
        9 === suspendedReason ||
        3 === suspendedReason ||
        6 === suspendedReason)
    )
      (suspendedReason = suspenseHandlerStackCursor.current),
        null !== suspendedReason &&
          13 === suspendedReason.tag &&
          (suspendedReason.flags |= 16384);
    unwindUnitOfWork(unitOfWork, root);
  } else completeUnitOfWork(unitOfWork);
}
function completeUnitOfWork(unitOfWork) {
  var completedWork = unitOfWork;
  do {
    if (0 !== (completedWork.flags & 32768)) {
      unwindUnitOfWork(
        completedWork,
        workInProgressRootDidSkipSuspendedSiblings
      );
      return;
    }
    unitOfWork = completedWork.return;
    var next = completeWork(
      completedWork.alternate,
      completedWork,
      entangledRenderLanes
    );
    if (null !== next) {
      workInProgress = next;
      return;
    }
    completedWork = completedWork.sibling;
    if (null !== completedWork) {
      workInProgress = completedWork;
      return;
    }
    workInProgress = completedWork = unitOfWork;
  } while (null !== completedWork);
  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
}
function unwindUnitOfWork(unitOfWork, skipSiblings) {
  do {
    var next = unwindWork(unitOfWork.alternate, unitOfWork);
    if (null !== next) {
      next.flags &= 32767;
      workInProgress = next;
      return;
    }
    next = unitOfWork.return;
    null !== next &&
      ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));
    if (
      !skipSiblings &&
      ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
    ) {
      workInProgress = unitOfWork;
      return;
    }
    workInProgress = unitOfWork = next;
  } while (null !== unitOfWork);
  workInProgressRootExitStatus = 6;
  workInProgress = null;
}
function commitRoot(
  root,
  finishedWork,
  lanes,
  recoverableErrors,
  transitions,
  didIncludeRenderPhaseUpdate,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes
) {
  root.cancelPendingCommit = null;
  do flushPendingEffects();
  while (0 !== pendingEffectsStatus);
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  if (null !== finishedWork) {
    if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
    didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
    didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
    markRootFinished(
      root,
      lanes,
      didIncludeRenderPhaseUpdate,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes
    );
    root === workInProgressRoot &&
      ((workInProgress = workInProgressRoot = null),
      (workInProgressRootRenderLanes = 0));
    pendingFinishedWork = finishedWork;
    pendingEffectsRoot = root;
    pendingEffectsLanes = lanes;
    pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
    pendingPassiveTransitions = transitions;
    pendingRecoverableErrors = recoverableErrors;
    0 !== (finishedWork.subtreeFlags & 10256) ||
    0 !== (finishedWork.flags & 10256)
      ? ((root.callbackNode = null),
        (root.callbackPriority = 0),
        scheduleCallback$1(NormalPriority$1, function () {
          flushPassiveEffects();
          return null;
        }))
      : ((root.callbackNode = null), (root.callbackPriority = 0));
    recoverableErrors = 0 !== (finishedWork.flags & 13878);
    if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
      recoverableErrors = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      transitions = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      spawnedLane = executionContext;
      executionContext |= 4;
      try {
        commitBeforeMutationEffects(root, finishedWork, lanes);
      } finally {
        (executionContext = spawnedLane),
          (ReactDOMSharedInternals.p = transitions),
          (ReactSharedInternals.T = recoverableErrors);
      }
    }
    pendingEffectsStatus = 1;
    flushMutationEffects();
    flushLayoutEffects();
    flushSpawnedWork();
  }
}
function flushMutationEffects() {
  if (1 === pendingEffectsStatus) {
    pendingEffectsStatus = 0;
    var root = pendingEffectsRoot,
      finishedWork = pendingFinishedWork,
      rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
    if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
      rootMutationHasEffect = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      try {
        commitMutationEffectsOnFiber(finishedWork, root);
        var priorSelectionInformation = selectionInformation,
          curFocusedElem = getActiveElementDeep(root.containerInfo),
          priorFocusedElem = priorSelectionInformation.focusedElem,
          priorSelectionRange = priorSelectionInformation.selectionRange;
        if (
          curFocusedElem !== priorFocusedElem &&
          priorFocusedElem &&
          priorFocusedElem.ownerDocument &&
          containsNode(
            priorFocusedElem.ownerDocument.documentElement,
            priorFocusedElem
          )
        ) {
          if (
            null !== priorSelectionRange &&
            hasSelectionCapabilities(priorFocusedElem)
          ) {
            var start = priorSelectionRange.start,
              end = priorSelectionRange.end;
            void 0 === end && (end = start);
            if ("selectionStart" in priorFocusedElem)
              (priorFocusedElem.selectionStart = start),
                (priorFocusedElem.selectionEnd = Math.min(
                  end,
                  priorFocusedElem.value.length
                ));
            else {
              var doc = priorFocusedElem.ownerDocument || document,
                win = (doc && doc.defaultView) || window;
              if (win.getSelection) {
                var selection = win.getSelection(),
                  length = priorFocusedElem.textContent.length,
                  start$jscomp$0 = Math.min(priorSelectionRange.start, length),
                  end$jscomp$0 =
                    void 0 === priorSelectionRange.end
                      ? start$jscomp$0
                      : Math.min(priorSelectionRange.end, length);
                !selection.extend &&
                  start$jscomp$0 > end$jscomp$0 &&
                  ((curFocusedElem = end$jscomp$0),
                  (end$jscomp$0 = start$jscomp$0),
                  (start$jscomp$0 = curFocusedElem));
                var startMarker = getNodeForCharacterOffset(
                    priorFocusedElem,
                    start$jscomp$0
                  ),
                  endMarker = getNodeForCharacterOffset(
                    priorFocusedElem,
                    end$jscomp$0
                  );
                if (
                  startMarker &&
                  endMarker &&
                  (1 !== selection.rangeCount ||
                    selection.anchorNode !== startMarker.node ||
                    selection.anchorOffset !== startMarker.offset ||
                    selection.focusNode !== endMarker.node ||
                    selection.focusOffset !== endMarker.offset)
                ) {
                  var range = doc.createRange();
                  range.setStart(startMarker.node, startMarker.offset);
                  selection.removeAllRanges();
                  start$jscomp$0 > end$jscomp$0
                    ? (selection.addRange(range),
                      selection.extend(endMarker.node, endMarker.offset))
                    : (range.setEnd(endMarker.node, endMarker.offset),
                      selection.addRange(range));
                }
              }
            }
          }
          doc = [];
          for (
            selection = priorFocusedElem;
            (selection = selection.parentNode);

          )
            1 === selection.nodeType &&
              doc.push({
                element: selection,
                left: selection.scrollLeft,
                top: selection.scrollTop
              });
          "function" === typeof priorFocusedElem.focus &&
            priorFocusedElem.focus();
          for (
            priorFocusedElem = 0;
            priorFocusedElem < doc.length;
            priorFocusedElem++
          ) {
            var info = doc[priorFocusedElem];
            info.element.scrollLeft = info.left;
            info.element.scrollTop = info.top;
          }
        }
        _enabled = !!eventsEnabled;
        selectionInformation = eventsEnabled = null;
      } finally {
        (executionContext = prevExecutionContext),
          (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = rootMutationHasEffect);
      }
    }
    root.current = finishedWork;
    pendingEffectsStatus = 2;
  }
}
function flushLayoutEffects() {
  if (2 === pendingEffectsStatus) {
    pendingEffectsStatus = 0;
    var root = pendingEffectsRoot,
      finishedWork = pendingFinishedWork,
      rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
    if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
      rootHasLayoutEffect = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      try {
        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
      } finally {
        (executionContext = prevExecutionContext),
          (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = rootHasLayoutEffect);
      }
    }
    pendingEffectsStatus = 3;
  }
}
function flushSpawnedWork() {
  if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
    pendingEffectsStatus = 0;
    requestPaint();
    var root = pendingEffectsRoot,
      finishedWork = pendingFinishedWork,
      lanes = pendingEffectsLanes,
      recoverableErrors = pendingRecoverableErrors;
    0 !== (finishedWork.subtreeFlags & 10256) ||
    0 !== (finishedWork.flags & 10256)
      ? (pendingEffectsStatus = 5)
      : ((pendingEffectsStatus = 0),
        (pendingFinishedWork = pendingEffectsRoot = null),
        releaseRootPooledCache(root, root.pendingLanes));
    var remainingLanes = root.pendingLanes;
    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
    lanesToEventPriority(lanes);
    finishedWork = finishedWork.stateNode;
    if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
      try {
        injectedHook.onCommitFiberRoot(
          rendererID,
          finishedWork,
          void 0,
          128 === (finishedWork.current.flags & 128)
        );
      } catch (err) {}
    if (null !== recoverableErrors) {
      finishedWork = ReactSharedInternals.T;
      remainingLanes = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      ReactSharedInternals.T = null;
      try {
        for (
          var onRecoverableError = root.onRecoverableError, i = 0;
          i < recoverableErrors.length;
          i++
        ) {
          var recoverableError = recoverableErrors[i];
          onRecoverableError(recoverableError.value, {
            componentStack: recoverableError.stack
          });
        }
      } finally {
        (ReactSharedInternals.T = finishedWork),
          (ReactDOMSharedInternals.p = remainingLanes);
      }
    }
    0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
    ensureRootIsScheduled(root);
    remainingLanes = root.pendingLanes;
    0 !== (lanes & 261930) && 0 !== (remainingLanes & 42)
      ? root === rootWithNestedUpdates
        ? nestedUpdateCount++
        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
      : (nestedUpdateCount = 0);
    flushSyncWorkAcrossRoots_impl(0, !1);
  }
}
function releaseRootPooledCache(root, remainingLanes) {
  0 === (root.pooledCacheLanes &= remainingLanes) &&
    ((remainingLanes = root.pooledCache),
    null != remainingLanes &&
      ((root.pooledCache = null), releaseCache(remainingLanes)));
}
function flushPendingEffects() {
  flushMutationEffects();
  flushLayoutEffects();
  flushSpawnedWork();
  return flushPassiveEffects();
}
function flushPassiveEffects() {
  if (5 !== pendingEffectsStatus) return !1;
  var root = pendingEffectsRoot,
    remainingLanes = pendingEffectsRemainingLanes;
  pendingEffectsRemainingLanes = 0;
  var renderPriority = lanesToEventPriority(pendingEffectsLanes),
    prevTransition = ReactSharedInternals.T,
    previousPriority = ReactDOMSharedInternals.p;
  try {
    ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
    ReactSharedInternals.T = null;
    renderPriority = pendingPassiveTransitions;
    pendingPassiveTransitions = null;
    var root$jscomp$0 = pendingEffectsRoot,
      lanes = pendingEffectsLanes;
    pendingEffectsStatus = 0;
    pendingFinishedWork = pendingEffectsRoot = null;
    pendingEffectsLanes = 0;
    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
    var prevExecutionContext = executionContext;
    executionContext |= 4;
    commitPassiveUnmountOnFiber(root$jscomp$0.current);
    commitPassiveMountOnFiber(
      root$jscomp$0,
      root$jscomp$0.current,
      lanes,
      renderPriority
    );
    executionContext = prevExecutionContext;
    flushSyncWorkAcrossRoots_impl(0, !1);
    if (
      injectedHook &&
      "function" === typeof injectedHook.onPostCommitFiberRoot
    )
      try {
        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
      } catch (err) {}
    return !0;
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition),
      releaseRootPooledCache(root, remainingLanes);
  }
}
function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
  null !== rootFiber &&
    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
}
function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
  if (3 === sourceFiber.tag)
    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
  else
    for (; null !== nearestMountedAncestor; ) {
      if (3 === nearestMountedAncestor.tag) {
        captureCommitPhaseErrorOnRoot(
          nearestMountedAncestor,
          sourceFiber,
          error
        );
        break;
      } else if (1 === nearestMountedAncestor.tag) {
        var instance = nearestMountedAncestor.stateNode;
        if (
          "function" ===
            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
          ("function" === typeof instance.componentDidCatch &&
            (null === legacyErrorBoundariesThatAlreadyFailed ||
              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
        ) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          error = createClassErrorUpdate(2);
          instance = enqueueUpdate(nearestMountedAncestor, error, 2);
          null !== instance &&
            (initializeClassErrorUpdate(
              error,
              instance,
              nearestMountedAncestor,
              sourceFiber
            ),
            markRootUpdated$1(instance, 2),
            ensureRootIsScheduled(instance));
          break;
        }
      }
      nearestMountedAncestor = nearestMountedAncestor.return;
    }
}
function attachPingListener(root, wakeable, lanes) {
  var pingCache = root.pingCache;
  if (null === pingCache) {
    pingCache = root.pingCache = new PossiblyWeakMap();
    var threadIDs = new Set();
    pingCache.set(wakeable, threadIDs);
  } else
    (threadIDs = pingCache.get(wakeable)),
      void 0 === threadIDs &&
        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
  threadIDs.has(lanes) ||
    ((workInProgressRootDidAttachPingListener = !0),
    threadIDs.add(lanes),
    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
    wakeable.then(root, root));
}
function pingSuspendedRoot(root, wakeable, pingedLanes) {
  var pingCache = root.pingCache;
  null !== pingCache && pingCache.delete(wakeable);
  root.pingedLanes |= root.suspendedLanes & pingedLanes;
  root.warmLanes &= ~pingedLanes;
  workInProgressRoot === root &&
    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
    (4 === workInProgressRootExitStatus ||
    (3 === workInProgressRootExitStatus &&
      (workInProgressRootRenderLanes & 62914560) ===
        workInProgressRootRenderLanes &&
      300 > now() - globalMostRecentFallbackTime)
      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
      : (workInProgressRootPingedLanes |= pingedLanes),
    workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
      (workInProgressSuspendedRetryLanes = 0));
  ensureRootIsScheduled(root);
}
function retryTimedOutBoundary(boundaryFiber, retryLane) {
  0 === retryLane && (retryLane = claimNextRetryLane());
  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
  null !== boundaryFiber &&
    (markRootUpdated$1(boundaryFiber, retryLane),
    ensureRootIsScheduled(boundaryFiber));
}
function retryDehydratedSuspenseBoundary(boundaryFiber) {
  var suspenseState = boundaryFiber.memoizedState,
    retryLane = 0;
  null !== suspenseState && (retryLane = suspenseState.retryLane);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function resolveRetryWakeable(boundaryFiber, wakeable) {
  var retryLane = 0;
  switch (boundaryFiber.tag) {
    case 31:
    case 13:
      var retryCache = boundaryFiber.stateNode;
      var suspenseState = boundaryFiber.memoizedState;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      break;
    case 19:
      retryCache = boundaryFiber.stateNode;
      break;
    case 22:
      retryCache = boundaryFiber.stateNode._retryCache;
      break;
    default:
      throw Error(formatProdErrorMessage(314));
  }
  null !== retryCache && retryCache.delete(wakeable);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function scheduleCallback$1(priorityLevel, callback) {
  return scheduleCallback$3(priorityLevel, callback);
}
var firstScheduledRoot = null,
  lastScheduledRoot = null,
  didScheduleMicrotask = !1,
  mightHavePendingSyncWork = !1,
  isFlushingWork = !1,
  currentEventTransitionLane = 0;
function ensureRootIsScheduled(root) {
  root !== lastScheduledRoot &&
    null === root.next &&
    (null === lastScheduledRoot
      ? (firstScheduledRoot = lastScheduledRoot = root)
      : (lastScheduledRoot = lastScheduledRoot.next = root));
  mightHavePendingSyncWork = !0;
  didScheduleMicrotask ||
    ((didScheduleMicrotask = !0), scheduleImmediateRootScheduleTask());
}
function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
  if (!isFlushingWork && mightHavePendingSyncWork) {
    isFlushingWork = !0;
    do {
      var didPerformSomeWork = !1;
      for (var root$170 = firstScheduledRoot; null !== root$170; ) {
        if (!onlyLegacy)
          if (0 !== syncTransitionLanes) {
            var pendingLanes = root$170.pendingLanes;
            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
            else {
              var suspendedLanes = root$170.suspendedLanes,
                pingedLanes = root$170.pingedLanes;
              JSCompiler_inline_result =
                (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
              JSCompiler_inline_result &=
                pendingLanes & ~(suspendedLanes & ~pingedLanes);
              JSCompiler_inline_result =
                JSCompiler_inline_result & 201326741
                  ? (JSCompiler_inline_result & 201326741) | 1
                  : JSCompiler_inline_result
                    ? JSCompiler_inline_result | 2
                    : 0;
            }
            0 !== JSCompiler_inline_result &&
              ((didPerformSomeWork = !0),
              performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
          } else
            (JSCompiler_inline_result = workInProgressRootRenderLanes),
              (JSCompiler_inline_result = getNextLanes(
                root$170,
                root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
                null !== root$170.cancelPendingCommit ||
                  -1 !== root$170.timeoutHandle
              )),
              0 === (JSCompiler_inline_result & 3) ||
                checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) ||
                ((didPerformSomeWork = !0),
                performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
        root$170 = root$170.next;
      }
    } while (didPerformSomeWork);
    isFlushingWork = !1;
  }
}
function processRootScheduleInImmediateTask() {
  processRootScheduleInMicrotask();
}
function processRootScheduleInMicrotask() {
  mightHavePendingSyncWork = didScheduleMicrotask = !1;
  var syncTransitionLanes = 0;
  0 !== currentEventTransitionLane &&
    shouldAttemptEagerTransition() &&
    (syncTransitionLanes = currentEventTransitionLane);
  for (
    var currentTime = now(), prev = null, root = firstScheduledRoot;
    null !== root;

  ) {
    var next = root.next,
      nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
    if (0 === nextLanes)
      (root.next = null),
        null === prev ? (firstScheduledRoot = next) : (prev.next = next),
        null === next && (lastScheduledRoot = prev);
    else if (
      ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
    )
      mightHavePendingSyncWork = !0;
    root = next;
  }
  (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus) ||
    flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
  0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
}
function scheduleTaskForRootDuringMicrotask(root, currentTime) {
  for (
    var suspendedLanes = root.suspendedLanes,
      pingedLanes = root.pingedLanes,
      expirationTimes = root.expirationTimes,
      lanes = root.pendingLanes & -62914561;
    0 < lanes;

  ) {
    var index$5 = 31 - clz32(lanes),
      lane = 1 << index$5,
      expirationTime = expirationTimes[index$5];
    if (-1 === expirationTime) {
      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
        expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
    } else expirationTime <= currentTime && (root.expiredLanes |= lane);
    lanes &= ~lane;
  }
  currentTime = workInProgressRoot;
  suspendedLanes = workInProgressRootRenderLanes;
  suspendedLanes = getNextLanes(
    root,
    root === currentTime ? suspendedLanes : 0,
    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
  );
  pingedLanes = root.callbackNode;
  if (
    0 === suspendedLanes ||
    (root === currentTime &&
      (2 === workInProgressSuspendedReason ||
        9 === workInProgressSuspendedReason)) ||
    null !== root.cancelPendingCommit
  )
    return (
      null !== pingedLanes &&
        null !== pingedLanes &&
        cancelCallback$1(pingedLanes),
      (root.callbackNode = null),
      (root.callbackPriority = 0)
    );
  if (
    0 === (suspendedLanes & 3) ||
    checkIfRootIsPrerendering(root, suspendedLanes)
  ) {
    currentTime = suspendedLanes & -suspendedLanes;
    if (currentTime === root.callbackPriority) return currentTime;
    null !== pingedLanes && cancelCallback$1(pingedLanes);
    switch (lanesToEventPriority(suspendedLanes)) {
      case 2:
      case 8:
        suspendedLanes = UserBlockingPriority;
        break;
      case 32:
        suspendedLanes = NormalPriority$1;
        break;
      case 268435456:
        suspendedLanes = IdlePriority;
        break;
      default:
        suspendedLanes = NormalPriority$1;
    }
    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
    root.callbackPriority = currentTime;
    root.callbackNode = suspendedLanes;
    return currentTime;
  }
  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
  root.callbackPriority = 2;
  root.callbackNode = null;
  return 2;
}
function performWorkOnRootViaSchedulerTask(root, didTimeout) {
  if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
    return (root.callbackNode = null), (root.callbackPriority = 0), null;
  var originalCallbackNode = root.callbackNode;
  if (flushPendingEffects() && root.callbackNode !== originalCallbackNode)
    return null;
  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
  );
  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
  performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
  scheduleTaskForRootDuringMicrotask(root, now());
  return null != root.callbackNode && root.callbackNode === originalCallbackNode
    ? performWorkOnRootViaSchedulerTask.bind(null, root)
    : null;
}
function performSyncWorkOnRoot(root, lanes) {
  if (flushPendingEffects()) return null;
  performWorkOnRoot(root, lanes, !0);
}
function scheduleImmediateRootScheduleTask() {
  scheduleMicrotask(function () {
    0 !== (executionContext & 6)
      ? scheduleCallback$3(
          ImmediatePriority,
          processRootScheduleInImmediateTask
        )
      : processRootScheduleInMicrotask();
  });
}
function requestTransitionLane() {
  if (0 === currentEventTransitionLane) {
    var actionScopeLane = currentEntangledLane;
    0 === actionScopeLane &&
      ((actionScopeLane = nextTransitionUpdateLane),
      (nextTransitionUpdateLane <<= 1),
      0 === (nextTransitionUpdateLane & 261888) &&
        (nextTransitionUpdateLane = 256));
    currentEventTransitionLane = actionScopeLane;
  }
  return currentEventTransitionLane;
}
function coerceFormActionProp(actionProp) {
  return null == actionProp ||
    "symbol" === typeof actionProp ||
    "boolean" === typeof actionProp
    ? null
    : "function" === typeof actionProp
      ? actionProp
      : sanitizeURL("" + actionProp);
}
function createFormDataWithSubmitter(form, submitter) {
  var temp = submitter.ownerDocument.createElement("input");
  temp.name = submitter.name;
  temp.value = submitter.value;
  form.id && temp.setAttribute("form", form.id);
  submitter.parentNode.insertBefore(temp, submitter);
  form = new FormData(form);
  temp.parentNode.removeChild(temp);
  return form;
}
function extractEvents$1(
  dispatchQueue,
  domEventName,
  maybeTargetInst,
  nativeEvent,
  nativeEventTarget
) {
  if (
    "submit" === domEventName &&
    maybeTargetInst &&
    maybeTargetInst.stateNode === nativeEventTarget
  ) {
    var action = coerceFormActionProp(
        (nativeEventTarget[internalPropsKey] || null).action
      ),
      submitter = nativeEvent.submitter;
    submitter &&
      ((domEventName = (domEventName = submitter[internalPropsKey] || null)
        ? coerceFormActionProp(domEventName.formAction)
        : submitter.getAttribute("formAction")),
      null !== domEventName && ((action = domEventName), (submitter = null)));
    var event = new SyntheticEvent(
      "action",
      "action",
      null,
      nativeEvent,
      nativeEventTarget
    );
    dispatchQueue.push({
      event: event,
      listeners: [
        {
          instance: null,
          listener: function () {
            if (nativeEvent.defaultPrevented) {
              if (0 !== currentEventTransitionLane) {
                var formData = submitter
                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                  : new FormData(nativeEventTarget);
                startHostTransition(
                  maybeTargetInst,
                  {
                    pending: !0,
                    data: formData,
                    method: nativeEventTarget.method,
                    action: action
                  },
                  null,
                  formData
                );
              }
            } else
              "function" === typeof action &&
                (event.preventDefault(),
                (formData = submitter
                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                  : new FormData(nativeEventTarget)),
                startHostTransition(
                  maybeTargetInst,
                  {
                    pending: !0,
                    data: formData,
                    method: nativeEventTarget.method,
                    action: action
                  },
                  action,
                  formData
                ));
          },
          currentTarget: nativeEventTarget
        }
      ]
    });
  }
}
for (
  var i$jscomp$inline_1577 = 0;
  i$jscomp$inline_1577 < simpleEventPluginEvents.length;
  i$jscomp$inline_1577++
) {
  var eventName$jscomp$inline_1578 =
      simpleEventPluginEvents[i$jscomp$inline_1577],
    domEventName$jscomp$inline_1579 =
      eventName$jscomp$inline_1578.toLowerCase(),
    capitalizedEvent$jscomp$inline_1580 =
      eventName$jscomp$inline_1578[0].toUpperCase() +
      eventName$jscomp$inline_1578.slice(1);
  registerSimpleEvent(
    domEventName$jscomp$inline_1579,
    "on" + capitalizedEvent$jscomp$inline_1580
  );
}
registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
registerSimpleEvent(ANIMATION_START, "onAnimationStart");
registerSimpleEvent("dblclick", "onDoubleClick");
registerSimpleEvent("focusin", "onFocus");
registerSimpleEvent("focusout", "onBlur");
registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
registerSimpleEvent(TRANSITION_START, "onTransitionStart");
registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
registerTwoPhaseEvent(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
registerTwoPhaseEvent(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
registerTwoPhaseEvent("onBeforeInput", [
  "compositionend",
  "keypress",
  "textInput",
  "paste"
]);
registerTwoPhaseEvent(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
registerTwoPhaseEvent(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
registerTwoPhaseEvent(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var mediaEventTypes =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  nonDelegatedEvents = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle"
      .split(" ")
      .concat(mediaEventTypes)
  );
function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  eventSystemFlags = 0 !== (eventSystemFlags & 4);
  for (var i = 0; i < dispatchQueue.length; i++) {
    var _dispatchQueue$i = dispatchQueue[i],
      event = _dispatchQueue$i.event;
    _dispatchQueue$i = _dispatchQueue$i.listeners;
    a: {
      var previousInstance = void 0;
      if (eventSystemFlags)
        for (
          var i$jscomp$0 = _dispatchQueue$i.length - 1;
          0 <= i$jscomp$0;
          i$jscomp$0--
        ) {
          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
            instance = _dispatchListeners$i.instance,
            currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
      else
        for (
          i$jscomp$0 = 0;
          i$jscomp$0 < _dispatchQueue$i.length;
          i$jscomp$0++
        ) {
          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
          instance = _dispatchListeners$i.instance;
          currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
    }
  }
}
function listenToNonDelegatedEvent(domEventName, targetElement) {
  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
  void 0 === JSCompiler_inline_result &&
    (JSCompiler_inline_result = targetElement[internalEventHandlersKey] =
      new Set());
  var listenerSetKey = domEventName + "__bubble";
  JSCompiler_inline_result.has(listenerSetKey) ||
    (addTrappedEventListener(targetElement, domEventName, 2, !1),
    JSCompiler_inline_result.add(listenerSetKey));
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  var eventSystemFlags = 0;
  isCapturePhaseListener && (eventSystemFlags |= 4);
  addTrappedEventListener(
    target,
    domEventName,
    eventSystemFlags,
    isCapturePhaseListener
  );
}
var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
function listenToAllSupportedEvents(rootContainerElement) {
  if (!rootContainerElement[listeningMarker]) {
    rootContainerElement[listeningMarker] = !0;
    allNativeEvents.forEach(function (domEventName) {
      "selectionchange" !== domEventName &&
        (nonDelegatedEvents.has(domEventName) ||
          listenToNativeEvent(domEventName, !1, rootContainerElement),
        listenToNativeEvent(domEventName, !0, rootContainerElement));
    });
    var ownerDocument =
      9 === rootContainerElement.nodeType
        ? rootContainerElement
        : rootContainerElement.ownerDocument;
    null === ownerDocument ||
      ownerDocument[listeningMarker] ||
      ((ownerDocument[listeningMarker] = !0),
      listenToNativeEvent("selectionchange", !1, ownerDocument));
  }
}
function addTrappedEventListener(
  targetContainer,
  domEventName,
  eventSystemFlags,
  isCapturePhaseListener
) {
  switch (getEventPriority(domEventName)) {
    case 2:
      var listenerWrapper = dispatchDiscreteEvent;
      break;
    case 8:
      listenerWrapper = dispatchContinuousEvent;
      break;
    default:
      listenerWrapper = dispatchEvent;
  }
  eventSystemFlags = listenerWrapper.bind(
    null,
    domEventName,
    eventSystemFlags,
    targetContainer
  );
  listenerWrapper = void 0;
  !passiveBrowserEventsSupported ||
    ("touchstart" !== domEventName &&
      "touchmove" !== domEventName &&
      "wheel" !== domEventName) ||
    (listenerWrapper = !0);
  isCapturePhaseListener
    ? void 0 !== listenerWrapper
      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: !0,
          passive: listenerWrapper
        })
      : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)
    : void 0 !== listenerWrapper
      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        })
      : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
}
function dispatchEventForPluginEventSystem(
  domEventName,
  eventSystemFlags,
  nativeEvent,
  targetInst$jscomp$0,
  targetContainer
) {
  var ancestorInst = targetInst$jscomp$0;
  if (
    0 === (eventSystemFlags & 1) &&
    0 === (eventSystemFlags & 2) &&
    null !== targetInst$jscomp$0
  )
    a: for (;;) {
      if (null === targetInst$jscomp$0) return;
      var nodeTag = targetInst$jscomp$0.tag;
      if (3 === nodeTag || 4 === nodeTag) {
        var container = targetInst$jscomp$0.stateNode.containerInfo;
        if (container === targetContainer) break;
        if (4 === nodeTag)
          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
            var grandTag = nodeTag.tag;
            if (
              (3 === grandTag || 4 === grandTag) &&
              nodeTag.stateNode.containerInfo === targetContainer
            )
              return;
            nodeTag = nodeTag.return;
          }
        for (; null !== container; ) {
          nodeTag = getClosestInstanceFromNode(container);
          if (null === nodeTag) return;
          grandTag = nodeTag.tag;
          if (
            5 === grandTag ||
            6 === grandTag ||
            26 === grandTag ||
            27 === grandTag
          ) {
            targetInst$jscomp$0 = ancestorInst = nodeTag;
            continue a;
          }
          container = container.parentNode;
        }
      }
      targetInst$jscomp$0 = targetInst$jscomp$0.return;
    }
  batchedUpdates$1(function () {
    var targetInst = ancestorInst,
      nativeEventTarget = getEventTarget(nativeEvent),
      dispatchQueue = [];
    a: {
      var reactName = topLevelEventsToReactNames.get(domEventName);
      if (void 0 !== reactName) {
        var SyntheticEventCtor = SyntheticEvent,
          reactEventType = domEventName;
        switch (domEventName) {
          case "keypress":
            if (0 === getEventCharCode(nativeEvent)) break a;
          case "keydown":
          case "keyup":
            SyntheticEventCtor = SyntheticKeyboardEvent;
            break;
          case "focusin":
            reactEventType = "focus";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "focusout":
            reactEventType = "blur";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "beforeblur":
          case "afterblur":
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "click":
            if (2 === nativeEvent.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            SyntheticEventCtor = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            SyntheticEventCtor = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            SyntheticEventCtor = SyntheticTouchEvent;
            break;
          case ANIMATION_END:
          case ANIMATION_ITERATION:
          case ANIMATION_START:
            SyntheticEventCtor = SyntheticAnimationEvent;
            break;
          case TRANSITION_END:
            SyntheticEventCtor = SyntheticTransitionEvent;
            break;
          case "scroll":
          case "scrollend":
            SyntheticEventCtor = SyntheticUIEvent;
            break;
          case "wheel":
            SyntheticEventCtor = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            SyntheticEventCtor = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            SyntheticEventCtor = SyntheticPointerEvent;
            break;
          case "toggle":
          case "beforetoggle":
            SyntheticEventCtor = SyntheticToggleEvent;
        }
        var inCapturePhase = 0 !== (eventSystemFlags & 4),
          accumulateTargetOnly =
            !inCapturePhase &&
            ("scroll" === domEventName || "scrollend" === domEventName),
          reactEventName = inCapturePhase
            ? null !== reactName
              ? reactName + "Capture"
              : null
            : reactName;
        inCapturePhase = [];
        for (
          var instance = targetInst, lastHostComponent;
          null !== instance;

        ) {
          var _instance = instance;
          lastHostComponent = _instance.stateNode;
          _instance = _instance.tag;
          (5 !== _instance && 26 !== _instance && 27 !== _instance) ||
            null === lastHostComponent ||
            null === reactEventName ||
            ((_instance = getListener(instance, reactEventName)),
            null != _instance &&
              inCapturePhase.push(
                createDispatchListener(instance, _instance, lastHostComponent)
              ));
          if (accumulateTargetOnly) break;
          instance = instance.return;
        }
        0 < inCapturePhase.length &&
          ((reactName = new SyntheticEventCtor(
            reactName,
            reactEventType,
            null,
            nativeEvent,
            nativeEventTarget
          )),
          dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
      }
    }
    if (0 === (eventSystemFlags & 7)) {
      a: {
        reactName =
          "mouseover" === domEventName || "pointerover" === domEventName;
        SyntheticEventCtor =
          "mouseout" === domEventName || "pointerout" === domEventName;
        if (
          reactName &&
          nativeEvent !== currentReplayingEvent &&
          (reactEventType =
            nativeEvent.relatedTarget || nativeEvent.fromElement) &&
          (getClosestInstanceFromNode(reactEventType) ||
            reactEventType[internalContainerInstanceKey])
        )
          break a;
        if (SyntheticEventCtor || reactName) {
          reactName =
            nativeEventTarget.window === nativeEventTarget
              ? nativeEventTarget
              : (reactName = nativeEventTarget.ownerDocument)
                ? reactName.defaultView || reactName.parentWindow
                : window;
          if (SyntheticEventCtor) {
            if (
              ((reactEventType =
                nativeEvent.relatedTarget || nativeEvent.toElement),
              (SyntheticEventCtor = targetInst),
              (reactEventType = reactEventType
                ? getClosestInstanceFromNode(reactEventType)
                : null),
              null !== reactEventType &&
                ((accumulateTargetOnly =
                  getNearestMountedFiber(reactEventType)),
                (inCapturePhase = reactEventType.tag),
                reactEventType !== accumulateTargetOnly ||
                  (5 !== inCapturePhase &&
                    27 !== inCapturePhase &&
                    6 !== inCapturePhase)))
            )
              reactEventType = null;
          } else (SyntheticEventCtor = null), (reactEventType = targetInst);
          if (SyntheticEventCtor !== reactEventType) {
            inCapturePhase = SyntheticMouseEvent;
            _instance = "onMouseLeave";
            reactEventName = "onMouseEnter";
            instance = "mouse";
            if ("pointerout" === domEventName || "pointerover" === domEventName)
              (inCapturePhase = SyntheticPointerEvent),
                (_instance = "onPointerLeave"),
                (reactEventName = "onPointerEnter"),
                (instance = "pointer");
            accumulateTargetOnly =
              null == SyntheticEventCtor
                ? reactName
                : getNodeFromInstance(SyntheticEventCtor);
            lastHostComponent =
              null == reactEventType
                ? reactName
                : getNodeFromInstance(reactEventType);
            reactName = new inCapturePhase(
              _instance,
              instance + "leave",
              SyntheticEventCtor,
              nativeEvent,
              nativeEventTarget
            );
            reactName.target = accumulateTargetOnly;
            reactName.relatedTarget = lastHostComponent;
            _instance = null;
            getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
              ((inCapturePhase = new inCapturePhase(
                reactEventName,
                instance + "enter",
                reactEventType,
                nativeEvent,
                nativeEventTarget
              )),
              (inCapturePhase.target = lastHostComponent),
              (inCapturePhase.relatedTarget = accumulateTargetOnly),
              (_instance = inCapturePhase));
            accumulateTargetOnly = _instance;
            if (SyntheticEventCtor && reactEventType)
              b: {
                inCapturePhase = getParent;
                reactEventName = SyntheticEventCtor;
                instance = reactEventType;
                lastHostComponent = 0;
                for (
                  _instance = reactEventName;
                  _instance;
                  _instance = inCapturePhase(_instance)
                )
                  lastHostComponent++;
                _instance = 0;
                for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                  _instance++;
                for (; 0 < lastHostComponent - _instance; )
                  (reactEventName = inCapturePhase(reactEventName)),
                    lastHostComponent--;
                for (; 0 < _instance - lastHostComponent; )
                  (instance = inCapturePhase(instance)), _instance--;
                for (; lastHostComponent--; ) {
                  if (
                    reactEventName === instance ||
                    (null !== instance && reactEventName === instance.alternate)
                  ) {
                    inCapturePhase = reactEventName;
                    break b;
                  }
                  reactEventName = inCapturePhase(reactEventName);
                  instance = inCapturePhase(instance);
                }
                inCapturePhase = null;
              }
            else inCapturePhase = null;
            null !== SyntheticEventCtor &&
              accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                reactName,
                SyntheticEventCtor,
                inCapturePhase,
                !1
              );
            null !== reactEventType &&
              null !== accumulateTargetOnly &&
              accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                accumulateTargetOnly,
                reactEventType,
                inCapturePhase,
                !0
              );
          }
        }
      }
      a: {
        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
        SyntheticEventCtor =
          reactName.nodeName && reactName.nodeName.toLowerCase();
        if (
          "select" === SyntheticEventCtor ||
          ("input" === SyntheticEventCtor && "file" === reactName.type)
        )
          var getTargetInstFunc = getTargetInstForChangeEvent;
        else if (isTextInputElement(reactName))
          if (isInputEventSupported)
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            var handleEventFunc = handleEventsForInputEventPolyfill;
          }
        else
          (SyntheticEventCtor = reactName.nodeName),
            !SyntheticEventCtor ||
            "input" !== SyntheticEventCtor.toLowerCase() ||
            ("checkbox" !== reactName.type && "radio" !== reactName.type)
              ? targetInst &&
                isCustomElement(targetInst.elementType) &&
                (getTargetInstFunc = getTargetInstForChangeEvent)
              : (getTargetInstFunc = getTargetInstForClickEvent);
        if (
          getTargetInstFunc &&
          (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
        ) {
          createAndAccumulateChangeEvent(
            dispatchQueue,
            getTargetInstFunc,
            nativeEvent,
            nativeEventTarget
          );
          break a;
        }
        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
        "focusout" === domEventName &&
          targetInst &&
          "number" === reactName.type &&
          null != targetInst.memoizedProps.value &&
          setDefaultValue(reactName, "number", reactName.value);
      }
      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
      switch (domEventName) {
        case "focusin":
          if (
            isTextInputElement(handleEventFunc) ||
            "true" === handleEventFunc.contentEditable
          )
            (activeElement = handleEventFunc),
              (activeElementInst = targetInst),
              (lastSelection = null);
          break;
        case "focusout":
          lastSelection = activeElementInst = activeElement = null;
          break;
        case "mousedown":
          mouseDown = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          mouseDown = !1;
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          break;
        case "selectionchange":
          if (skipSelectionChangeEvent) break;
        case "keydown":
        case "keyup":
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      }
      var fallbackData;
      if (canUseCompositionEvent)
        b: {
          switch (domEventName) {
            case "compositionstart":
              var eventType = "onCompositionStart";
              break b;
            case "compositionend":
              eventType = "onCompositionEnd";
              break b;
            case "compositionupdate":
              eventType = "onCompositionUpdate";
              break b;
          }
          eventType = void 0;
        }
      else
        isComposing
          ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
            (eventType = "onCompositionEnd")
          : "keydown" === domEventName &&
            229 === nativeEvent.keyCode &&
            (eventType = "onCompositionStart");
      eventType &&
        (useFallbackCompositionData &&
          "ko" !== nativeEvent.locale &&
          (isComposing || "onCompositionStart" !== eventType
            ? "onCompositionEnd" === eventType &&
              isComposing &&
              (fallbackData = getData())
            : ((root = nativeEventTarget),
              (startText = "value" in root ? root.value : root.textContent),
              (isComposing = !0))),
        (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),
        0 < handleEventFunc.length &&
          ((eventType = new SyntheticCompositionEvent(
            eventType,
            domEventName,
            null,
            nativeEvent,
            nativeEventTarget
          )),
          dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),
          fallbackData
            ? (eventType.data = fallbackData)
            : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
              null !== fallbackData && (eventType.data = fallbackData))));
      if (
        (fallbackData = canUseTextInputEvent
          ? getNativeBeforeInputChars(domEventName, nativeEvent)
          : getFallbackBeforeInputChars(domEventName, nativeEvent))
      )
        (eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput")),
          0 < eventType.length &&
            ((handleEventFunc = new SyntheticCompositionEvent(
              "onBeforeInput",
              "beforeinput",
              null,
              nativeEvent,
              nativeEventTarget
            )),
            dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }),
            (handleEventFunc.data = fallbackData));
      extractEvents$1(
        dispatchQueue,
        domEventName,
        targetInst,
        nativeEvent,
        nativeEventTarget
      );
    }
    processDispatchQueue(dispatchQueue, eventSystemFlags);
  });
}
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance: instance,
    listener: listener,
    currentTarget: currentTarget
  };
}
function accumulateTwoPhaseListeners(targetFiber, reactName) {
  for (
    var captureName = reactName + "Capture", listeners = [];
    null !== targetFiber;

  ) {
    var _instance2 = targetFiber,
      stateNode = _instance2.stateNode;
    _instance2 = _instance2.tag;
    (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
      null === stateNode ||
      ((_instance2 = getListener(targetFiber, captureName)),
      null != _instance2 &&
        listeners.unshift(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ),
      (_instance2 = getListener(targetFiber, reactName)),
      null != _instance2 &&
        listeners.push(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ));
    if (3 === targetFiber.tag) return listeners;
    targetFiber = targetFiber.return;
  }
  return [];
}
function getParent(inst) {
  if (null === inst) return null;
  do inst = inst.return;
  while (inst && 5 !== inst.tag && 27 !== inst.tag);
  return inst ? inst : null;
}
function accumulateEnterLeaveListenersForEvent(
  dispatchQueue,
  event,
  target,
  common,
  inCapturePhase
) {
  for (
    var registrationName = event._reactName, listeners = [];
    null !== target && target !== common;

  ) {
    var _instance3 = target,
      alternate = _instance3.alternate,
      stateNode = _instance3.stateNode;
    _instance3 = _instance3.tag;
    if (null !== alternate && alternate === common) break;
    (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
      null === stateNode ||
      ((alternate = stateNode),
      inCapturePhase
        ? ((stateNode = getListener(target, registrationName)),
          null != stateNode &&
            listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            ))
        : inCapturePhase ||
          ((stateNode = getListener(target, registrationName)),
          null != stateNode &&
            listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
    target = target.return;
  }
  0 !== listeners.length &&
    dispatchQueue.push({ event: event, listeners: listeners });
}
var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
function normalizeMarkupForTextOrAttribute(markup) {
  return ("string" === typeof markup ? markup : "" + markup)
    .replace(NORMALIZE_NEWLINES_REGEX, "\n")
    .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
}
function checkForUnmatchedText(serverText, clientText) {
  clientText = normalizeMarkupForTextOrAttribute(clientText);
  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
}
function setProp(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "children":
      "string" === typeof value
        ? "body" === tag ||
          ("textarea" === tag && "" === value) ||
          setTextContent(domElement, value)
        : ("number" === typeof value || "bigint" === typeof value) &&
          "body" !== tag &&
          setTextContent(domElement, "" + value);
      break;
    case "className":
      setValueForKnownAttribute(domElement, "class", value);
      break;
    case "tabIndex":
      setValueForKnownAttribute(domElement, "tabindex", value);
      break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height":
      setValueForKnownAttribute(domElement, key, value);
      break;
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "data":
      if ("object" !== tag) {
        setValueForKnownAttribute(domElement, "data", value);
        break;
      }
    case "src":
    case "href":
      if ("" === value && ("a" !== tag || "href" !== key)) {
        domElement.removeAttribute(key);
        break;
      }
      if (
        null == value ||
        "function" === typeof value ||
        "symbol" === typeof value ||
        "boolean" === typeof value
      ) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "action":
    case "formAction":
      if ("function" === typeof value) {
        domElement.setAttribute(
          key,
          "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
        );
        break;
      } else
        "function" === typeof prevValue &&
          ("formAction" === key
            ? ("input" !== tag &&
                setProp(domElement, tag, "name", props.name, props, null),
              setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ),
              setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ),
              setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              ))
            : (setProp(domElement, tag, "encType", props.encType, props, null),
              setProp(domElement, tag, "method", props.method, props, null),
              setProp(domElement, tag, "target", props.target, props, null)));
      if (
        null == value ||
        "symbol" === typeof value ||
        "boolean" === typeof value
      ) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value))
          throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "multiple":
      domElement.multiple =
        value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "muted":
      domElement.muted =
        value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "ref":
      break;
    case "autoFocus":
      break;
    case "xlinkHref":
      if (
        null == value ||
        "function" === typeof value ||
        "boolean" === typeof value ||
        "symbol" === typeof value
      ) {
        domElement.removeAttribute("xlink:href");
        break;
      }
      key = sanitizeURL("" + value);
      domElement.setAttributeNS(
        "http://www.w3.org/1999/xlink",
        "xlink:href",
        key
      );
      break;
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha":
      null != value && "function" !== typeof value && "symbol" !== typeof value
        ? domElement.setAttribute(key, "" + value)
        : domElement.removeAttribute(key);
      break;
    case "inert":
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope":
      value && "function" !== typeof value && "symbol" !== typeof value
        ? domElement.setAttribute(key, "")
        : domElement.removeAttribute(key);
      break;
    case "capture":
    case "download":
      !0 === value
        ? domElement.setAttribute(key, "")
        : !1 !== value &&
            null != value &&
            "function" !== typeof value &&
            "symbol" !== typeof value
          ? domElement.setAttribute(key, value)
          : domElement.removeAttribute(key);
      break;
    case "cols":
    case "rows":
    case "size":
    case "span":
      null != value &&
      "function" !== typeof value &&
      "symbol" !== typeof value &&
      !isNaN(value) &&
      1 <= value
        ? domElement.setAttribute(key, value)
        : domElement.removeAttribute(key);
      break;
    case "rowSpan":
    case "start":
      null == value ||
      "function" === typeof value ||
      "symbol" === typeof value ||
      isNaN(value)
        ? domElement.removeAttribute(key)
        : domElement.setAttribute(key, value);
      break;
    case "popover":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      setValueForAttribute(domElement, "popover", value);
      break;
    case "xlinkActuate":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:actuate",
        value
      );
      break;
    case "xlinkArcrole":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:arcrole",
        value
      );
      break;
    case "xlinkRole":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:role",
        value
      );
      break;
    case "xlinkShow":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:show",
        value
      );
      break;
    case "xlinkTitle":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:title",
        value
      );
      break;
    case "xlinkType":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:type",
        value
      );
      break;
    case "xmlBase":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:base",
        value
      );
      break;
    case "xmlLang":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:lang",
        value
      );
      break;
    case "xmlSpace":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:space",
        value
      );
      break;
    case "is":
      setValueForAttribute(domElement, "is", value);
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (
        !(2 < key.length) ||
        ("o" !== key[0] && "O" !== key[0]) ||
        ("n" !== key[1] && "N" !== key[1])
      )
        (key = aliases.get(key) || key),
          setValueForAttribute(domElement, key, value);
  }
}
function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value))
          throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "children":
      "string" === typeof value
        ? setTextContent(domElement, value)
        : ("number" === typeof value || "bigint" === typeof value) &&
          setTextContent(domElement, "" + value);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "innerHTML":
    case "ref":
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (!registrationNameDependencies.hasOwnProperty(key))
        a: {
          if (
            "o" === key[0] &&
            "n" === key[1] &&
            ((props = key.endsWith("Capture")),
            (tag = key.slice(2, props ? key.length - 7 : void 0)),
            (prevValue = domElement[internalPropsKey] || null),
            (prevValue = null != prevValue ? prevValue[key] : null),
            "function" === typeof prevValue &&
              domElement.removeEventListener(tag, prevValue, props),
            "function" === typeof value)
          ) {
            "function" !== typeof prevValue &&
              null !== prevValue &&
              (key in domElement
                ? (domElement[key] = null)
                : domElement.hasAttribute(key) &&
                  domElement.removeAttribute(key));
            domElement.addEventListener(tag, value, props);
            break a;
          }
          key in domElement
            ? (domElement[key] = value)
            : !0 === value
              ? domElement.setAttribute(key, "")
              : setValueForAttribute(domElement, key, value);
        }
  }
}
function setInitialProperties(domElement, tag, props) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "img":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      var hasSrc = !1,
        hasSrcSet = !1,
        propKey;
      for (propKey in props)
        if (props.hasOwnProperty(propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "src":
                hasSrc = !0;
                break;
              case "srcSet":
                hasSrcSet = !0;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(formatProdErrorMessage(137, tag));
              default:
                setProp(domElement, tag, propKey, propValue, props, null);
            }
        }
      hasSrcSet &&
        setProp(domElement, tag, "srcSet", props.srcSet, props, null);
      hasSrc && setProp(domElement, tag, "src", props.src, props, null);
      return;
    case "input":
      listenToNonDelegatedEvent("invalid", domElement);
      var defaultValue = (propKey = propValue = hasSrcSet = null),
        checked = null,
        defaultChecked = null;
      for (hasSrc in props)
        if (props.hasOwnProperty(hasSrc)) {
          var propValue$184 = props[hasSrc];
          if (null != propValue$184)
            switch (hasSrc) {
              case "name":
                hasSrcSet = propValue$184;
                break;
              case "type":
                propValue = propValue$184;
                break;
              case "checked":
                checked = propValue$184;
                break;
              case "defaultChecked":
                defaultChecked = propValue$184;
                break;
              case "value":
                propKey = propValue$184;
                break;
              case "defaultValue":
                defaultValue = propValue$184;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propValue$184)
                  throw Error(formatProdErrorMessage(137, tag));
                break;
              default:
                setProp(domElement, tag, hasSrc, propValue$184, props, null);
            }
        }
      initInput(
        domElement,
        propKey,
        defaultValue,
        checked,
        defaultChecked,
        propValue,
        hasSrcSet,
        !1
      );
      return;
    case "select":
      listenToNonDelegatedEvent("invalid", domElement);
      hasSrc = propValue = propKey = null;
      for (hasSrcSet in props)
        if (
          props.hasOwnProperty(hasSrcSet) &&
          ((defaultValue = props[hasSrcSet]), null != defaultValue)
        )
          switch (hasSrcSet) {
            case "value":
              propKey = defaultValue;
              break;
            case "defaultValue":
              propValue = defaultValue;
              break;
            case "multiple":
              hasSrc = defaultValue;
            default:
              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
          }
      tag = propKey;
      props = propValue;
      domElement.multiple = !!hasSrc;
      null != tag
        ? updateOptions(domElement, !!hasSrc, tag, !1)
        : null != props && updateOptions(domElement, !!hasSrc, props, !0);
      return;
    case "textarea":
      listenToNonDelegatedEvent("invalid", domElement);
      propKey = hasSrcSet = hasSrc = null;
      for (propValue in props)
        if (
          props.hasOwnProperty(propValue) &&
          ((defaultValue = props[propValue]), null != defaultValue)
        )
          switch (propValue) {
            case "value":
              hasSrc = defaultValue;
              break;
            case "defaultValue":
              hasSrcSet = defaultValue;
              break;
            case "children":
              propKey = defaultValue;
              break;
            case "dangerouslySetInnerHTML":
              if (null != defaultValue) throw Error(formatProdErrorMessage(91));
              break;
            default:
              setProp(domElement, tag, propValue, defaultValue, props, null);
          }
      initTextarea(domElement, hasSrc, hasSrcSet, propKey);
      return;
    case "option":
      for (checked in props)
        if (
          props.hasOwnProperty(checked) &&
          ((hasSrc = props[checked]), null != hasSrc)
        )
          switch (checked) {
            case "selected":
              domElement.selected =
                hasSrc &&
                "function" !== typeof hasSrc &&
                "symbol" !== typeof hasSrc;
              break;
            default:
              setProp(domElement, tag, checked, hasSrc, props, null);
          }
      return;
    case "dialog":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      listenToNonDelegatedEvent("cancel", domElement);
      listenToNonDelegatedEvent("close", domElement);
      break;
    case "iframe":
    case "object":
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "video":
    case "audio":
      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
      break;
    case "image":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", domElement);
      break;
    case "embed":
    case "source":
    case "link":
      listenToNonDelegatedEvent("error", domElement),
        listenToNonDelegatedEvent("load", domElement);
    case "area":
    case "base":
    case "br":
    case "col":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "track":
    case "wbr":
    case "menuitem":
      for (defaultChecked in props)
        if (
          props.hasOwnProperty(defaultChecked) &&
          ((hasSrc = props[defaultChecked]), null != hasSrc)
        )
          switch (defaultChecked) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(formatProdErrorMessage(137, tag));
            default:
              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (propValue$184 in props)
          props.hasOwnProperty(propValue$184) &&
            ((hasSrc = props[propValue$184]),
            void 0 !== hasSrc &&
              setPropOnCustomElement(
                domElement,
                tag,
                propValue$184,
                hasSrc,
                props,
                void 0
              ));
        return;
      }
  }
  for (defaultValue in props)
    props.hasOwnProperty(defaultValue) &&
      ((hasSrc = props[defaultValue]),
      null != hasSrc &&
        setProp(domElement, tag, defaultValue, hasSrc, props, null));
}
function updateProperties(domElement, tag, lastProps, nextProps) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "input":
      var name = null,
        type = null,
        value = null,
        defaultValue = null,
        lastDefaultValue = null,
        checked = null,
        defaultChecked = null;
      for (propKey in lastProps) {
        var lastProp = lastProps[propKey];
        if (lastProps.hasOwnProperty(propKey) && null != lastProp)
          switch (propKey) {
            case "checked":
              break;
            case "value":
              break;
            case "defaultValue":
              lastDefaultValue = lastProp;
            default:
              nextProps.hasOwnProperty(propKey) ||
                setProp(domElement, tag, propKey, null, nextProps, lastProp);
          }
      }
      for (var propKey$201 in nextProps) {
        var propKey = nextProps[propKey$201];
        lastProp = lastProps[propKey$201];
        if (
          nextProps.hasOwnProperty(propKey$201) &&
          (null != propKey || null != lastProp)
        )
          switch (propKey$201) {
            case "type":
              type = propKey;
              break;
            case "name":
              name = propKey;
              break;
            case "checked":
              checked = propKey;
              break;
            case "defaultChecked":
              defaultChecked = propKey;
              break;
            case "value":
              value = propKey;
              break;
            case "defaultValue":
              defaultValue = propKey;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey)
                throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              propKey !== lastProp &&
                setProp(
                  domElement,
                  tag,
                  propKey$201,
                  propKey,
                  nextProps,
                  lastProp
                );
          }
      }
      updateInput(
        domElement,
        value,
        defaultValue,
        lastDefaultValue,
        checked,
        defaultChecked,
        type,
        name
      );
      return;
    case "select":
      propKey = value = defaultValue = propKey$201 = null;
      for (type in lastProps)
        if (
          ((lastDefaultValue = lastProps[type]),
          lastProps.hasOwnProperty(type) && null != lastDefaultValue)
        )
          switch (type) {
            case "value":
              break;
            case "multiple":
              propKey = lastDefaultValue;
            default:
              nextProps.hasOwnProperty(type) ||
                setProp(
                  domElement,
                  tag,
                  type,
                  null,
                  nextProps,
                  lastDefaultValue
                );
          }
      for (name in nextProps)
        if (
          ((type = nextProps[name]),
          (lastDefaultValue = lastProps[name]),
          nextProps.hasOwnProperty(name) &&
            (null != type || null != lastDefaultValue))
        )
          switch (name) {
            case "value":
              propKey$201 = type;
              break;
            case "defaultValue":
              defaultValue = type;
              break;
            case "multiple":
              value = type;
            default:
              type !== lastDefaultValue &&
                setProp(
                  domElement,
                  tag,
                  name,
                  type,
                  nextProps,
                  lastDefaultValue
                );
          }
      tag = defaultValue;
      lastProps = value;
      nextProps = propKey;
      null != propKey$201
        ? updateOptions(domElement, !!lastProps, propKey$201, !1)
        : !!nextProps !== !!lastProps &&
          (null != tag
            ? updateOptions(domElement, !!lastProps, tag, !0)
            : updateOptions(domElement, !!lastProps, lastProps ? [] : "", !1));
      return;
    case "textarea":
      propKey = propKey$201 = null;
      for (defaultValue in lastProps)
        if (
          ((name = lastProps[defaultValue]),
          lastProps.hasOwnProperty(defaultValue) &&
            null != name &&
            !nextProps.hasOwnProperty(defaultValue))
        )
          switch (defaultValue) {
            case "value":
              break;
            case "children":
              break;
            default:
              setProp(domElement, tag, defaultValue, null, nextProps, name);
          }
      for (value in nextProps)
        if (
          ((name = nextProps[value]),
          (type = lastProps[value]),
          nextProps.hasOwnProperty(value) && (null != name || null != type))
        )
          switch (value) {
            case "value":
              propKey$201 = name;
              break;
            case "defaultValue":
              propKey = name;
              break;
            case "children":
              break;
            case "dangerouslySetInnerHTML":
              if (null != name) throw Error(formatProdErrorMessage(91));
              break;
            default:
              name !== type &&
                setProp(domElement, tag, value, name, nextProps, type);
          }
      updateTextarea(domElement, propKey$201, propKey);
      return;
    case "option":
      for (var propKey$217 in lastProps)
        if (
          ((propKey$201 = lastProps[propKey$217]),
          lastProps.hasOwnProperty(propKey$217) &&
            null != propKey$201 &&
            !nextProps.hasOwnProperty(propKey$217))
        )
          switch (propKey$217) {
            case "selected":
              domElement.selected = !1;
              break;
            default:
              setProp(
                domElement,
                tag,
                propKey$217,
                null,
                nextProps,
                propKey$201
              );
          }
      for (lastDefaultValue in nextProps)
        if (
          ((propKey$201 = nextProps[lastDefaultValue]),
          (propKey = lastProps[lastDefaultValue]),
          nextProps.hasOwnProperty(lastDefaultValue) &&
            propKey$201 !== propKey &&
            (null != propKey$201 || null != propKey))
        )
          switch (lastDefaultValue) {
            case "selected":
              domElement.selected =
                propKey$201 &&
                "function" !== typeof propKey$201 &&
                "symbol" !== typeof propKey$201;
              break;
            default:
              setProp(
                domElement,
                tag,
                lastDefaultValue,
                propKey$201,
                nextProps,
                propKey
              );
          }
      return;
    case "img":
    case "link":
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
    case "menuitem":
      for (var propKey$222 in lastProps)
        (propKey$201 = lastProps[propKey$222]),
          lastProps.hasOwnProperty(propKey$222) &&
            null != propKey$201 &&
            !nextProps.hasOwnProperty(propKey$222) &&
            setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
      for (checked in nextProps)
        if (
          ((propKey$201 = nextProps[checked]),
          (propKey = lastProps[checked]),
          nextProps.hasOwnProperty(checked) &&
            propKey$201 !== propKey &&
            (null != propKey$201 || null != propKey))
        )
          switch (checked) {
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey$201)
                throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              setProp(
                domElement,
                tag,
                checked,
                propKey$201,
                nextProps,
                propKey
              );
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (var propKey$227 in lastProps)
          (propKey$201 = lastProps[propKey$227]),
            lastProps.hasOwnProperty(propKey$227) &&
              void 0 !== propKey$201 &&
              !nextProps.hasOwnProperty(propKey$227) &&
              setPropOnCustomElement(
                domElement,
                tag,
                propKey$227,
                void 0,
                nextProps,
                propKey$201
              );
        for (defaultChecked in nextProps)
          (propKey$201 = nextProps[defaultChecked]),
            (propKey = lastProps[defaultChecked]),
            !nextProps.hasOwnProperty(defaultChecked) ||
              propKey$201 === propKey ||
              (void 0 === propKey$201 && void 0 === propKey) ||
              setPropOnCustomElement(
                domElement,
                tag,
                defaultChecked,
                propKey$201,
                nextProps,
                propKey
              );
        return;
      }
  }
  for (var propKey$232 in lastProps)
    (propKey$201 = lastProps[propKey$232]),
      lastProps.hasOwnProperty(propKey$232) &&
        null != propKey$201 &&
        !nextProps.hasOwnProperty(propKey$232) &&
        setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
  for (lastProp in nextProps)
    (propKey$201 = nextProps[lastProp]),
      (propKey = lastProps[lastProp]),
      !nextProps.hasOwnProperty(lastProp) ||
        propKey$201 === propKey ||
        (null == propKey$201 && null == propKey) ||
        setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
}
function isLikelyStaticResource(initiatorType) {
  switch (initiatorType) {
    case "css":
    case "script":
    case "font":
    case "img":
    case "image":
    case "input":
    case "link":
      return !0;
    default:
      return !1;
  }
}
function estimateBandwidth() {
  if ("function" === typeof performance.getEntriesByType) {
    for (
      var count = 0,
        bits = 0,
        resourceEntries = performance.getEntriesByType("resource"),
        i = 0;
      i < resourceEntries.length;
      i++
    ) {
      var entry = resourceEntries[i],
        transferSize = entry.transferSize,
        initiatorType = entry.initiatorType,
        duration = entry.duration;
      if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
        initiatorType = 0;
        duration = entry.responseEnd;
        for (i += 1; i < resourceEntries.length; i++) {
          var overlapEntry = resourceEntries[i],
            overlapStartTime = overlapEntry.startTime;
          if (overlapStartTime > duration) break;
          var overlapTransferSize = overlapEntry.transferSize,
            overlapInitiatorType = overlapEntry.initiatorType;
          overlapTransferSize &&
            isLikelyStaticResource(overlapInitiatorType) &&
            ((overlapEntry = overlapEntry.responseEnd),
            (initiatorType +=
              overlapTransferSize *
              (overlapEntry < duration
                ? 1
                : (duration - overlapStartTime) /
                  (overlapEntry - overlapStartTime))));
        }
        --i;
        bits += (8 * (transferSize + initiatorType)) / (entry.duration / 1e3);
        count++;
        if (10 < count) break;
      }
    }
    if (0 < count) return bits / count / 1e6;
  }
  return navigator.connection &&
    ((count = navigator.connection.downlink), "number" === typeof count)
    ? count
    : 5;
}
var eventsEnabled = null,
  selectionInformation = null;
function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return 9 === rootContainerElement.nodeType
    ? rootContainerElement
    : rootContainerElement.ownerDocument;
}
function getOwnHostContext(namespaceURI) {
  switch (namespaceURI) {
    case "http://www.w3.org/2000/svg":
      return 1;
    case "http://www.w3.org/1998/Math/MathML":
      return 2;
    default:
      return 0;
  }
}
function getChildHostContextProd(parentNamespace, type) {
  if (0 === parentNamespace)
    switch (type) {
      case "svg":
        return 1;
      case "math":
        return 2;
      default:
        return 0;
    }
  return 1 === parentNamespace && "foreignObject" === type
    ? 0
    : parentNamespace;
}
function shouldSetTextContent(type, props) {
  return (
    "textarea" === type ||
    "noscript" === type ||
    "string" === typeof props.children ||
    "number" === typeof props.children ||
    "bigint" === typeof props.children ||
    ("object" === typeof props.dangerouslySetInnerHTML &&
      null !== props.dangerouslySetInnerHTML &&
      null != props.dangerouslySetInnerHTML.__html)
  );
}
var currentPopstateTransitionEvent = null;
function shouldAttemptEagerTransition() {
  var event = window.event;
  if (event && "popstate" === event.type) {
    if (event === currentPopstateTransitionEvent) return !1;
    currentPopstateTransitionEvent = event;
    return !0;
  }
  currentPopstateTransitionEvent = null;
  return !1;
}
var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
  cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
  localPromise = "function" === typeof Promise ? Promise : void 0,
  scheduleMicrotask =
    "function" === typeof queueMicrotask
      ? queueMicrotask
      : "undefined" !== typeof localPromise
        ? function (callback) {
            return localPromise
              .resolve(null)
              .then(callback)
              .catch(handleErrorInNextTick);
          }
        : scheduleTimeout;
function handleErrorInNextTick(error) {
  setTimeout(function () {
    throw error;
  });
}
function isSingletonScope(type) {
  return "head" === type;
}
function clearHydrationBoundary(parentInstance, hydrationInstance) {
  var node = hydrationInstance,
    depth = 0;
  do {
    var nextNode = node.nextSibling;
    parentInstance.removeChild(node);
    if (nextNode && 8 === nextNode.nodeType)
      if (((node = nextNode.data), "/$" === node || "/&" === node)) {
        if (0 === depth) {
          parentInstance.removeChild(nextNode);
          retryIfBlockedOn(hydrationInstance);
          return;
        }
        depth--;
      } else if (
        "$" === node ||
        "$?" === node ||
        "$~" === node ||
        "$!" === node ||
        "&" === node
      )
        depth++;
      else if ("html" === node)
        releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
      else if ("head" === node) {
        node = parentInstance.ownerDocument.head;
        releaseSingletonInstance(node);
        for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
          var nextNode$jscomp$0 = node$jscomp$0.nextSibling,
            nodeName = node$jscomp$0.nodeName;
          node$jscomp$0[internalHoistableMarker] ||
            "SCRIPT" === nodeName ||
            "STYLE" === nodeName ||
            ("LINK" === nodeName &&
              "stylesheet" === node$jscomp$0.rel.toLowerCase()) ||
            node.removeChild(node$jscomp$0);
          node$jscomp$0 = nextNode$jscomp$0;
        }
      } else
        "body" === node &&
          releaseSingletonInstance(parentInstance.ownerDocument.body);
    node = nextNode;
  } while (node);
  retryIfBlockedOn(hydrationInstance);
}
function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
  var node = suspenseInstance;
  suspenseInstance = 0;
  do {
    var nextNode = node.nextSibling;
    1 === node.nodeType
      ? isHidden
        ? ((node._stashedDisplay = node.style.display),
          (node.style.display = "none"))
        : ((node.style.display = node._stashedDisplay || ""),
          "" === node.getAttribute("style") && node.removeAttribute("style"))
      : 3 === node.nodeType &&
        (isHidden
          ? ((node._stashedText = node.nodeValue), (node.nodeValue = ""))
          : (node.nodeValue = node._stashedText || ""));
    if (nextNode && 8 === nextNode.nodeType)
      if (((node = nextNode.data), "/$" === node))
        if (0 === suspenseInstance) break;
        else suspenseInstance--;
      else
        ("$" !== node && "$?" !== node && "$~" !== node && "$!" !== node) ||
          suspenseInstance++;
    node = nextNode;
  } while (node);
}
function clearContainerSparingly(container) {
  var nextNode = container.firstChild;
  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
  for (; nextNode; ) {
    var node = nextNode;
    nextNode = nextNode.nextSibling;
    switch (node.nodeName) {
      case "HTML":
      case "HEAD":
      case "BODY":
        clearContainerSparingly(node);
        detachDeletedInstance(node);
        continue;
      case "SCRIPT":
      case "STYLE":
        continue;
      case "LINK":
        if ("stylesheet" === node.rel.toLowerCase()) continue;
    }
    container.removeChild(node);
  }
}
function canHydrateInstance(instance, type, props, inRootOrSingleton) {
  for (; 1 === instance.nodeType; ) {
    var anyProps = props;
    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
      if (
        !inRootOrSingleton &&
        ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
      )
        break;
    } else if (!inRootOrSingleton)
      if ("input" === type && "hidden" === instance.type) {
        var name = null == anyProps.name ? null : "" + anyProps.name;
        if (
          "hidden" === anyProps.type &&
          instance.getAttribute("name") === name
        )
          return instance;
      } else return instance;
    else if (!instance[internalHoistableMarker])
      switch (type) {
        case "meta":
          if (!instance.hasAttribute("itemprop")) break;
          return instance;
        case "link":
          name = instance.getAttribute("rel");
          if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
            break;
          else if (
            name !== anyProps.rel ||
            instance.getAttribute("href") !==
              (null == anyProps.href || "" === anyProps.href
                ? null
                : anyProps.href) ||
            instance.getAttribute("crossorigin") !==
              (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) ||
            instance.getAttribute("title") !==
              (null == anyProps.title ? null : anyProps.title)
          )
            break;
          return instance;
        case "style":
          if (instance.hasAttribute("data-precedence")) break;
          return instance;
        case "script":
          name = instance.getAttribute("src");
          if (
            (name !== (null == anyProps.src ? null : anyProps.src) ||
              instance.getAttribute("type") !==
                (null == anyProps.type ? null : anyProps.type) ||
              instance.getAttribute("crossorigin") !==
                (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) &&
            name &&
            instance.hasAttribute("async") &&
            !instance.hasAttribute("itemprop")
          )
            break;
          return instance;
        default:
          return instance;
      }
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) break;
  }
  return null;
}
function canHydrateTextInstance(instance, text, inRootOrSingleton) {
  if ("" === text) return null;
  for (; 3 !== instance.nodeType; ) {
    if (
      (1 !== instance.nodeType ||
        "INPUT" !== instance.nodeName ||
        "hidden" !== instance.type) &&
      !inRootOrSingleton
    )
      return null;
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) return null;
  }
  return instance;
}
function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
  for (; 8 !== instance.nodeType; ) {
    if (
      (1 !== instance.nodeType ||
        "INPUT" !== instance.nodeName ||
        "hidden" !== instance.type) &&
      !inRootOrSingleton
    )
      return null;
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) return null;
  }
  return instance;
}
function isSuspenseInstancePending(instance) {
  return "$?" === instance.data || "$~" === instance.data;
}
function isSuspenseInstanceFallback(instance) {
  return (
    "$!" === instance.data ||
    ("$?" === instance.data && "loading" !== instance.ownerDocument.readyState)
  );
}
function registerSuspenseInstanceRetry(instance, callback) {
  var ownerDocument = instance.ownerDocument;
  if ("$~" === instance.data) instance._reactRetry = callback;
  else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
    callback();
  else {
    var listener = function () {
      callback();
      ownerDocument.removeEventListener("DOMContentLoaded", listener);
    };
    ownerDocument.addEventListener("DOMContentLoaded", listener);
    instance._reactRetry = listener;
  }
}
function getNextHydratable(node) {
  for (; null != node; node = node.nextSibling) {
    var nodeType = node.nodeType;
    if (1 === nodeType || 3 === nodeType) break;
    if (8 === nodeType) {
      nodeType = node.data;
      if (
        "$" === nodeType ||
        "$!" === nodeType ||
        "$?" === nodeType ||
        "$~" === nodeType ||
        "&" === nodeType ||
        "F!" === nodeType ||
        "F" === nodeType
      )
        break;
      if ("/$" === nodeType || "/&" === nodeType) return null;
    }
  }
  return node;
}
var previousHydratableOnEnteringScopedSingleton = null;
function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
  hydrationInstance = hydrationInstance.nextSibling;
  for (var depth = 0; hydrationInstance; ) {
    if (8 === hydrationInstance.nodeType) {
      var data = hydrationInstance.data;
      if ("/$" === data || "/&" === data) {
        if (0 === depth)
          return getNextHydratable(hydrationInstance.nextSibling);
        depth--;
      } else
        ("$" !== data &&
          "$!" !== data &&
          "$?" !== data &&
          "$~" !== data &&
          "&" !== data) ||
          depth++;
    }
    hydrationInstance = hydrationInstance.nextSibling;
  }
  return null;
}
function getParentHydrationBoundary(targetInstance) {
  targetInstance = targetInstance.previousSibling;
  for (var depth = 0; targetInstance; ) {
    if (8 === targetInstance.nodeType) {
      var data = targetInstance.data;
      if (
        "$" === data ||
        "$!" === data ||
        "$?" === data ||
        "$~" === data ||
        "&" === data
      ) {
        if (0 === depth) return targetInstance;
        depth--;
      } else ("/$" !== data && "/&" !== data) || depth++;
    }
    targetInstance = targetInstance.previousSibling;
  }
  return null;
}
function resolveSingletonInstance(type, props, rootContainerInstance) {
  props = getOwnerDocumentFromRootContainer(rootContainerInstance);
  switch (type) {
    case "html":
      type = props.documentElement;
      if (!type) throw Error(formatProdErrorMessage(452));
      return type;
    case "head":
      type = props.head;
      if (!type) throw Error(formatProdErrorMessage(453));
      return type;
    case "body":
      type = props.body;
      if (!type) throw Error(formatProdErrorMessage(454));
      return type;
    default:
      throw Error(formatProdErrorMessage(451));
  }
}
function releaseSingletonInstance(instance) {
  for (var attributes = instance.attributes; attributes.length; )
    instance.removeAttributeNode(attributes[0]);
  detachDeletedInstance(instance);
}
var preloadPropsMap = new Map(),
  preconnectsSet = new Set();
function getHoistableRoot(container) {
  return "function" === typeof container.getRootNode
    ? container.getRootNode()
    : 9 === container.nodeType
      ? container
      : container.ownerDocument;
}
var previousDispatcher = ReactDOMSharedInternals.d;
ReactDOMSharedInternals.d = {
  f: flushSyncWork,
  r: requestFormReset,
  D: prefetchDNS,
  C: preconnect,
  L: preload,
  m: preloadModule,
  X: preinitScript,
  S: preinitStyle,
  M: preinitModuleScript
};
function flushSyncWork() {
  var previousWasRendering = previousDispatcher.f(),
    wasRendering = flushSyncWork$1();
  return previousWasRendering || wasRendering;
}
function requestFormReset(form) {
  var formInst = getInstanceFromNode(form);
  null !== formInst && 5 === formInst.tag && "form" === formInst.type
    ? requestFormReset$1(formInst)
    : previousDispatcher.r(form);
}
var globalDocument = "undefined" === typeof document ? null : document;
function preconnectAs(rel, href, crossOrigin) {
  var ownerDocument = globalDocument;
  if (ownerDocument && "string" === typeof href && href) {
    var limitedEscapedHref =
      escapeSelectorAttributeValueInsideDoubleQuotes(href);
    limitedEscapedHref =
      'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
    "string" === typeof crossOrigin &&
      (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
    preconnectsSet.has(limitedEscapedHref) ||
      (preconnectsSet.add(limitedEscapedHref),
      (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
      null === ownerDocument.querySelector(limitedEscapedHref) &&
        ((href = ownerDocument.createElement("link")),
        setInitialProperties(href, "link", rel),
        markNodeAsHoistable(href),
        ownerDocument.head.appendChild(href)));
  }
}
function prefetchDNS(href) {
  previousDispatcher.D(href);
  preconnectAs("dns-prefetch", href, null);
}
function preconnect(href, crossOrigin) {
  previousDispatcher.C(href, crossOrigin);
  preconnectAs("preconnect", href, crossOrigin);
}
function preload(href, as, options) {
  previousDispatcher.L(href, as, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href && as) {
    var preloadSelector =
      'link[rel="preload"][as="' +
      escapeSelectorAttributeValueInsideDoubleQuotes(as) +
      '"]';
    "image" === as
      ? options && options.imageSrcSet
        ? ((preloadSelector +=
            '[imagesrcset="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(
              options.imageSrcSet
            ) +
            '"]'),
          "string" === typeof options.imageSizes &&
            (preloadSelector +=
              '[imagesizes="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSizes
              ) +
              '"]'))
        : (preloadSelector +=
            '[href="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(href) +
            '"]')
      : (preloadSelector +=
          '[href="' +
          escapeSelectorAttributeValueInsideDoubleQuotes(href) +
          '"]');
    var key = preloadSelector;
    switch (as) {
      case "style":
        key = getStyleKey(href);
        break;
      case "script":
        key = getScriptKey(href);
    }
    preloadPropsMap.has(key) ||
      ((href = assign(
        {
          rel: "preload",
          href:
            "image" === as && options && options.imageSrcSet ? void 0 : href,
          as: as
        },
        options
      )),
      preloadPropsMap.set(key, href),
      null !== ownerDocument.querySelector(preloadSelector) ||
        ("style" === as &&
          ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||
        ("script" === as &&
          ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
        ((as = ownerDocument.createElement("link")),
        setInitialProperties(as, "link", href),
        markNodeAsHoistable(as),
        ownerDocument.head.appendChild(as)));
  }
}
function preloadModule(href, options) {
  previousDispatcher.m(href, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var as = options && "string" === typeof options.as ? options.as : "script",
      preloadSelector =
        'link[rel="modulepreload"][as="' +
        escapeSelectorAttributeValueInsideDoubleQuotes(as) +
        '"][href="' +
        escapeSelectorAttributeValueInsideDoubleQuotes(href) +
        '"]',
      key = preloadSelector;
    switch (as) {
      case "audioworklet":
      case "paintworklet":
      case "serviceworker":
      case "sharedworker":
      case "worker":
      case "script":
        key = getScriptKey(href);
    }
    if (
      !preloadPropsMap.has(key) &&
      ((href = assign({ rel: "modulepreload", href: href }, options)),
      preloadPropsMap.set(key, href),
      null === ownerDocument.querySelector(preloadSelector))
    ) {
      switch (as) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
            return;
      }
      as = ownerDocument.createElement("link");
      setInitialProperties(as, "link", href);
      markNodeAsHoistable(as);
      ownerDocument.head.appendChild(as);
    }
  }
}
function preinitStyle(href, precedence, options) {
  previousDispatcher.S(href, precedence, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
      key = getStyleKey(href);
    precedence = precedence || "default";
    var resource = styles.get(key);
    if (!resource) {
      var state = { loading: 0, preload: null };
      if (
        (resource = ownerDocument.querySelector(
          getStylesheetSelectorFromKey(key)
        ))
      )
        state.loading = 5;
      else {
        href = assign(
          { rel: "stylesheet", href: href, "data-precedence": precedence },
          options
        );
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForStylesheet(href, options);
        var link = (resource = ownerDocument.createElement("link"));
        markNodeAsHoistable(link);
        setInitialProperties(link, "link", href);
        link._p = new Promise(function (resolve, reject) {
          link.onload = resolve;
          link.onerror = reject;
        });
        link.addEventListener("load", function () {
          state.loading |= 1;
        });
        link.addEventListener("error", function () {
          state.loading |= 2;
        });
        state.loading |= 4;
        insertStylesheet(resource, precedence, ownerDocument);
      }
      resource = {
        type: "stylesheet",
        instance: resource,
        count: 1,
        state: state
      };
      styles.set(key, resource);
    }
  }
}
function preinitScript(src, options) {
  previousDispatcher.X(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
      key = getScriptKey(src),
      resource = scripts.get(key);
    resource ||
      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
      resource ||
        ((src = assign({ src: src, async: !0 }, options)),
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForScript(src, options),
        (resource = ownerDocument.createElement("script")),
        markNodeAsHoistable(resource),
        setInitialProperties(resource, "link", src),
        ownerDocument.head.appendChild(resource)),
      (resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }),
      scripts.set(key, resource));
  }
}
function preinitModuleScript(src, options) {
  previousDispatcher.M(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
      key = getScriptKey(src),
      resource = scripts.get(key);
    resource ||
      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
      resource ||
        ((src = assign({ src: src, async: !0, type: "module" }, options)),
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForScript(src, options),
        (resource = ownerDocument.createElement("script")),
        markNodeAsHoistable(resource),
        setInitialProperties(resource, "link", src),
        ownerDocument.head.appendChild(resource)),
      (resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }),
      scripts.set(key, resource));
  }
}
function getResource(type, currentProps, pendingProps, currentResource) {
  var JSCompiler_inline_result = (JSCompiler_inline_result =
    rootInstanceStackCursor.current)
    ? getHoistableRoot(JSCompiler_inline_result)
    : null;
  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
  switch (type) {
    case "meta":
    case "title":
      return null;
    case "style":
      return "string" === typeof pendingProps.precedence &&
        "string" === typeof pendingProps.href
        ? ((currentProps = getStyleKey(pendingProps.href)),
          (pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles),
          (currentResource = pendingProps.get(currentProps)),
          currentResource ||
            ((currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }),
            pendingProps.set(currentProps, currentResource)),
          currentResource)
        : { type: "void", instance: null, count: 0, state: null };
    case "link":
      if (
        "stylesheet" === pendingProps.rel &&
        "string" === typeof pendingProps.href &&
        "string" === typeof pendingProps.precedence
      ) {
        type = getStyleKey(pendingProps.href);
        var styles$243 = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles,
          resource$244 = styles$243.get(type);
        resource$244 ||
          ((JSCompiler_inline_result =
            JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),
          (resource$244 = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }),
          styles$243.set(type, resource$244),
          (styles$243 = JSCompiler_inline_result.querySelector(
            getStylesheetSelectorFromKey(type)
          )) &&
            !styles$243._p &&
            ((resource$244.instance = styles$243),
            (resource$244.state.loading = 5)),
          preloadPropsMap.has(type) ||
            ((pendingProps = {
              rel: "preload",
              as: "style",
              href: pendingProps.href,
              crossOrigin: pendingProps.crossOrigin,
              integrity: pendingProps.integrity,
              media: pendingProps.media,
              hrefLang: pendingProps.hrefLang,
              referrerPolicy: pendingProps.referrerPolicy
            }),
            preloadPropsMap.set(type, pendingProps),
            styles$243 ||
              preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$244.state
              )));
        if (currentProps && null === currentResource)
          throw Error(formatProdErrorMessage(528, ""));
        return resource$244;
      }
      if (currentProps && null !== currentResource)
        throw Error(formatProdErrorMessage(529, ""));
      return null;
    case "script":
      return (
        (currentProps = pendingProps.async),
        (pendingProps = pendingProps.src),
        "string" === typeof pendingProps &&
        currentProps &&
        "function" !== typeof currentProps &&
        "symbol" !== typeof currentProps
          ? ((currentProps = getScriptKey(pendingProps)),
            (pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts),
            (currentResource = pendingProps.get(currentProps)),
            currentResource ||
              ((currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }),
              pendingProps.set(currentProps, currentResource)),
            currentResource)
          : { type: "void", instance: null, count: 0, state: null }
      );
    default:
      throw Error(formatProdErrorMessage(444, type));
  }
}
function getStyleKey(href) {
  return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
}
function getStylesheetSelectorFromKey(key) {
  return 'link[rel="stylesheet"][' + key + "]";
}
function stylesheetPropsFromRawProps(rawProps) {
  return assign({}, rawProps, {
    "data-precedence": rawProps.precedence,
    precedence: null
  });
}
function preloadStylesheet(ownerDocument, key, preloadProps, state) {
  ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]")
    ? (state.loading = 1)
    : ((key = ownerDocument.createElement("link")),
      (state.preload = key),
      key.addEventListener("load", function () {
        return (state.loading |= 1);
      }),
      key.addEventListener("error", function () {
        return (state.loading |= 2);
      }),
      setInitialProperties(key, "link", preloadProps),
      markNodeAsHoistable(key),
      ownerDocument.head.appendChild(key));
}
function getScriptKey(src) {
  return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
}
function getScriptSelectorFromKey(key) {
  return "script[async]" + key;
}
function acquireResource(hoistableRoot, resource, props) {
  resource.count++;
  if (null === resource.instance)
    switch (resource.type) {
      case "style":
        var instance = hoistableRoot.querySelector(
          'style[data-href~="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
            '"]'
        );
        if (instance)
          return (
            (resource.instance = instance),
            markNodeAsHoistable(instance),
            instance
          );
        var styleProps = assign({}, props, {
          "data-href": props.href,
          "data-precedence": props.precedence,
          href: null,
          precedence: null
        });
        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
          "style"
        );
        markNodeAsHoistable(instance);
        setInitialProperties(instance, "style", styleProps);
        insertStylesheet(instance, props.precedence, hoistableRoot);
        return (resource.instance = instance);
      case "stylesheet":
        styleProps = getStyleKey(props.href);
        var instance$249 = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(styleProps)
        );
        if (instance$249)
          return (
            (resource.state.loading |= 4),
            (resource.instance = instance$249),
            markNodeAsHoistable(instance$249),
            instance$249
          );
        instance = stylesheetPropsFromRawProps(props);
        (styleProps = preloadPropsMap.get(styleProps)) &&
          adoptPreloadPropsForStylesheet(instance, styleProps);
        instance$249 = (
          hoistableRoot.ownerDocument || hoistableRoot
        ).createElement("link");
        markNodeAsHoistable(instance$249);
        var linkInstance = instance$249;
        linkInstance._p = new Promise(function (resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(instance$249, "link", instance);
        resource.state.loading |= 4;
        insertStylesheet(instance$249, props.precedence, hoistableRoot);
        return (resource.instance = instance$249);
      case "script":
        instance$249 = getScriptKey(props.src);
        if (
          (styleProps = hoistableRoot.querySelector(
            getScriptSelectorFromKey(instance$249)
          ))
        )
          return (
            (resource.instance = styleProps),
            markNodeAsHoistable(styleProps),
            styleProps
          );
        instance = props;
        if ((styleProps = preloadPropsMap.get(instance$249)))
          (instance = assign({}, props)),
            adoptPreloadPropsForScript(instance, styleProps);
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        styleProps = hoistableRoot.createElement("script");
        markNodeAsHoistable(styleProps);
        setInitialProperties(styleProps, "link", instance);
        hoistableRoot.head.appendChild(styleProps);
        return (resource.instance = styleProps);
      case "void":
        return null;
      default:
        throw Error(formatProdErrorMessage(443, resource.type));
    }
  else
    "stylesheet" === resource.type &&
      0 === (resource.state.loading & 4) &&
      ((instance = resource.instance),
      (resource.state.loading |= 4),
      insertStylesheet(instance, props.precedence, hoistableRoot));
  return resource.instance;
}
function insertStylesheet(instance, precedence, root) {
  for (
    var nodes = root.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ),
      last = nodes.length ? nodes[nodes.length - 1] : null,
      prior = last,
      i = 0;
    i < nodes.length;
    i++
  ) {
    var node = nodes[i];
    if (node.dataset.precedence === precedence) prior = node;
    else if (prior !== last) break;
  }
  prior
    ? prior.parentNode.insertBefore(instance, prior.nextSibling)
    : ((precedence = 9 === root.nodeType ? root.head : root),
      precedence.insertBefore(instance, precedence.firstChild));
}
function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
  null == stylesheetProps.crossOrigin &&
    (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
  null == stylesheetProps.referrerPolicy &&
    (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
}
function adoptPreloadPropsForScript(scriptProps, preloadProps) {
  null == scriptProps.crossOrigin &&
    (scriptProps.crossOrigin = preloadProps.crossOrigin);
  null == scriptProps.referrerPolicy &&
    (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
  null == scriptProps.integrity &&
    (scriptProps.integrity = preloadProps.integrity);
}
var tagCaches = null;
function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
  if (null === tagCaches) {
    var cache = new Map();
    var caches = (tagCaches = new Map());
    caches.set(ownerDocument, cache);
  } else
    (caches = tagCaches),
      (cache = caches.get(ownerDocument)),
      cache || ((cache = new Map()), caches.set(ownerDocument, cache));
  if (cache.has(type)) return cache;
  cache.set(type, null);
  ownerDocument = ownerDocument.getElementsByTagName(type);
  for (caches = 0; caches < ownerDocument.length; caches++) {
    var node = ownerDocument[caches];
    if (
      !(
        node[internalHoistableMarker] ||
        node[internalInstanceKey] ||
        ("link" === type && "stylesheet" === node.getAttribute("rel"))
      ) &&
      "http://www.w3.org/2000/svg" !== node.namespaceURI
    ) {
      var nodeKey = node.getAttribute(keyAttribute) || "";
      nodeKey = type + nodeKey;
      var existing = cache.get(nodeKey);
      existing ? existing.push(node) : cache.set(nodeKey, [node]);
    }
  }
  return cache;
}
function mountHoistable(hoistableRoot, type, instance) {
  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
  hoistableRoot.head.insertBefore(
    instance,
    "title" === type ? hoistableRoot.querySelector("head > title") : null
  );
}
function isHostHoistableType(type, props, hostContext) {
  if (1 === hostContext || null != props.itemProp) return !1;
  switch (type) {
    case "meta":
    case "title":
      return !0;
    case "style":
      if (
        "string" !== typeof props.precedence ||
        "string" !== typeof props.href ||
        "" === props.href
      )
        break;
      return !0;
    case "link":
      if (
        "string" !== typeof props.rel ||
        "string" !== typeof props.href ||
        "" === props.href ||
        props.onLoad ||
        props.onError
      )
        break;
      switch (props.rel) {
        case "stylesheet":
          return (
            (type = props.disabled),
            "string" === typeof props.precedence && null == type
          );
        default:
          return !0;
      }
    case "script":
      if (
        props.async &&
        "function" !== typeof props.async &&
        "symbol" !== typeof props.async &&
        !props.onLoad &&
        !props.onError &&
        props.src &&
        "string" === typeof props.src
      )
        return !0;
  }
  return !1;
}
function preloadResource(resource) {
  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3)
    ? !1
    : !0;
}
function suspendResource(state, hoistableRoot, resource, props) {
  if (
    "stylesheet" === resource.type &&
    ("string" !== typeof props.media ||
      !1 !== matchMedia(props.media).matches) &&
    0 === (resource.state.loading & 4)
  ) {
    if (null === resource.instance) {
      var key = getStyleKey(props.href),
        instance = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(key)
        );
      if (instance) {
        hoistableRoot = instance._p;
        null !== hoistableRoot &&
          "object" === typeof hoistableRoot &&
          "function" === typeof hoistableRoot.then &&
          (state.count++,
          (state = onUnsuspend.bind(state)),
          hoistableRoot.then(state, state));
        resource.state.loading |= 4;
        resource.instance = instance;
        markNodeAsHoistable(instance);
        return;
      }
      instance = hoistableRoot.ownerDocument || hoistableRoot;
      props = stylesheetPropsFromRawProps(props);
      (key = preloadPropsMap.get(key)) &&
        adoptPreloadPropsForStylesheet(props, key);
      instance = instance.createElement("link");
      markNodeAsHoistable(instance);
      var linkInstance = instance;
      linkInstance._p = new Promise(function (resolve, reject) {
        linkInstance.onload = resolve;
        linkInstance.onerror = reject;
      });
      setInitialProperties(instance, "link", props);
      resource.instance = instance;
    }
    null === state.stylesheets && (state.stylesheets = new Map());
    state.stylesheets.set(resource, hoistableRoot);
    (hoistableRoot = resource.state.preload) &&
      0 === (resource.state.loading & 3) &&
      (state.count++,
      (resource = onUnsuspend.bind(state)),
      hoistableRoot.addEventListener("load", resource),
      hoistableRoot.addEventListener("error", resource));
  }
}
var estimatedBytesWithinLimit = 0;
function waitForCommitToBeReady(state, timeoutOffset) {
  state.stylesheets &&
    0 === state.count &&
    insertSuspendedStylesheets(state, state.stylesheets);
  return 0 < state.count || 0 < state.imgCount
    ? function (commit) {
        var stylesheetTimer = setTimeout(function () {
          state.stylesheets &&
            insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, 6e4 + timeoutOffset);
        0 < state.imgBytes &&
          0 === estimatedBytesWithinLimit &&
          (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
        var imgTimer = setTimeout(
          function () {
            state.waitingForImages = !1;
            if (
              0 === state.count &&
              (state.stylesheets &&
                insertSuspendedStylesheets(state, state.stylesheets),
              state.unsuspend)
            ) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          },
          (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) +
            timeoutOffset
        );
        state.unsuspend = commit;
        return function () {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
          clearTimeout(imgTimer);
        };
      }
    : null;
}
function onUnsuspend() {
  this.count--;
  if (0 === this.count && (0 === this.imgCount || !this.waitingForImages))
    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
    else if (this.unsuspend) {
      var unsuspend = this.unsuspend;
      this.unsuspend = null;
      unsuspend();
    }
}
var precedencesByRoot = null;
function insertSuspendedStylesheets(state, resources) {
  state.stylesheets = null;
  null !== state.unsuspend &&
    (state.count++,
    (precedencesByRoot = new Map()),
    resources.forEach(insertStylesheetIntoRoot, state),
    (precedencesByRoot = null),
    onUnsuspend.call(state));
}
function insertStylesheetIntoRoot(root, resource) {
  if (!(resource.state.loading & 4)) {
    var precedences = precedencesByRoot.get(root);
    if (precedences) var last = precedences.get(null);
    else {
      precedences = new Map();
      precedencesByRoot.set(root, precedences);
      for (
        var nodes = root.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ),
          i = 0;
        i < nodes.length;
        i++
      ) {
        var node = nodes[i];
        if (
          "LINK" === node.nodeName ||
          "not all" !== node.getAttribute("media")
        )
          precedences.set(node.dataset.precedence, node), (last = node);
      }
      last && precedences.set(null, last);
    }
    nodes = resource.instance;
    node = nodes.getAttribute("data-precedence");
    i = precedences.get(node) || last;
    i === last && precedences.set(null, nodes);
    precedences.set(node, nodes);
    this.count++;
    last = onUnsuspend.bind(this);
    nodes.addEventListener("load", last);
    nodes.addEventListener("error", last);
    i
      ? i.parentNode.insertBefore(nodes, i.nextSibling)
      : ((root = 9 === root.nodeType ? root.head : root),
        root.insertBefore(nodes, root.firstChild));
    resource.state.loading |= 4;
  }
}
var HostTransitionContext = {
  $$typeof: REACT_CONTEXT_TYPE,
  Provider: null,
  Consumer: null,
  _currentValue: sharedNotPendingObject,
  _currentValue2: sharedNotPendingObject,
  _threadCount: 0
};
function FiberRootNode(
  containerInfo,
  tag,
  hydrate,
  identifierPrefix,
  onUncaughtError,
  onCaughtError,
  onRecoverableError,
  onDefaultTransitionIndicator,
  formState
) {
  this.tag = 1;
  this.containerInfo = containerInfo;
  this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode =
    this.next =
    this.pendingContext =
    this.context =
    this.cancelPendingCommit =
      null;
  this.callbackPriority = 0;
  this.expirationTimes = createLaneMap(-1);
  this.entangledLanes =
    this.shellSuspendCounter =
    this.errorRecoveryDisabledLanes =
    this.expiredLanes =
    this.warmLanes =
    this.pingedLanes =
    this.suspendedLanes =
    this.pendingLanes =
      0;
  this.entanglements = createLaneMap(0);
  this.hiddenUpdates = createLaneMap(null);
  this.identifierPrefix = identifierPrefix;
  this.onUncaughtError = onUncaughtError;
  this.onCaughtError = onCaughtError;
  this.onRecoverableError = onRecoverableError;
  this.pooledCache = null;
  this.pooledCacheLanes = 0;
  this.formState = formState;
  this.incompleteTransitions = new Map();
}
function createFiberRoot(
  containerInfo,
  tag,
  hydrate,
  initialChildren,
  hydrationCallbacks,
  isStrictMode,
  identifierPrefix,
  formState,
  onUncaughtError,
  onCaughtError,
  onRecoverableError,
  onDefaultTransitionIndicator
) {
  containerInfo = new FiberRootNode(
    containerInfo,
    tag,
    hydrate,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    onDefaultTransitionIndicator,
    formState
  );
  tag = 1;
  !0 === isStrictMode && (tag |= 24);
  isStrictMode = createFiberImplClass(3, null, null, tag);
  containerInfo.current = isStrictMode;
  isStrictMode.stateNode = containerInfo;
  tag = createCache();
  tag.refCount++;
  containerInfo.pooledCache = tag;
  tag.refCount++;
  isStrictMode.memoizedState = {
    element: initialChildren,
    isDehydrated: hydrate,
    cache: tag
  };
  initializeUpdateQueue(isStrictMode);
  return containerInfo;
}
function getContextForSubtree(parentComponent) {
  if (!parentComponent) return emptyContextObject;
  parentComponent = emptyContextObject;
  return parentComponent;
}
function updateContainerImpl(
  rootFiber,
  lane,
  element,
  container,
  parentComponent,
  callback
) {
  parentComponent = getContextForSubtree(parentComponent);
  null === container.context
    ? (container.context = parentComponent)
    : (container.pendingContext = parentComponent);
  container = createUpdate(lane);
  container.payload = { element: element };
  callback = void 0 === callback ? null : callback;
  null !== callback && (container.callback = callback);
  element = enqueueUpdate(rootFiber, container, lane);
  null !== element &&
    (scheduleUpdateOnFiber(element, rootFiber, lane),
    entangleTransitions(element, rootFiber, lane));
}
function markRetryLaneImpl(fiber, retryLane) {
  fiber = fiber.memoizedState;
  if (null !== fiber && null !== fiber.dehydrated) {
    var a = fiber.retryLane;
    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
  }
}
function markRetryLaneIfNotHydrated(fiber, retryLane) {
  markRetryLaneImpl(fiber, retryLane);
  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
}
function attemptContinuousHydration(fiber) {
  if (13 === fiber.tag || 31 === fiber.tag) {
    var root = enqueueConcurrentRenderForLane(fiber, 67108864);
    null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
    markRetryLaneIfNotHydrated(fiber, 67108864);
  }
}
function attemptHydrationAtCurrentPriority(fiber) {
  if (13 === fiber.tag || 31 === fiber.tag) {
    var lane = requestUpdateLane();
    lane = getBumpedLaneForHydrationByLane(lane);
    var root = enqueueConcurrentRenderForLane(fiber, lane);
    null !== root && scheduleUpdateOnFiber(root, fiber, lane);
    markRetryLaneIfNotHydrated(fiber, lane);
  }
}
var _enabled = !0;
function dispatchDiscreteEvent(
  domEventName,
  eventSystemFlags,
  container,
  nativeEvent
) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    (ReactDOMSharedInternals.p = 2),
      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition);
  }
}
function dispatchContinuousEvent(
  domEventName,
  eventSystemFlags,
  container,
  nativeEvent
) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    (ReactDOMSharedInternals.p = 8),
      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition);
  }
}
function dispatchEvent(
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  if (_enabled) {
    var blockedOn = findInstanceBlockingEvent(nativeEvent);
    if (null === blockedOn)
      dispatchEventForPluginEventSystem(
        domEventName,
        eventSystemFlags,
        nativeEvent,
        return_targetInst,
        targetContainer
      ),
        clearIfContinuousEvent(domEventName, nativeEvent);
    else if (
      queueIfContinuousEvent(
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      )
    )
      nativeEvent.stopPropagation();
    else if (
      (clearIfContinuousEvent(domEventName, nativeEvent),
      eventSystemFlags & 4 &&
        -1 < discreteReplayableEvents.indexOf(domEventName))
    ) {
      for (; null !== blockedOn; ) {
        var fiber = getInstanceFromNode(blockedOn);
        if (null !== fiber)
          switch (fiber.tag) {
            case 3:
              fiber = fiber.stateNode;
              if (fiber.current.memoizedState.isDehydrated) {
                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                if (0 !== lanes) {
                  var root = fiber;
                  root.pendingLanes |= 2;
                  for (root.entangledLanes |= 2; lanes; ) {
                    var lane = 1 << (31 - clz32(lanes));
                    root.entanglements[1] |= lane;
                    lanes &= ~lane;
                  }
                  ensureRootIsScheduled(fiber);
                  0 === (executionContext & 6) &&
                    ((workInProgressRootRenderTargetTime = now() + 500),
                    flushSyncWorkAcrossRoots_impl(0, !1));
                }
              }
              break;
            case 31:
            case 13:
              (root = enqueueConcurrentRenderForLane(fiber, 2)),
                null !== root && scheduleUpdateOnFiber(root, fiber, 2),
                flushSyncWork$1(),
                markRetryLaneIfNotHydrated(fiber, 2);
          }
        fiber = findInstanceBlockingEvent(nativeEvent);
        null === fiber &&
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          );
        if (fiber === blockedOn) break;
        blockedOn = fiber;
      }
      null !== blockedOn && nativeEvent.stopPropagation();
    } else
      dispatchEventForPluginEventSystem(
        domEventName,
        eventSystemFlags,
        nativeEvent,
        null,
        targetContainer
      );
  }
}
function findInstanceBlockingEvent(nativeEvent) {
  nativeEvent = getEventTarget(nativeEvent);
  return findInstanceBlockingTarget(nativeEvent);
}
var return_targetInst = null;
function findInstanceBlockingTarget(targetNode) {
  return_targetInst = null;
  targetNode = getClosestInstanceFromNode(targetNode);
  if (null !== targetNode) {
    var nearestMounted = getNearestMountedFiber(targetNode);
    if (null === nearestMounted) targetNode = null;
    else {
      var tag = nearestMounted.tag;
      if (13 === tag) {
        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
        if (null !== targetNode) return targetNode;
        targetNode = null;
      } else if (31 === tag) {
        targetNode = getActivityInstanceFromFiber(nearestMounted);
        if (null !== targetNode) return targetNode;
        targetNode = null;
      } else if (3 === tag) {
        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
          return 3 === nearestMounted.tag
            ? nearestMounted.stateNode.containerInfo
            : null;
        targetNode = null;
      } else nearestMounted !== targetNode && (targetNode = null);
    }
  }
  return_targetInst = targetNode;
  return null;
}
function getEventPriority(domEventName) {
  switch (domEventName) {
    case "beforetoggle":
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "toggle":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 2;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 8;
    case "message":
      switch (getCurrentPriorityLevel()) {
        case ImmediatePriority:
          return 2;
        case UserBlockingPriority:
          return 8;
        case NormalPriority$1:
        case LowPriority:
          return 32;
        case IdlePriority:
          return 268435456;
        default:
          return 32;
      }
    default:
      return 32;
  }
}
var hasScheduledReplayAttempt = !1,
  queuedFocus = null,
  queuedDrag = null,
  queuedMouse = null,
  queuedPointers = new Map(),
  queuedPointerCaptures = new Map(),
  queuedExplicitHydrationTargets = [],
  discreteReplayableEvents =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
function clearIfContinuousEvent(domEventName, nativeEvent) {
  switch (domEventName) {
    case "focusin":
    case "focusout":
      queuedFocus = null;
      break;
    case "dragenter":
    case "dragleave":
      queuedDrag = null;
      break;
    case "mouseover":
    case "mouseout":
      queuedMouse = null;
      break;
    case "pointerover":
    case "pointerout":
      queuedPointers.delete(nativeEvent.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      queuedPointerCaptures.delete(nativeEvent.pointerId);
  }
}
function accumulateOrCreateContinuousQueuedReplayableEvent(
  existingQueuedEvent,
  blockedOn,
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  if (
    null === existingQueuedEvent ||
    existingQueuedEvent.nativeEvent !== nativeEvent
  )
    return (
      (existingQueuedEvent = {
        blockedOn: blockedOn,
        domEventName: domEventName,
        eventSystemFlags: eventSystemFlags,
        nativeEvent: nativeEvent,
        targetContainers: [targetContainer]
      }),
      null !== blockedOn &&
        ((blockedOn = getInstanceFromNode(blockedOn)),
        null !== blockedOn && attemptContinuousHydration(blockedOn)),
      existingQueuedEvent
    );
  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
  blockedOn = existingQueuedEvent.targetContainers;
  null !== targetContainer &&
    -1 === blockedOn.indexOf(targetContainer) &&
    blockedOn.push(targetContainer);
  return existingQueuedEvent;
}
function queueIfContinuousEvent(
  blockedOn,
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  switch (domEventName) {
    case "focusin":
      return (
        (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedFocus,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "dragenter":
      return (
        (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedDrag,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "mouseover":
      return (
        (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedMouse,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "pointerover":
      var pointerId = nativeEvent.pointerId;
      queuedPointers.set(
        pointerId,
        accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedPointers.get(pointerId) || null,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )
      );
      return !0;
    case "gotpointercapture":
      return (
        (pointerId = nativeEvent.pointerId),
        queuedPointerCaptures.set(
          pointerId,
          accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedPointerCaptures.get(pointerId) || null,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        ),
        !0
      );
  }
  return !1;
}
function attemptExplicitHydrationTarget(queuedTarget) {
  var targetInst = getClosestInstanceFromNode(queuedTarget.target);
  if (null !== targetInst) {
    var nearestMounted = getNearestMountedFiber(targetInst);
    if (null !== nearestMounted)
      if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
        if (
          ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
          null !== targetInst)
        ) {
          queuedTarget.blockedOn = targetInst;
          runWithPriority(queuedTarget.priority, function () {
            attemptHydrationAtCurrentPriority(nearestMounted);
          });
          return;
        }
      } else if (31 === targetInst) {
        if (
          ((targetInst = getActivityInstanceFromFiber(nearestMounted)),
          null !== targetInst)
        ) {
          queuedTarget.blockedOn = targetInst;
          runWithPriority(queuedTarget.priority, function () {
            attemptHydrationAtCurrentPriority(nearestMounted);
          });
          return;
        }
      } else if (
        3 === targetInst &&
        nearestMounted.stateNode.current.memoizedState.isDehydrated
      ) {
        queuedTarget.blockedOn =
          3 === nearestMounted.tag
            ? nearestMounted.stateNode.containerInfo
            : null;
        return;
      }
  }
  queuedTarget.blockedOn = null;
}
function attemptReplayContinuousQueuedEvent(queuedEvent) {
  if (null !== queuedEvent.blockedOn) return !1;
  for (
    var targetContainers = queuedEvent.targetContainers;
    0 < targetContainers.length;

  ) {
    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
    if (null === nextBlockedOn) {
      nextBlockedOn = queuedEvent.nativeEvent;
      var nativeEventClone = new nextBlockedOn.constructor(
        nextBlockedOn.type,
        nextBlockedOn
      );
      currentReplayingEvent = nativeEventClone;
      nextBlockedOn.target.dispatchEvent(nativeEventClone);
      currentReplayingEvent = null;
    } else
      return (
        (targetContainers = getInstanceFromNode(nextBlockedOn)),
        null !== targetContainers &&
          attemptContinuousHydration(targetContainers),
        (queuedEvent.blockedOn = nextBlockedOn),
        !1
      );
    targetContainers.shift();
  }
  return !0;
}
function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
}
function replayUnblockedEvents() {
  hasScheduledReplayAttempt = !1;
  null !== queuedFocus &&
    attemptReplayContinuousQueuedEvent(queuedFocus) &&
    (queuedFocus = null);
  null !== queuedDrag &&
    attemptReplayContinuousQueuedEvent(queuedDrag) &&
    (queuedDrag = null);
  null !== queuedMouse &&
    attemptReplayContinuousQueuedEvent(queuedMouse) &&
    (queuedMouse = null);
  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
}
function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
  queuedEvent.blockedOn === unblocked &&
    ((queuedEvent.blockedOn = null),
    hasScheduledReplayAttempt ||
      ((hasScheduledReplayAttempt = !0),
      Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        replayUnblockedEvents
      )));
}
var lastScheduledReplayQueue = null;
function scheduleReplayQueueIfNeeded(formReplayingQueue) {
  lastScheduledReplayQueue !== formReplayingQueue &&
    ((lastScheduledReplayQueue = formReplayingQueue),
    Scheduler.unstable_scheduleCallback(
      Scheduler.unstable_NormalPriority,
      function () {
        lastScheduledReplayQueue === formReplayingQueue &&
          (lastScheduledReplayQueue = null);
        for (var i = 0; i < formReplayingQueue.length; i += 3) {
          var form = formReplayingQueue[i],
            submitterOrAction = formReplayingQueue[i + 1],
            formData = formReplayingQueue[i + 2];
          if ("function" !== typeof submitterOrAction)
            if (null === findInstanceBlockingTarget(submitterOrAction || form))
              continue;
            else break;
          var formInst = getInstanceFromNode(form);
          null !== formInst &&
            (formReplayingQueue.splice(i, 3),
            (i -= 3),
            startHostTransition(
              formInst,
              {
                pending: !0,
                data: formData,
                method: form.method,
                action: submitterOrAction
              },
              submitterOrAction,
              formData
            ));
        }
      }
    ));
}
function retryIfBlockedOn(unblocked) {
  function unblock(queuedEvent) {
    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
  }
  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
  queuedPointers.forEach(unblock);
  queuedPointerCaptures.forEach(unblock);
  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
    var queuedTarget = queuedExplicitHydrationTargets[i];
    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
  }
  for (
    ;
    0 < queuedExplicitHydrationTargets.length &&
    ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);

  )
    attemptExplicitHydrationTarget(i),
      null === i.blockedOn && queuedExplicitHydrationTargets.shift();
  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
  if (null != i)
    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
      var form = i[queuedTarget],
        submitterOrAction = i[queuedTarget + 1],
        formProps = form[internalPropsKey] || null;
      if ("function" === typeof submitterOrAction)
        formProps || scheduleReplayQueueIfNeeded(i);
      else if (formProps) {
        var action = null;
        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
          if (
            ((form = submitterOrAction),
            (formProps = submitterOrAction[internalPropsKey] || null))
          )
            action = formProps.formAction;
          else {
            if (null !== findInstanceBlockingTarget(form)) continue;
          }
        else action = formProps.action;
        "function" === typeof action
          ? (i[queuedTarget + 1] = action)
          : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
        scheduleReplayQueueIfNeeded(i);
      }
    }
}
function defaultOnDefaultTransitionIndicator() {
  function handleNavigate(event) {
    event.canIntercept &&
      "react-transition" === event.info &&
      event.intercept({
        handler: function () {
          return new Promise(function (resolve) {
            return (pendingResolve = resolve);
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
  }
  function handleNavigateComplete() {
    null !== pendingResolve && (pendingResolve(), (pendingResolve = null));
    isCancelled || setTimeout(startFakeNavigation, 20);
  }
  function startFakeNavigation() {
    if (!isCancelled && !navigation.transition) {
      var currentEntry = navigation.currentEntry;
      currentEntry &&
        null != currentEntry.url &&
        navigation.navigate(currentEntry.url, {
          state: currentEntry.getState(),
          info: "react-transition",
          history: "replace"
        });
    }
  }
  if ("object" === typeof navigation) {
    var isCancelled = !1,
      pendingResolve = null;
    navigation.addEventListener("navigate", handleNavigate);
    navigation.addEventListener("navigatesuccess", handleNavigateComplete);
    navigation.addEventListener("navigateerror", handleNavigateComplete);
    setTimeout(startFakeNavigation, 100);
    return function () {
      isCancelled = !0;
      navigation.removeEventListener("navigate", handleNavigate);
      navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
      navigation.removeEventListener("navigateerror", handleNavigateComplete);
      null !== pendingResolve && (pendingResolve(), (pendingResolve = null));
    };
  }
}
function ReactDOMRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
  function (children) {
    var root = this._internalRoot;
    if (null === root) throw Error(formatProdErrorMessage(409));
    var current = root.current,
      lane = requestUpdateLane();
    updateContainerImpl(current, lane, children, root, null, null);
  };
ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
  function () {
    var root = this._internalRoot;
    if (null !== root) {
      this._internalRoot = null;
      var container = root.containerInfo;
      updateContainerImpl(root.current, 2, null, root, null, null);
      flushSyncWork$1();
      container[internalContainerInstanceKey] = null;
    }
  };
function ReactDOMHydrationRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
  if (target) {
    var updatePriority = resolveUpdatePriority();
    target = { blockedOn: null, target: target, priority: updatePriority };
    for (
      var i = 0;
      i < queuedExplicitHydrationTargets.length &&
      0 !== updatePriority &&
      updatePriority < queuedExplicitHydrationTargets[i].priority;
      i++
    );
    queuedExplicitHydrationTargets.splice(i, 0, target);
    0 === i && attemptExplicitHydrationTarget(target);
  }
};
var isomorphicReactPackageVersion$jscomp$inline_1840 = React.version;
if (
  "19.2.3" !==
  isomorphicReactPackageVersion$jscomp$inline_1840
)
  throw Error(
    formatProdErrorMessage(
      527,
      isomorphicReactPackageVersion$jscomp$inline_1840,
      "19.2.3"
    )
  );
ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
  var fiber = componentOrElement._reactInternals;
  if (void 0 === fiber) {
    if ("function" === typeof componentOrElement.render)
      throw Error(formatProdErrorMessage(188));
    componentOrElement = Object.keys(componentOrElement).join(",");
    throw Error(formatProdErrorMessage(268, componentOrElement));
  }
  componentOrElement = findCurrentFiberUsingSlowPath(fiber);
  componentOrElement =
    null !== componentOrElement
      ? findCurrentHostFiberImpl(componentOrElement)
      : null;
  componentOrElement =
    null === componentOrElement ? null : componentOrElement.stateNode;
  return componentOrElement;
};
var internals$jscomp$inline_2347 = {
  bundleType: 0,
  version: "19.2.3",
  rendererPackageName: "react-dom",
  currentDispatcherRef: ReactSharedInternals,
  reconcilerVersion: "19.2.3"
};
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (
    !hook$jscomp$inline_2348.isDisabled &&
    hook$jscomp$inline_2348.supportsFiber
  )
    try {
      (rendererID = hook$jscomp$inline_2348.inject(
        internals$jscomp$inline_2347
      )),
        (injectedHook = hook$jscomp$inline_2348);
    } catch (err) {}
}
exports.createRoot = function (container, options) {
  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = !1,
    identifierPrefix = "",
    onUncaughtError = defaultOnUncaughtError,
    onCaughtError = defaultOnCaughtError,
    onRecoverableError = defaultOnRecoverableError;
  null !== options &&
    void 0 !== options &&
    (!0 === options.unstable_strictMode && (isStrictMode = !0),
    void 0 !== options.identifierPrefix &&
      (identifierPrefix = options.identifierPrefix),
    void 0 !== options.onUncaughtError &&
      (onUncaughtError = options.onUncaughtError),
    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
    void 0 !== options.onRecoverableError &&
      (onRecoverableError = options.onRecoverableError));
  options = createFiberRoot(
    container,
    1,
    !1,
    null,
    null,
    isStrictMode,
    identifierPrefix,
    null,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    defaultOnDefaultTransitionIndicator
  );
  container[internalContainerInstanceKey] = options.current;
  listenToAllSupportedEvents(container);
  return new ReactDOMRoot(options);
};
exports.hydrateRoot = function (container, initialChildren, options) {
  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = !1,
    identifierPrefix = "",
    onUncaughtError = defaultOnUncaughtError,
    onCaughtError = defaultOnCaughtError,
    onRecoverableError = defaultOnRecoverableError,
    formState = null;
  null !== options &&
    void 0 !== options &&
    (!0 === options.unstable_strictMode && (isStrictMode = !0),
    void 0 !== options.identifierPrefix &&
      (identifierPrefix = options.identifierPrefix),
    void 0 !== options.onUncaughtError &&
      (onUncaughtError = options.onUncaughtError),
    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
    void 0 !== options.onRecoverableError &&
      (onRecoverableError = options.onRecoverableError),
    void 0 !== options.formState && (formState = options.formState));
  initialChildren = createFiberRoot(
    container,
    1,
    !0,
    initialChildren,
    null != options ? options : null,
    isStrictMode,
    identifierPrefix,
    formState,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    defaultOnDefaultTransitionIndicator
  );
  initialChildren.context = getContextForSubtree(null);
  options = initialChildren.current;
  isStrictMode = requestUpdateLane();
  isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
  identifierPrefix = createUpdate(isStrictMode);
  identifierPrefix.callback = null;
  enqueueUpdate(options, identifierPrefix, isStrictMode);
  options = isStrictMode;
  initialChildren.current.lanes = options;
  markRootUpdated$1(initialChildren, options);
  ensureRootIsScheduled(initialChildren);
  container[internalContainerInstanceKey] = initialChildren.current;
  listenToAllSupportedEvents(container);
  return new ReactDOMHydrationRoot(initialChildren);
};
exports.version = "19.2.3";


/***/ },

/***/ 6221
(__unused_webpack_module, exports, __webpack_require__) {

/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var React = __webpack_require__(6540);
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return (
    "Minified React error #" +
    code +
    "; visit " +
    url +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
function noop() {}
var Internals = {
    d: {
      f: noop,
      r: function () {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop,
      C: noop,
      L: noop,
      m: noop,
      X: noop,
      S: noop,
      M: noop
    },
    p: 0,
    findDOMNode: null
  },
  REACT_PORTAL_TYPE = Symbol.for("react.portal");
function createPortal$1(children, containerInfo, implementation) {
  var key =
    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return {
    $$typeof: REACT_PORTAL_TYPE,
    key: null == key ? null : "" + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}
var ReactSharedInternals =
  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
function getCrossOriginStringAs(as, input) {
  if ("font" === as) return "";
  if ("string" === typeof input)
    return "use-credentials" === input ? input : "";
}
exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
  Internals;
exports.createPortal = function (children, container) {
  var key =
    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (
    !container ||
    (1 !== container.nodeType &&
      9 !== container.nodeType &&
      11 !== container.nodeType)
  )
    throw Error(formatProdErrorMessage(299));
  return createPortal$1(children, container, null, key);
};
exports.flushSync = function (fn) {
  var previousTransition = ReactSharedInternals.T,
    previousUpdatePriority = Internals.p;
  try {
    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();
  } finally {
    (ReactSharedInternals.T = previousTransition),
      (Internals.p = previousUpdatePriority),
      Internals.d.f();
  }
};
exports.preconnect = function (href, options) {
  "string" === typeof href &&
    (options
      ? ((options = options.crossOrigin),
        (options =
          "string" === typeof options
            ? "use-credentials" === options
              ? options
              : ""
            : void 0))
      : (options = null),
    Internals.d.C(href, options));
};
exports.prefetchDNS = function (href) {
  "string" === typeof href && Internals.d.D(href);
};
exports.preinit = function (href, options) {
  if ("string" === typeof href && options && "string" === typeof options.as) {
    var as = options.as,
      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
      integrity =
        "string" === typeof options.integrity ? options.integrity : void 0,
      fetchPriority =
        "string" === typeof options.fetchPriority
          ? options.fetchPriority
          : void 0;
    "style" === as
      ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin: crossOrigin,
            integrity: integrity,
            fetchPriority: fetchPriority
          }
        )
      : "script" === as &&
        Internals.d.X(href, {
          crossOrigin: crossOrigin,
          integrity: integrity,
          fetchPriority: fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
  }
};
exports.preinitModule = function (href, options) {
  if ("string" === typeof href)
    if ("object" === typeof options && null !== options) {
      if (null == options.as || "script" === options.as) {
        var crossOrigin = getCrossOriginStringAs(
          options.as,
          options.crossOrigin
        );
        Internals.d.M(href, {
          crossOrigin: crossOrigin,
          integrity:
            "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    } else null == options && Internals.d.M(href);
};
exports.preload = function (href, options) {
  if (
    "string" === typeof href &&
    "object" === typeof options &&
    null !== options &&
    "string" === typeof options.as
  ) {
    var as = options.as,
      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
    Internals.d.L(href, as, {
      crossOrigin: crossOrigin,
      integrity:
        "string" === typeof options.integrity ? options.integrity : void 0,
      nonce: "string" === typeof options.nonce ? options.nonce : void 0,
      type: "string" === typeof options.type ? options.type : void 0,
      fetchPriority:
        "string" === typeof options.fetchPriority
          ? options.fetchPriority
          : void 0,
      referrerPolicy:
        "string" === typeof options.referrerPolicy
          ? options.referrerPolicy
          : void 0,
      imageSrcSet:
        "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
      imageSizes:
        "string" === typeof options.imageSizes ? options.imageSizes : void 0,
      media: "string" === typeof options.media ? options.media : void 0
    });
  }
};
exports.preloadModule = function (href, options) {
  if ("string" === typeof href)
    if (options) {
      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
      Internals.d.m(href, {
        as:
          "string" === typeof options.as && "script" !== options.as
            ? options.as
            : void 0,
        crossOrigin: crossOrigin,
        integrity:
          "string" === typeof options.integrity ? options.integrity : void 0
      });
    } else Internals.d.m(href);
};
exports.requestFormReset = function (form) {
  Internals.d.r(form);
};
exports.unstable_batchedUpdates = function (fn, a) {
  return fn(a);
};
exports.useFormState = function (action, initialState, permalink) {
  return ReactSharedInternals.H.useFormState(action, initialState, permalink);
};
exports.useFormStatus = function () {
  return ReactSharedInternals.H.useHostTransitionStatus();
};
exports.version = "19.2.3";


/***/ },

/***/ 5338
(module, __unused_webpack_exports, __webpack_require__) {



function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) // removed by dead control flow
{}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(1247);
} else // removed by dead control flow
{}


/***/ },

/***/ 961
(module, __unused_webpack_exports, __webpack_require__) {



function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) // removed by dead control flow
{}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(6221);
} else // removed by dead control flow
{}


/***/ },

/***/ 9698
(__unused_webpack_module, exports) {

/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
function jsxProd(type, config, maybeKey) {
  var key = null;
  void 0 !== maybeKey && (key = "" + maybeKey);
  void 0 !== config.key && (key = "" + config.key);
  if ("key" in config) {
    maybeKey = {};
    for (var propName in config)
      "key" !== propName && (maybeKey[propName] = config[propName]);
  } else maybeKey = config;
  config = maybeKey.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: void 0 !== config ? config : null,
    props: maybeKey
  };
}
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.jsx = jsxProd;
exports.jsxs = jsxProd;


/***/ },

/***/ 9869
(__unused_webpack_module, exports) {

/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
  REACT_MEMO_TYPE = Symbol.for("react.memo"),
  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
  REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable =
    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
    maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var ReactNoopUpdateQueue = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
  assign = Object.assign,
  emptyObject = {};
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
Component.prototype.isReactComponent = {};
Component.prototype.setState = function (partialState, callback) {
  if (
    "object" !== typeof partialState &&
    "function" !== typeof partialState &&
    null != partialState
  )
    throw Error(
      "takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, partialState, callback, "setState");
};
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
};
function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
pureComponentPrototype.constructor = PureComponent;
assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = !0;
var isArrayImpl = Array.isArray;
function noop() {}
var ReactSharedInternals = { H: null, A: null, T: null, S: null },
  hasOwnProperty = Object.prototype.hasOwnProperty;
function ReactElement(type, key, props) {
  var refProp = props.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: void 0 !== refProp ? refProp : null,
    props: props
  };
}
function cloneAndReplaceKey(oldElement, newKey) {
  return ReactElement(oldElement.type, newKey, oldElement.props);
}
function isValidElement(object) {
  return (
    "object" === typeof object &&
    null !== object &&
    object.$$typeof === REACT_ELEMENT_TYPE
  );
}
function escape(key) {
  var escaperLookup = { "=": "=0", ":": "=2" };
  return (
    "$" +
    key.replace(/[=:]/g, function (match) {
      return escaperLookup[match];
    })
  );
}
var userProvidedKeyEscapeRegex = /\/+/g;
function getElementKey(element, index) {
  return "object" === typeof element && null !== element && null != element.key
    ? escape("" + element.key)
    : index.toString(36);
}
function resolveThenable(thenable) {
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenable.reason;
    default:
      switch (
        ("string" === typeof thenable.status
          ? thenable.then(noop, noop)
          : ((thenable.status = "pending"),
            thenable.then(
              function (fulfilledValue) {
                "pending" === thenable.status &&
                  ((thenable.status = "fulfilled"),
                  (thenable.value = fulfilledValue));
              },
              function (error) {
                "pending" === thenable.status &&
                  ((thenable.status = "rejected"), (thenable.reason = error));
              }
            )),
        thenable.status)
      ) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
      }
  }
  throw thenable;
}
function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;
  if ("undefined" === type || "boolean" === type) children = null;
  var invokeCallback = !1;
  if (null === children) invokeCallback = !0;
  else
    switch (type) {
      case "bigint":
      case "string":
      case "number":
        invokeCallback = !0;
        break;
      case "object":
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = !0;
            break;
          case REACT_LAZY_TYPE:
            return (
              (invokeCallback = children._init),
              mapIntoArray(
                invokeCallback(children._payload),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              )
            );
        }
    }
  if (invokeCallback)
    return (
      (callback = callback(children)),
      (invokeCallback =
        "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),
      isArrayImpl(callback)
        ? ((escapedPrefix = ""),
          null != invokeCallback &&
            (escapedPrefix =
              invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
          mapIntoArray(callback, array, escapedPrefix, "", function (c) {
            return c;
          }))
        : null != callback &&
          (isValidElement(callback) &&
            (callback = cloneAndReplaceKey(
              callback,
              escapedPrefix +
                (null == callback.key ||
                (children && children.key === callback.key)
                  ? ""
                  : ("" + callback.key).replace(
                      userProvidedKeyEscapeRegex,
                      "$&/"
                    ) + "/") +
                invokeCallback
            )),
          array.push(callback)),
      1
    );
  invokeCallback = 0;
  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
  if (isArrayImpl(children))
    for (var i = 0; i < children.length; i++)
      (nameSoFar = children[i]),
        (type = nextNamePrefix + getElementKey(nameSoFar, i)),
        (invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        ));
  else if (((i = getIteratorFn(children)), "function" === typeof i))
    for (
      children = i.call(children), i = 0;
      !(nameSoFar = children.next()).done;

    )
      (nameSoFar = nameSoFar.value),
        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),
        (invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        ));
  else if ("object" === type) {
    if ("function" === typeof children.then)
      return mapIntoArray(
        resolveThenable(children),
        array,
        escapedPrefix,
        nameSoFar,
        callback
      );
    array = String(children);
    throw Error(
      "Objects are not valid as a React child (found: " +
        ("[object Object]" === array
          ? "object with keys {" + Object.keys(children).join(", ") + "}"
          : array) +
        "). If you meant to render a collection of children, use an array instead."
    );
  }
  return invokeCallback;
}
function mapChildren(children, func, context) {
  if (null == children) return children;
  var result = [],
    count = 0;
  mapIntoArray(children, result, "", "", function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
function lazyInitializer(payload) {
  if (-1 === payload._status) {
    var ctor = payload._result;
    ctor = ctor();
    ctor.then(
      function (moduleObject) {
        if (0 === payload._status || -1 === payload._status)
          (payload._status = 1), (payload._result = moduleObject);
      },
      function (error) {
        if (0 === payload._status || -1 === payload._status)
          (payload._status = 2), (payload._result = error);
      }
    );
    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));
  }
  if (1 === payload._status) return payload._result.default;
  throw payload._result;
}
var reportGlobalError =
    "function" === typeof reportError
      ? reportError
      : function (error) {
          if (
            "object" === typeof window &&
            "function" === typeof window.ErrorEvent
          ) {
            var event = new window.ErrorEvent("error", {
              bubbles: !0,
              cancelable: !0,
              message:
                "object" === typeof error &&
                null !== error &&
                "string" === typeof error.message
                  ? String(error.message)
                  : String(error),
              error: error
            });
            if (!window.dispatchEvent(event)) return;
          } else if (
            "object" === typeof process &&
            "function" === typeof process.emit
          ) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        },
  Children = {
    map: mapChildren,
    forEach: function (children, forEachFunc, forEachContext) {
      mapChildren(
        children,
        function () {
          forEachFunc.apply(this, arguments);
        },
        forEachContext
      );
    },
    count: function (children) {
      var n = 0;
      mapChildren(children, function () {
        n++;
      });
      return n;
    },
    toArray: function (children) {
      return (
        mapChildren(children, function (child) {
          return child;
        }) || []
      );
    },
    only: function (children) {
      if (!isValidElement(children))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return children;
    }
  };
exports.Activity = REACT_ACTIVITY_TYPE;
exports.Children = Children;
exports.Component = Component;
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.Profiler = REACT_PROFILER_TYPE;
exports.PureComponent = PureComponent;
exports.StrictMode = REACT_STRICT_MODE_TYPE;
exports.Suspense = REACT_SUSPENSE_TYPE;
exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
  ReactSharedInternals;
exports.__COMPILER_RUNTIME = {
  __proto__: null,
  c: function (size) {
    return ReactSharedInternals.H.useMemoCache(size);
  }
};
exports.cache = function (fn) {
  return function () {
    return fn.apply(null, arguments);
  };
};
exports.cacheSignal = function () {
  return null;
};
exports.cloneElement = function (element, config, children) {
  if (null === element || void 0 === element)
    throw Error(
      "The argument must be a React element, but you passed " + element + "."
    );
  var props = assign({}, element.props),
    key = element.key;
  if (null != config)
    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
      !hasOwnProperty.call(config, propName) ||
        "key" === propName ||
        "__self" === propName ||
        "__source" === propName ||
        ("ref" === propName && void 0 === config.ref) ||
        (props[propName] = config[propName]);
  var propName = arguments.length - 2;
  if (1 === propName) props.children = children;
  else if (1 < propName) {
    for (var childArray = Array(propName), i = 0; i < propName; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  return ReactElement(element.type, key, props);
};
exports.createContext = function (defaultValue) {
  defaultValue = {
    $$typeof: REACT_CONTEXT_TYPE,
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  };
  defaultValue.Provider = defaultValue;
  defaultValue.Consumer = {
    $$typeof: REACT_CONSUMER_TYPE,
    _context: defaultValue
  };
  return defaultValue;
};
exports.createElement = function (type, config, children) {
  var propName,
    props = {},
    key = null;
  if (null != config)
    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
      hasOwnProperty.call(config, propName) &&
        "key" !== propName &&
        "__self" !== propName &&
        "__source" !== propName &&
        (props[propName] = config[propName]);
  var childrenLength = arguments.length - 2;
  if (1 === childrenLength) props.children = children;
  else if (1 < childrenLength) {
    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  if (type && type.defaultProps)
    for (propName in ((childrenLength = type.defaultProps), childrenLength))
      void 0 === props[propName] &&
        (props[propName] = childrenLength[propName]);
  return ReactElement(type, key, props);
};
exports.createRef = function () {
  return { current: null };
};
exports.forwardRef = function (render) {
  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };
};
exports.isValidElement = isValidElement;
exports.lazy = function (ctor) {
  return {
    $$typeof: REACT_LAZY_TYPE,
    _payload: { _status: -1, _result: ctor },
    _init: lazyInitializer
  };
};
exports.memo = function (type, compare) {
  return {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: void 0 === compare ? null : compare
  };
};
exports.startTransition = function (scope) {
  var prevTransition = ReactSharedInternals.T,
    currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  try {
    var returnValue = scope(),
      onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish &&
      onStartTransitionFinish(currentTransition, returnValue);
    "object" === typeof returnValue &&
      null !== returnValue &&
      "function" === typeof returnValue.then &&
      returnValue.then(noop, reportGlobalError);
  } catch (error) {
    reportGlobalError(error);
  } finally {
    null !== prevTransition &&
      null !== currentTransition.types &&
      (prevTransition.types = currentTransition.types),
      (ReactSharedInternals.T = prevTransition);
  }
};
exports.unstable_useCacheRefresh = function () {
  return ReactSharedInternals.H.useCacheRefresh();
};
exports.use = function (usable) {
  return ReactSharedInternals.H.use(usable);
};
exports.useActionState = function (action, initialState, permalink) {
  return ReactSharedInternals.H.useActionState(action, initialState, permalink);
};
exports.useCallback = function (callback, deps) {
  return ReactSharedInternals.H.useCallback(callback, deps);
};
exports.useContext = function (Context) {
  return ReactSharedInternals.H.useContext(Context);
};
exports.useDebugValue = function () {};
exports.useDeferredValue = function (value, initialValue) {
  return ReactSharedInternals.H.useDeferredValue(value, initialValue);
};
exports.useEffect = function (create, deps) {
  return ReactSharedInternals.H.useEffect(create, deps);
};
exports.useEffectEvent = function (callback) {
  return ReactSharedInternals.H.useEffectEvent(callback);
};
exports.useId = function () {
  return ReactSharedInternals.H.useId();
};
exports.useImperativeHandle = function (ref, create, deps) {
  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
};
exports.useInsertionEffect = function (create, deps) {
  return ReactSharedInternals.H.useInsertionEffect(create, deps);
};
exports.useLayoutEffect = function (create, deps) {
  return ReactSharedInternals.H.useLayoutEffect(create, deps);
};
exports.useMemo = function (create, deps) {
  return ReactSharedInternals.H.useMemo(create, deps);
};
exports.useOptimistic = function (passthrough, reducer) {
  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
};
exports.useReducer = function (reducer, initialArg, init) {
  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
};
exports.useRef = function (initialValue) {
  return ReactSharedInternals.H.useRef(initialValue);
};
exports.useState = function (initialState) {
  return ReactSharedInternals.H.useState(initialState);
};
exports.useSyncExternalStore = function (
  subscribe,
  getSnapshot,
  getServerSnapshot
) {
  return ReactSharedInternals.H.useSyncExternalStore(
    subscribe,
    getSnapshot,
    getServerSnapshot
  );
};
exports.useTransition = function () {
  return ReactSharedInternals.H.useTransition();
};
exports.version = "19.2.3";


/***/ },

/***/ 6540
(module, __unused_webpack_exports, __webpack_require__) {



if (true) {
  module.exports = __webpack_require__(9869);
} else // removed by dead control flow
{}


/***/ },

/***/ 4848
(module, __unused_webpack_exports, __webpack_require__) {



if (true) {
  module.exports = __webpack_require__(9698);
} else // removed by dead control flow
{}


/***/ },

/***/ 4477
(__unused_webpack_module, exports) {

/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function push(heap, node) {
  var index = heap.length;
  heap.push(node);
  a: for (; 0 < index; ) {
    var parentIndex = (index - 1) >>> 1,
      parent = heap[parentIndex];
    if (0 < compare(parent, node))
      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);
    else break a;
  }
}
function peek(heap) {
  return 0 === heap.length ? null : heap[0];
}
function pop(heap) {
  if (0 === heap.length) return null;
  var first = heap[0],
    last = heap.pop();
  if (last !== first) {
    heap[0] = last;
    a: for (
      var index = 0, length = heap.length, halfLength = length >>> 1;
      index < halfLength;

    ) {
      var leftIndex = 2 * (index + 1) - 1,
        left = heap[leftIndex],
        rightIndex = leftIndex + 1,
        right = heap[rightIndex];
      if (0 > compare(left, last))
        rightIndex < length && 0 > compare(right, left)
          ? ((heap[index] = right),
            (heap[rightIndex] = last),
            (index = rightIndex))
          : ((heap[index] = left),
            (heap[leftIndex] = last),
            (index = leftIndex));
      else if (rightIndex < length && 0 > compare(right, last))
        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);
      else break a;
    }
  }
  return first;
}
function compare(a, b) {
  var diff = a.sortIndex - b.sortIndex;
  return 0 !== diff ? diff : a.id - b.id;
}
exports.unstable_now = void 0;
if ("object" === typeof performance && "function" === typeof performance.now) {
  var localPerformance = performance;
  exports.unstable_now = function () {
    return localPerformance.now();
  };
} else {
  var localDate = Date,
    initialTime = localDate.now();
  exports.unstable_now = function () {
    return localDate.now() - initialTime;
  };
}
var taskQueue = [],
  timerQueue = [],
  taskIdCounter = 1,
  currentTask = null,
  currentPriorityLevel = 3,
  isPerformingWork = !1,
  isHostCallbackScheduled = !1,
  isHostTimeoutScheduled = !1,
  needsPaint = !1,
  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
function advanceTimers(currentTime) {
  for (var timer = peek(timerQueue); null !== timer; ) {
    if (null === timer.callback) pop(timerQueue);
    else if (timer.startTime <= currentTime)
      pop(timerQueue),
        (timer.sortIndex = timer.expirationTime),
        push(taskQueue, timer);
    else break;
    timer = peek(timerQueue);
  }
}
function handleTimeout(currentTime) {
  isHostTimeoutScheduled = !1;
  advanceTimers(currentTime);
  if (!isHostCallbackScheduled)
    if (null !== peek(taskQueue))
      (isHostCallbackScheduled = !0),
        isMessageLoopRunning ||
          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());
    else {
      var firstTimer = peek(timerQueue);
      null !== firstTimer &&
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
}
var isMessageLoopRunning = !1,
  taskTimeoutID = -1,
  frameInterval = 5,
  startTime = -1;
function shouldYieldToHost() {
  return needsPaint
    ? !0
    : exports.unstable_now() - startTime < frameInterval
      ? !1
      : !0;
}
function performWorkUntilDeadline() {
  needsPaint = !1;
  if (isMessageLoopRunning) {
    var currentTime = exports.unstable_now();
    startTime = currentTime;
    var hasMoreWork = !0;
    try {
      a: {
        isHostCallbackScheduled = !1;
        isHostTimeoutScheduled &&
          ((isHostTimeoutScheduled = !1),
          localClearTimeout(taskTimeoutID),
          (taskTimeoutID = -1));
        isPerformingWork = !0;
        var previousPriorityLevel = currentPriorityLevel;
        try {
          b: {
            advanceTimers(currentTime);
            for (
              currentTask = peek(taskQueue);
              null !== currentTask &&
              !(
                currentTask.expirationTime > currentTime && shouldYieldToHost()
              );

            ) {
              var callback = currentTask.callback;
              if ("function" === typeof callback) {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var continuationCallback = callback(
                  currentTask.expirationTime <= currentTime
                );
                currentTime = exports.unstable_now();
                if ("function" === typeof continuationCallback) {
                  currentTask.callback = continuationCallback;
                  advanceTimers(currentTime);
                  hasMoreWork = !0;
                  break b;
                }
                currentTask === peek(taskQueue) && pop(taskQueue);
                advanceTimers(currentTime);
              } else pop(taskQueue);
              currentTask = peek(taskQueue);
            }
            if (null !== currentTask) hasMoreWork = !0;
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer &&
                requestHostTimeout(
                  handleTimeout,
                  firstTimer.startTime - currentTime
                );
              hasMoreWork = !1;
            }
          }
          break a;
        } finally {
          (currentTask = null),
            (currentPriorityLevel = previousPriorityLevel),
            (isPerformingWork = !1);
        }
        hasMoreWork = void 0;
      }
    } finally {
      hasMoreWork
        ? schedulePerformWorkUntilDeadline()
        : (isMessageLoopRunning = !1);
    }
  }
}
var schedulePerformWorkUntilDeadline;
if ("function" === typeof localSetImmediate)
  schedulePerformWorkUntilDeadline = function () {
    localSetImmediate(performWorkUntilDeadline);
  };
else if ("undefined" !== typeof MessageChannel) {
  var channel = new MessageChannel(),
    port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;
  schedulePerformWorkUntilDeadline = function () {
    port.postMessage(null);
  };
} else
  schedulePerformWorkUntilDeadline = function () {
    localSetTimeout(performWorkUntilDeadline, 0);
  };
function requestHostTimeout(callback, ms) {
  taskTimeoutID = localSetTimeout(function () {
    callback(exports.unstable_now());
  }, ms);
}
exports.unstable_IdlePriority = 5;
exports.unstable_ImmediatePriority = 1;
exports.unstable_LowPriority = 4;
exports.unstable_NormalPriority = 3;
exports.unstable_Profiling = null;
exports.unstable_UserBlockingPriority = 2;
exports.unstable_cancelCallback = function (task) {
  task.callback = null;
};
exports.unstable_forceFrameRate = function (fps) {
  0 > fps || 125 < fps
    ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      )
    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
};
exports.unstable_getCurrentPriorityLevel = function () {
  return currentPriorityLevel;
};
exports.unstable_next = function (eventHandler) {
  switch (currentPriorityLevel) {
    case 1:
    case 2:
    case 3:
      var priorityLevel = 3;
      break;
    default:
      priorityLevel = currentPriorityLevel;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
};
exports.unstable_requestPaint = function () {
  needsPaint = !0;
};
exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      break;
    default:
      priorityLevel = 3;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
};
exports.unstable_scheduleCallback = function (
  priorityLevel,
  callback,
  options
) {
  var currentTime = exports.unstable_now();
  "object" === typeof options && null !== options
    ? ((options = options.delay),
      (options =
        "number" === typeof options && 0 < options
          ? currentTime + options
          : currentTime))
    : (options = currentTime);
  switch (priorityLevel) {
    case 1:
      var timeout = -1;
      break;
    case 2:
      timeout = 250;
      break;
    case 5:
      timeout = 1073741823;
      break;
    case 4:
      timeout = 1e4;
      break;
    default:
      timeout = 5e3;
  }
  timeout = options + timeout;
  priorityLevel = {
    id: taskIdCounter++,
    callback: callback,
    priorityLevel: priorityLevel,
    startTime: options,
    expirationTime: timeout,
    sortIndex: -1
  };
  options > currentTime
    ? ((priorityLevel.sortIndex = options),
      push(timerQueue, priorityLevel),
      null === peek(taskQueue) &&
        priorityLevel === peek(timerQueue) &&
        (isHostTimeoutScheduled
          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
          : (isHostTimeoutScheduled = !0),
        requestHostTimeout(handleTimeout, options - currentTime)))
    : ((priorityLevel.sortIndex = timeout),
      push(taskQueue, priorityLevel),
      isHostCallbackScheduled ||
        isPerformingWork ||
        ((isHostCallbackScheduled = !0),
        isMessageLoopRunning ||
          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline())));
  return priorityLevel;
};
exports.unstable_shouldYield = shouldYieldToHost;
exports.unstable_wrapCallback = function (callback) {
  var parentPriorityLevel = currentPriorityLevel;
  return function () {
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = parentPriorityLevel;
    try {
      return callback.apply(this, arguments);
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
};


/***/ },

/***/ 9982
(module, __unused_webpack_exports, __webpack_require__) {



if (true) {
  module.exports = __webpack_require__(4477);
} else // removed by dead control flow
{}


/***/ },

/***/ 5072
(module) {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ },

/***/ 7659
(module) {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ },

/***/ 540
(module) {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ },

/***/ 5056
(module, __unused_webpack_exports, __webpack_require__) {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ },

/***/ 7825
(module) {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ },

/***/ 1113
(module) {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ },

/***/ 3482
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

/* unused harmony export setBundleModeAndUpdate */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6540);
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5338);
/* harmony import */ var remotion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3947);
/* harmony import */ var remotion_no_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9382);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4848);


// src/renderEntry.tsx





var currentBundleMode = {
  type: "index"
};
var setBundleMode = (state) => {
  currentBundleMode = state;
};
var getBundleMode = () => {
  return currentBundleMode;
};
remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.CSSUtils.injectCSS(remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.CSSUtils.makeDefaultPreviewCSS(null, "#1f2428"));
var getCanSerializeDefaultProps = (object) => {
  try {
    const str = JSON.stringify(object);
    return str.length < 256 * 1024 * 1024 * 0.9;
  } catch (err) {
    if (err.message.includes("Invalid string length")) {
      return false;
    }
    throw err;
  }
};
var isInHeadlessBrowser = () => {
  return typeof window.remotion_puppeteerTimeout !== "undefined";
};
var DelayedSpinner = () => {
  const [show, setShow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const timeout = setTimeout(() => {
      setShow(true);
    }, 2000);
    return () => {
      clearTimeout(timeout);
    };
  }, []);
  if (!show) {
    return null;
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_2__.AbsoluteFill, {
    style: {
      justifyContent: "center",
      alignItems: "center",
      fontSize: 13,
      opacity: 0.6,
      color: "white",
      fontFamily: "Helvetica, Arial, sans-serif"
    },
    children: "Loading Studio"
  });
};
var GetVideoComposition = ({ state }) => {
  const { compositions, currentCompositionMetadata, canvasContent } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.CompositionManager);
  const { setCanvasContent } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.CompositionSetters);
  const portalContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const { delayRender, continueRender } = (0,remotion__WEBPACK_IMPORTED_MODULE_2__.useDelayRender)();
  const [handle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => delayRender(`Waiting for Composition "${state.compositionName}"`));
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    return () => continueRender(handle);
  }, [handle, continueRender]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (compositions.length === 0) {
      return;
    }
    const foundComposition = compositions.find((c) => c.id === state.compositionName);
    if (!foundComposition) {
      throw new Error(`Found no composition with the name ${state.compositionName}. The following compositions were found instead: ${compositions.map((c) => c.id).join(", ")}. All compositions must have their ID calculated deterministically and must be mounted at the same time.`);
    }
    setCanvasContent({
      type: "composition",
      compositionId: foundComposition.id
    });
  }, [compositions, state, currentCompositionMetadata, setCanvasContent]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!canvasContent) {
      return;
    }
    const { current } = portalContainer;
    if (!current) {
      throw new Error("portal did not render");
    }
    current.appendChild(remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.portalNode());
    continueRender(handle);
    return () => {
      current.removeChild(remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.portalNode());
    };
  }, [canvasContent, handle, continueRender]);
  if (!currentCompositionMetadata) {
    return null;
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
    ref: portalContainer,
    id: "remotion-canvas",
    style: {
      width: currentCompositionMetadata.width,
      height: currentCompositionMetadata.height,
      display: "flex",
      backgroundColor: "transparent"
    }
  });
};
var DEFAULT_ROOT_COMPONENT_TIMEOUT = 1e4;
var waitForRootHandle = (0,remotion__WEBPACK_IMPORTED_MODULE_2__.delayRender)("Loading root component - See https://remotion.dev/docs/troubleshooting/loading-root-component if you experience a timeout", {
  timeoutInMilliseconds: typeof window === "undefined" ? DEFAULT_ROOT_COMPONENT_TIMEOUT : window.remotion_puppeteerTimeout ?? DEFAULT_ROOT_COMPONENT_TIMEOUT
});
var videoContainer = document.getElementById("video-container");
var root = null;
var getRootForElement = () => {
  if (root) {
    return root;
  }
  root = react_dom_client__WEBPACK_IMPORTED_MODULE_1__.createRoot(videoContainer);
  return root;
};
var renderToDOM = (content) => {
  if (!react_dom_client__WEBPACK_IMPORTED_MODULE_1__.createRoot) {
    if (remotion_no_react__WEBPACK_IMPORTED_MODULE_3__.NoReactInternals.ENABLE_V5_BREAKING_CHANGES) {
      throw new Error("Remotion 5.0 does only support React 18+. However, ReactDOM.createRoot() is undefined.");
    }
    react_dom_client__WEBPACK_IMPORTED_MODULE_1__.render(content, videoContainer);
    return;
  }
  getRootForElement().render(content);
};
var renderContent = (Root) => {
  const bundleMode = getBundleMode();
  if (bundleMode.type === "composition") {
    const markup = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.CompositionManagerProvider, {
      initialCanvasContent: null,
      onlyRenderComposition: bundleMode.compositionName,
      currentCompositionMetadata: {
        props: remotion_no_react__WEBPACK_IMPORTED_MODULE_3__.NoReactInternals.deserializeJSONWithSpecialTypes(bundleMode.serializedResolvedPropsWithSchema),
        durationInFrames: bundleMode.compositionDurationInFrames,
        fps: bundleMode.compositionFps,
        height: bundleMode.compositionHeight,
        width: bundleMode.compositionWidth,
        defaultCodec: bundleMode.compositionDefaultCodec,
        defaultOutName: bundleMode.compositionDefaultOutName,
        defaultVideoImageFormat: bundleMode.compositionDefaultVideoImageFormat,
        defaultPixelFormat: bundleMode.compositionDefaultPixelFormat,
        defaultProResProfile: bundleMode.compositionDefaultProResProfile
      },
      initialCompositions: [],
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.RemotionRootContexts, {
        frameState: null,
        audioEnabled: window.remotion_audioEnabled,
        videoEnabled: window.remotion_videoEnabled,
        logLevel: window.remotion_logLevel,
        numberOfAudioTags: 0,
        nonceContextSeed: 0,
        audioLatencyHint: window.remotion_audioLatencyHint ?? "interactive",
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.RenderAssetManagerProvider, {
          collectAssets: null,
          children: [
            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Root, {}),
            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(GetVideoComposition, {
              state: bundleMode
            })
          ]
        })
      })
    });
    renderToDOM(markup);
  }
  if (bundleMode.type === "evaluation") {
    const markup = /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.CompositionManagerProvider, {
      initialCanvasContent: null,
      onlyRenderComposition: null,
      currentCompositionMetadata: null,
      initialCompositions: [],
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.RemotionRootContexts, {
        frameState: null,
        audioEnabled: window.remotion_audioEnabled,
        videoEnabled: window.remotion_videoEnabled,
        logLevel: window.remotion_logLevel,
        numberOfAudioTags: 0,
        audioLatencyHint: window.remotion_audioLatencyHint ?? "interactive",
        nonceContextSeed: 0,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.RenderAssetManagerProvider, {
          collectAssets: null,
          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(Root, {})
        })
      })
    });
    renderToDOM(markup);
  }
  if (bundleMode.type === "index") {
    if (isInHeadlessBrowser()) {
      return;
    }
    renderToDOM(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)("div", {
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(DelayedSpinner, {})
    }));
    Promise.all(/* import() */[__webpack_require__.e(724), __webpack_require__.e(845)]).then(__webpack_require__.bind(__webpack_require__, 6724)).then(({ StudioInternals }) => {
      window.remotion_isStudio = true;
      window.remotion_isReadOnlyStudio = true;
      window.remotion_inputProps = "{}";
      remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.enableSequenceStackTraces();
      renderToDOM(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(StudioInternals.Studio, {
        readOnly: true,
        rootComponent: Root
      }));
    }).catch((err) => {
      renderToDOM(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)("div", {
        children: [
          "Failed to load Remotion Studio: ",
          err.message
        ]
      }));
    });
  }
};
remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.waitForRoot((Root) => {
  renderContent(Root);
  (0,remotion__WEBPACK_IMPORTED_MODULE_2__.continueRender)(waitForRootHandle);
});
var setBundleModeAndUpdate = (state) => {
  setBundleMode(state);
  const delay = (0,remotion__WEBPACK_IMPORTED_MODULE_2__.delayRender)("Waiting for root component to load - See https://remotion.dev/docs/troubleshooting/loading-root-component if you experience a timeout");
  remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.waitForRoot((Root) => {
    renderContent(Root);
    requestAnimationFrame(() => {
      (0,remotion__WEBPACK_IMPORTED_MODULE_2__.continueRender)(delay);
    });
  });
};
if (typeof window !== "undefined") {
  const getUnevaluatedComps = () => {
    if (!remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.getRoot()) {
      throw new Error("registerRoot() was never called. 1. Make sure you specified the correct entrypoint for your bundle. 2. If your registerRoot() call is deferred, use the delayRender/continueRender pattern to tell Remotion to wait.");
    }
    if (!remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.compositionsRef.current) {
      throw new Error("Unexpectedly did not have a CompositionManager");
    }
    const compositions = remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.compositionsRef.current.getCompositions();
    const canSerializeDefaultProps = getCanSerializeDefaultProps(compositions);
    if (!canSerializeDefaultProps) {
      remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.Log.warn({ logLevel: window.remotion_logLevel, tag: null }, "defaultProps are too big to serialize - trying to find the problematic composition...");
      remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.Log.warn({ logLevel: window.remotion_logLevel, tag: null }, "Serialization:", compositions);
      for (const comp of compositions) {
        if (!getCanSerializeDefaultProps(comp)) {
          throw new Error(`defaultProps too big - could not serialize - the defaultProps of composition with ID ${comp.id} - the object that was passed to defaultProps was too big. Learn how to mitigate this error by visiting https://remotion.dev/docs/troubleshooting/serialize-defaultprops`);
        }
      }
      remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.Log.warn({ logLevel: window.remotion_logLevel, tag: null }, "Could not single out a problematic composition -  The composition list as a whole is too big to serialize.");
      throw new Error("defaultProps too big - Could not serialize - an object that was passed to defaultProps was too big. Learn how to mitigate this error by visiting https://remotion.dev/docs/troubleshooting/serialize-defaultprops");
    }
    return compositions;
  };
  window.getStaticCompositions = () => {
    const compositions = getUnevaluatedComps();
    const inputProps = typeof window === "undefined" || (0,remotion__WEBPACK_IMPORTED_MODULE_2__.getRemotionEnvironment)().isPlayer ? {} : (0,remotion__WEBPACK_IMPORTED_MODULE_2__.getInputProps)() ?? {};
    return Promise.all(compositions.map(async (c) => {
      const handle = (0,remotion__WEBPACK_IMPORTED_MODULE_2__.delayRender)(`Running calculateMetadata() for composition ${c.id}. If you didn't want to evaluate this composition, use "selectComposition()" instead of "getCompositions()"`);
      const originalProps = {
        ...c.defaultProps ?? {},
        ...inputProps ?? {}
      };
      const comp = remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.resolveVideoConfig({
        calculateMetadata: c.calculateMetadata,
        compositionDurationInFrames: c.durationInFrames ?? null,
        compositionFps: c.fps ?? null,
        compositionHeight: c.height ?? null,
        compositionWidth: c.width ?? null,
        signal: new AbortController().signal,
        inputProps: originalProps,
        defaultProps: c.defaultProps ?? {},
        compositionId: c.id
      });
      const resolved = await Promise.resolve(comp);
      (0,remotion__WEBPACK_IMPORTED_MODULE_2__.continueRender)(handle);
      const { props, defaultProps, ...data } = resolved;
      return {
        ...data,
        serializedResolvedPropsWithCustomSchema: remotion_no_react__WEBPACK_IMPORTED_MODULE_3__.NoReactInternals.serializeJSONWithSpecialTypes({
          data: props,
          indent: undefined,
          staticBase: null
        }).serializedString,
        serializedDefaultPropsWithCustomSchema: remotion_no_react__WEBPACK_IMPORTED_MODULE_3__.NoReactInternals.serializeJSONWithSpecialTypes({
          data: defaultProps,
          indent: undefined,
          staticBase: null
        }).serializedString
      };
    }));
  };
  window.remotion_getCompositionNames = () => {
    return getUnevaluatedComps().map((c) => c.id);
  };
  window.remotion_calculateComposition = async (compId) => {
    const compositions = getUnevaluatedComps();
    const selectedComp = compositions.find((c) => c.id === compId);
    if (!selectedComp) {
      throw new Error(`Could not find composition with ID ${compId}. Available compositions: ${compositions.map((c) => c.id).join(", ")}`);
    }
    const abortController = new AbortController;
    const handle = (0,remotion__WEBPACK_IMPORTED_MODULE_2__.delayRender)(`Running the calculateMetadata() function for composition ${compId}`);
    const inputProps = typeof window === "undefined" || (0,remotion__WEBPACK_IMPORTED_MODULE_2__.getRemotionEnvironment)().isPlayer ? {} : (0,remotion__WEBPACK_IMPORTED_MODULE_2__.getInputProps)() ?? {};
    const originalProps = {
      ...selectedComp.defaultProps ?? {},
      ...inputProps ?? {}
    };
    const prom = await Promise.resolve(remotion__WEBPACK_IMPORTED_MODULE_2__.Internals.resolveVideoConfig({
      calculateMetadata: selectedComp.calculateMetadata,
      compositionDurationInFrames: selectedComp.durationInFrames ?? null,
      compositionFps: selectedComp.fps ?? null,
      compositionHeight: selectedComp.height ?? null,
      compositionWidth: selectedComp.width ?? null,
      inputProps: originalProps,
      signal: abortController.signal,
      defaultProps: selectedComp.defaultProps ?? {},
      compositionId: selectedComp.id
    }));
    (0,remotion__WEBPACK_IMPORTED_MODULE_2__.continueRender)(handle);
    const { props, defaultProps, ...data } = prom;
    return {
      ...data,
      serializedResolvedPropsWithCustomSchema: remotion_no_react__WEBPACK_IMPORTED_MODULE_3__.NoReactInternals.serializeJSONWithSpecialTypes({
        data: props,
        indent: undefined,
        staticBase: null
      }).serializedString,
      serializedDefaultPropsWithCustomSchema: remotion_no_react__WEBPACK_IMPORTED_MODULE_3__.NoReactInternals.serializeJSONWithSpecialTypes({
        data: defaultProps,
        indent: undefined,
        staticBase: null
      }).serializedString
    };
  };
  window.remotion_setBundleMode = setBundleModeAndUpdate;
}



/***/ },

/***/ 3947
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbsoluteFill: () => (/* binding */ AbsoluteFill),
/* harmony export */   AnimatedImage: () => (/* binding */ AnimatedImage),
/* harmony export */   Artifact: () => (/* binding */ Artifact),
/* harmony export */   Audio: () => (/* binding */ Audio),
/* harmony export */   Composition: () => (/* binding */ Composition),
/* harmony export */   Config: () => (/* binding */ Config),
/* harmony export */   Easing: () => (/* binding */ Easing),
/* harmony export */   Experimental: () => (/* binding */ Experimental),
/* harmony export */   Folder: () => (/* binding */ Folder),
/* harmony export */   FolderContext: () => (/* binding */ FolderContext),
/* harmony export */   Freeze: () => (/* binding */ Freeze),
/* harmony export */   Html5Audio: () => (/* binding */ Html5Audio),
/* harmony export */   Html5Video: () => (/* binding */ Html5Video),
/* harmony export */   IFrame: () => (/* binding */ IFrame),
/* harmony export */   Img: () => (/* binding */ Img),
/* harmony export */   Internals: () => (/* binding */ Internals),
/* harmony export */   Loop: () => (/* binding */ Loop),
/* harmony export */   OffthreadVideo: () => (/* binding */ OffthreadVideo),
/* harmony export */   Sequence: () => (/* binding */ Sequence),
/* harmony export */   Series: () => (/* binding */ Series),
/* harmony export */   Still: () => (/* binding */ Still),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   Video: () => (/* binding */ Video),
/* harmony export */   cancelRender: () => (/* binding */ cancelRender),
/* harmony export */   continueRender: () => (/* binding */ continueRender),
/* harmony export */   delayRender: () => (/* binding */ delayRender),
/* harmony export */   getInputProps: () => (/* binding */ getInputProps),
/* harmony export */   getRemotionEnvironment: () => (/* binding */ getRemotionEnvironment),
/* harmony export */   getStaticFiles: () => (/* binding */ getStaticFiles),
/* harmony export */   interpolate: () => (/* binding */ interpolate),
/* harmony export */   interpolateColors: () => (/* binding */ interpolateColors),
/* harmony export */   measureSpring: () => (/* binding */ measureSpring),
/* harmony export */   prefetch: () => (/* binding */ prefetch),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   registerRoot: () => (/* binding */ registerRoot),
/* harmony export */   spring: () => (/* binding */ spring),
/* harmony export */   staticFile: () => (/* binding */ staticFile),
/* harmony export */   useBufferState: () => (/* binding */ useBufferState),
/* harmony export */   useCurrentFrame: () => (/* binding */ useCurrentFrame),
/* harmony export */   useCurrentScale: () => (/* binding */ useCurrentScale),
/* harmony export */   useDelayRender: () => (/* binding */ useDelayRender),
/* harmony export */   useRemotionEnvironment: () => (/* binding */ useRemotionEnvironment),
/* harmony export */   useVideoConfig: () => (/* binding */ useVideoConfig),
/* harmony export */   watchStaticFile: () => (/* binding */ watchStaticFile)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6540);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4848);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(961);
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// src/_check-rsc.ts

if (typeof react__WEBPACK_IMPORTED_MODULE_0__.createContext !== "function") {
  const err = [
    'Remotion requires React.createContext, but it is "undefined".',
    'If you are in a React Server Component, turn it into a client component by adding "use client" at the top of the file.',
    "",
    "Before:",
    '  import {useCurrentFrame} from "remotion";',
    "",
    "After:",
    '  "use client";',
    '  import {useCurrentFrame} from "remotion";'
  ];
  throw new Error(err.join(`
`));
}

// src/Clipper.tsx
var Clipper = () => {
  throw new Error("<Clipper> has been removed as of Remotion v4.0.228. The native clipping APIs were experimental and subject to removal at any time. We removed them because they were sparingly used and made rendering often slower rather than faster.");
};

// src/enable-sequence-stack-traces.ts



// src/get-remotion-environment.ts
function getNodeEnvString() {
  return ["NOD", "E_EN", "V"].join("");
}
var getEnvString = () => {
  return ["e", "nv"].join("");
};
var getRemotionEnvironment = () => {
  const isPlayer = typeof window !== "undefined" && window.remotion_isPlayer;
  const isRendering = typeof window !== "undefined" && typeof window.process !== "undefined" && typeof window.process.env !== "undefined" && (window.process[getEnvString()][getNodeEnvString()] === "test" || window.process[getEnvString()][getNodeEnvString()] === "production" && typeof window !== "undefined" && typeof window.remotion_puppeteerTimeout !== "undefined");
  const isStudio = typeof window !== "undefined" && window.remotion_isStudio;
  const isReadOnlyStudio = typeof window !== "undefined" && window.remotion_isReadOnlyStudio;
  return {
    isStudio,
    isRendering,
    isPlayer,
    isReadOnlyStudio,
    isClientSideRendering: false
  };
};

// src/enable-sequence-stack-traces.ts
var originalCreateElement = react__WEBPACK_IMPORTED_MODULE_0__.createElement;
var originalJsx = react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx;
var componentsToAddStacksTo = [];
var enableProxy = (api) => {
  return new Proxy(api, {
    apply(target, thisArg, argArray) {
      if (componentsToAddStacksTo.includes(argArray[0])) {
        const [first, props, ...rest] = argArray;
        const newProps = props.stack ? props : {
          ...props ?? {},
          stack: new Error().stack
        };
        return Reflect.apply(target, thisArg, [first, newProps, ...rest]);
      }
      return Reflect.apply(target, thisArg, argArray);
    }
  });
};
var enableSequenceStackTraces = () => {
  if (!getRemotionEnvironment().isStudio) {
    return;
  }
  react__WEBPACK_IMPORTED_MODULE_0__.createElement = enableProxy(originalCreateElement);
  react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx = enableProxy(originalJsx);
};
var addSequenceStackTraces = (component) => {
  componentsToAddStacksTo.push(component);
  enableSequenceStackTraces();
};

// src/is-player.tsx


var IsPlayerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);
var IsPlayerContextProvider = ({
  children
}) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsPlayerContext.Provider, {
    value: true,
    children
  });
};
var useIsPlayer = () => {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IsPlayerContext);
};

// src/truthy.ts
function truthy(value) {
  return Boolean(value);
}

// src/version.ts
var VERSION = "4.0.421";

// src/multiple-versions-warning.ts
var checkMultipleRemotionVersions = () => {
  if (typeof globalThis === "undefined") {
    return;
  }
  const set = () => {
    globalThis.remotion_imported = VERSION;
    if (typeof window !== "undefined") {
      window.remotion_imported = VERSION;
    }
  };
  const alreadyImported = globalThis.remotion_imported || typeof window !== "undefined" && window.remotion_imported;
  if (alreadyImported) {
    if (alreadyImported === VERSION) {
      return;
    }
    if (typeof alreadyImported === "string" && alreadyImported.includes("webcodecs")) {
      set();
      return;
    }
    throw new TypeError(`\uD83D\uDEA8 Multiple versions of Remotion detected: ${[
      VERSION,
      typeof alreadyImported === "string" ? alreadyImported : "an older version"
    ].filter(truthy).join(" and ")}. This will cause things to break in an unexpected way.
Check that all your Remotion packages are on the same version. If your dependencies depend on Remotion, make them peer dependencies. You can also run \`npx remotion versions\` from your terminal to see which versions are mismatching.`);
  }
  set();
};

// src/Null.tsx
var Null = () => {
  throw new Error("<Null> has been removed as of Remotion v4.0.228. The native clipping APIs were experimental and subject to removal at any time. We removed them because they were sparingly used and made rendering often slower rather than faster.");
};

// src/Sequence.tsx


// src/AbsoluteFill.tsx


var hasTailwindClassName = ({
  className,
  classPrefix,
  type
}) => {
  if (!className) {
    return false;
  }
  if (type === "exact") {
    const split = className.split(" ");
    return classPrefix.some((token) => {
      return split.some((part) => {
        return part.trim() === token || part.trim().endsWith(`:${token}`) || part.trim().endsWith(`!${token}`);
      });
    });
  }
  return classPrefix.some((prefix) => {
    return className.startsWith(prefix) || className.includes(` ${prefix}`) || className.includes(`!${prefix}`) || className.includes(`:${prefix}`);
  });
};
var AbsoluteFillRefForwarding = (props, ref) => {
  const { style, ...other } = props;
  const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      position: "absolute",
      top: hasTailwindClassName({
        className: other.className,
        classPrefix: ["top-", "inset-"],
        type: "prefix"
      }) ? undefined : 0,
      left: hasTailwindClassName({
        className: other.className,
        classPrefix: ["left-", "inset-"],
        type: "prefix"
      }) ? undefined : 0,
      right: hasTailwindClassName({
        className: other.className,
        classPrefix: ["right-", "inset-"],
        type: "prefix"
      }) ? undefined : 0,
      bottom: hasTailwindClassName({
        className: other.className,
        classPrefix: ["bottom-", "inset-"],
        type: "prefix"
      }) ? undefined : 0,
      width: hasTailwindClassName({
        className: other.className,
        classPrefix: ["w-"],
        type: "prefix"
      }) ? undefined : "100%",
      height: hasTailwindClassName({
        className: other.className,
        classPrefix: ["h-"],
        type: "prefix"
      }) ? undefined : "100%",
      display: hasTailwindClassName({
        className: other.className,
        classPrefix: [
          "block",
          "inline-block",
          "inline",
          "flex",
          "inline-flex",
          "flow-root",
          "grid",
          "inline-grid",
          "contents",
          "list-item",
          "hidden"
        ],
        type: "exact"
      }) ? undefined : "flex",
      flexDirection: hasTailwindClassName({
        className: other.className,
        classPrefix: [
          "flex-row",
          "flex-col",
          "flex-row-reverse",
          "flex-col-reverse"
        ],
        type: "exact"
      }) ? undefined : "column",
      ...style
    };
  }, [other.className, style]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
    ref,
    style: actualStyle,
    ...other
  });
};
var AbsoluteFill = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AbsoluteFillRefForwarding);

// src/SequenceContext.tsx

var SequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);

// src/SequenceManager.tsx


var SequenceManager = react__WEBPACK_IMPORTED_MODULE_0__.createContext({
  registerSequence: () => {
    throw new Error("SequenceManagerContext not initialized");
  },
  unregisterSequence: () => {
    throw new Error("SequenceManagerContext not initialized");
  },
  sequences: []
});
var SequenceVisibilityToggleContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({
  hidden: {},
  setHidden: () => {
    throw new Error("SequenceVisibilityToggle not initialized");
  }
});
var SequenceManagerProvider = ({ children }) => {
  const [sequences, setSequences] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
  const [hidden, setHidden] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});
  const registerSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq) => {
    setSequences((seqs) => {
      return [...seqs, seq];
    });
  }, []);
  const unregisterSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq) => {
    setSequences((seqs) => seqs.filter((s) => s.id !== seq));
  }, []);
  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      registerSequence,
      sequences,
      unregisterSequence
    };
  }, [registerSequence, sequences, unregisterSequence]);
  const hiddenContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      hidden,
      setHidden
    };
  }, [hidden]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {
    value: sequenceContext,
    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceVisibilityToggleContext.Provider, {
      value: hiddenContext,
      children
    })
  });
};

// src/TimelineContext.tsx


// src/random.ts
function mulberry32(a) {
  let t = a + 1831565813;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function hashCode(str) {
  let i = 0;
  let chr = 0;
  let hash = 0;
  for (i = 0;i < str.length; i++) {
    chr = str.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  return hash;
}
var random = (seed, dummy) => {
  if (dummy !== undefined) {
    throw new TypeError("random() takes only one argument");
  }
  if (seed === null) {
    return Math.random();
  }
  if (typeof seed === "string") {
    return mulberry32(hashCode(seed));
  }
  if (typeof seed === "number") {
    return mulberry32(seed * 10000000000);
  }
  throw new Error("random() argument must be a number or a string");
};

// src/timeline-position-state.ts
var exports_timeline_position_state = {};
__export(exports_timeline_position_state, {
  useTimelineSetFrame: () => useTimelineSetFrame,
  useTimelinePosition: () => useTimelinePosition,
  usePlayingState: () => usePlayingState,
  persistCurrentFrame: () => persistCurrentFrame,
  getInitialFrameState: () => getInitialFrameState,
  getFrameForComposition: () => getFrameForComposition
});


// src/use-remotion-environment.ts


// src/remotion-environment-context.ts

var RemotionEnvironmentContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);

// src/use-remotion-environment.ts
var useRemotionEnvironment = () => {
  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RemotionEnvironmentContext);
  const [env] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => getRemotionEnvironment());
  return context ?? env;
};

// src/use-video.ts


// src/CompositionManagerContext.tsx

var CompositionManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  compositions: [],
  folders: [],
  currentCompositionMetadata: null,
  canvasContent: null
});
var CompositionSetters = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  registerComposition: () => {
    return;
  },
  unregisterComposition: () => {
    return;
  },
  registerFolder: () => {
    return;
  },
  unregisterFolder: () => {
    return;
  },
  setCanvasContent: () => {
    return;
  },
  updateCompositionDefaultProps: () => {
    return;
  },
  onlyRenderComposition: null
});

// src/ResolveCompositionConfig.tsx


// src/EditorProps.tsx


var EditorPropsContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  props: {},
  updateProps: () => {
    throw new Error("Not implemented");
  },
  resetUnsaved: () => {
    throw new Error("Not implemented");
  }
});
var editorPropsProviderRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();
var timeValueRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();
var EditorPropsProvider = ({ children }) => {
  const [props, setProps] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});
  const updateProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({
    defaultProps,
    id,
    newProps
  }) => {
    setProps((prev) => {
      return {
        ...prev,
        [id]: typeof newProps === "function" ? newProps(prev[id] ?? defaultProps) : newProps
      };
    });
  }, []);
  const resetUnsaved = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((compositionId) => {
    setProps((prev) => {
      if (prev[compositionId]) {
        const newProps = { ...prev };
        delete newProps[compositionId];
        return newProps;
      }
      return prev;
    });
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(editorPropsProviderRef, () => {
    return {
      getProps: () => props,
      setProps
    };
  }, [props]);
  const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return { props, updateProps, resetUnsaved };
  }, [props, resetUnsaved, updateProps]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsContext.Provider, {
    value: ctx,
    children
  });
};

// src/input-props-override.ts
var getKey = () => {
  return `remotion_inputPropsOverride` + window.location.origin;
};
var getInputPropsOverride = () => {
  if (typeof localStorage === "undefined")
    return null;
  const override = localStorage.getItem(getKey());
  if (!override)
    return null;
  return JSON.parse(override);
};
var setInputPropsOverride = (override) => {
  if (typeof localStorage === "undefined")
    return;
  if (override === null) {
    localStorage.removeItem(getKey());
    return;
  }
  localStorage.setItem(getKey(), JSON.stringify(override));
};

// src/input-props-serialization.ts
var DATE_TOKEN = "remotion-date:";
var FILE_TOKEN = "remotion-file:";
var serializeJSONWithSpecialTypes = ({
  data,
  indent,
  staticBase
}) => {
  let customDateUsed = false;
  let customFileUsed = false;
  let mapUsed = false;
  let setUsed = false;
  try {
    const serializedString = JSON.stringify(data, function(key, value) {
      const item = this[key];
      if (item instanceof Date) {
        customDateUsed = true;
        return `${DATE_TOKEN}${item.toISOString()}`;
      }
      if (item instanceof Map) {
        mapUsed = true;
        return value;
      }
      if (item instanceof Set) {
        setUsed = true;
        return value;
      }
      if (typeof item === "string" && staticBase !== null && item.startsWith(staticBase)) {
        customFileUsed = true;
        return `${FILE_TOKEN}${item.replace(staticBase + "/", "")}`;
      }
      return value;
    }, indent);
    return { serializedString, customDateUsed, customFileUsed, mapUsed, setUsed };
  } catch (err) {
    throw new Error("Could not serialize the passed input props to JSON: " + err.message);
  }
};
var deserializeJSONWithSpecialTypes = (data) => {
  return JSON.parse(data, (_, value) => {
    if (typeof value === "string" && value.startsWith(DATE_TOKEN)) {
      return new Date(value.replace(DATE_TOKEN, ""));
    }
    if (typeof value === "string" && value.startsWith(FILE_TOKEN)) {
      return `${window.remotion_staticBase}/${value.replace(FILE_TOKEN, "")}`;
    }
    return value;
  });
};
var serializeThenDeserialize = (props) => {
  return deserializeJSONWithSpecialTypes(serializeJSONWithSpecialTypes({
    data: props,
    indent: 2,
    staticBase: window.remotion_staticBase
  }).serializedString);
};
var serializeThenDeserializeInStudio = (props) => {
  if (getRemotionEnvironment().isStudio) {
    return serializeThenDeserialize(props);
  }
  return props;
};

// src/config/input-props.ts
var didWarnSSRImport = false;
var warnOnceSSRImport = () => {
  if (didWarnSSRImport) {
    return;
  }
  didWarnSSRImport = true;
  console.warn("Called `getInputProps()` on the server. This function is not available server-side and has returned an empty object.");
  console.warn("To hide this warning, don't call this function on the server:");
  console.warn("  typeof window === 'undefined' ? {} : getInputProps()");
};
var getInputProps = () => {
  if (typeof window === "undefined") {
    warnOnceSSRImport();
    return {};
  }
  if (getRemotionEnvironment().isPlayer) {
    throw new Error("You cannot call `getInputProps()` from a <Player>. Instead, the props are available as React props from component that you passed as `component` prop.");
  }
  const override = getInputPropsOverride();
  if (override) {
    return override;
  }
  if (typeof window === "undefined" || typeof window.remotion_inputProps === "undefined") {
    throw new Error("Cannot call `getInputProps()` - window.remotion_inputProps is not set. This API is only available if you are in the Studio, or while you are rendering server-side.");
  }
  const param = window.remotion_inputProps;
  if (!param) {
    return {};
  }
  const parsed = deserializeJSONWithSpecialTypes(param);
  return parsed;
};

// src/validation/validate-dimensions.ts
function validateDimension(amount, nameOfProp, location) {
  if (typeof amount !== "number") {
    throw new Error(`The "${nameOfProp}" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);
  }
  if (isNaN(amount)) {
    throw new TypeError(`The "${nameOfProp}" prop ${location} must not be NaN, but is NaN.`);
  }
  if (!Number.isFinite(amount)) {
    throw new TypeError(`The "${nameOfProp}" prop ${location} must be finite, but is ${amount}.`);
  }
  if (amount % 1 !== 0) {
    throw new TypeError(`The "${nameOfProp}" prop ${location} must be an integer, but is ${amount}.`);
  }
  if (amount <= 0) {
    throw new TypeError(`The "${nameOfProp}" prop ${location} must be positive, but got ${amount}.`);
  }
}

// src/validation/validate-duration-in-frames.ts
function validateDurationInFrames(durationInFrames, options) {
  const { allowFloats, component } = options;
  if (typeof durationInFrames === "undefined") {
    throw new Error(`The "durationInFrames" prop ${component} is missing.`);
  }
  if (typeof durationInFrames !== "number") {
    throw new Error(`The "durationInFrames" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);
  }
  if (durationInFrames <= 0) {
    throw new TypeError(`The "durationInFrames" prop ${component} must be positive, but got ${durationInFrames}.`);
  }
  if (!allowFloats && durationInFrames % 1 !== 0) {
    throw new TypeError(`The "durationInFrames" prop ${component} must be an integer, but got ${durationInFrames}.`);
  }
  if (!Number.isFinite(durationInFrames)) {
    throw new TypeError(`The "durationInFrames" prop ${component} must be finite, but got ${durationInFrames}.`);
  }
}

// src/validation/validate-fps.ts
function validateFps(fps, location, isGif) {
  if (typeof fps !== "number") {
    throw new Error(`"fps" must be a number, but you passed a value of type ${typeof fps} ${location}`);
  }
  if (!Number.isFinite(fps)) {
    throw new Error(`"fps" must be a finite, but you passed ${fps} ${location}`);
  }
  if (isNaN(fps)) {
    throw new Error(`"fps" must not be NaN, but got ${fps} ${location}`);
  }
  if (fps <= 0) {
    throw new TypeError(`"fps" must be positive, but got ${fps} ${location}`);
  }
  if (isGif && fps > 50) {
    throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);
  }
}

// src/ResolveCompositionConfig.tsx
var ResolveCompositionContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
var resolveCompositionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();
var needsResolution = (composition) => {
  return Boolean(composition.calculateMetadata);
};
var PROPS_UPDATED_EXTERNALLY = "remotion.propsUpdatedExternally";
var useResolvedVideoConfig = (preferredCompositionId) => {
  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ResolveCompositionContext);
  const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);
  const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);
  const currentComposition = canvasContent?.type === "composition" ? canvasContent.compositionId : null;
  const compositionId = preferredCompositionId ?? currentComposition;
  const composition = compositions.find((c) => c.id === compositionId);
  const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return composition ? allEditorProps[composition.id] ?? {} : {};
  }, [allEditorProps, composition]);
  const env = useRemotionEnvironment();
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    if (!composition) {
      return null;
    }
    if (currentCompositionMetadata) {
      return {
        type: "success",
        result: {
          ...currentCompositionMetadata,
          id: composition.id,
          defaultProps: composition.defaultProps ?? {}
        }
      };
    }
    if (!needsResolution(composition)) {
      validateDurationInFrames(composition.durationInFrames, {
        allowFloats: false,
        component: `in <Composition id="${composition.id}">`
      });
      validateFps(composition.fps, `in <Composition id="${composition.id}">`, false);
      validateDimension(composition.width, "width", `in <Composition id="${composition.id}">`);
      validateDimension(composition.height, "height", `in <Composition id="${composition.id}">`);
      return {
        type: "success",
        result: {
          width: composition.width,
          height: composition.height,
          fps: composition.fps,
          id: composition.id,
          durationInFrames: composition.durationInFrames,
          defaultProps: composition.defaultProps ?? {},
          props: {
            ...composition.defaultProps ?? {},
            ...selectedEditorProps ?? {},
            ...typeof window === "undefined" || env.isPlayer || !window.remotion_inputProps ? {} : getInputProps() ?? {}
          },
          defaultCodec: null,
          defaultOutName: null,
          defaultVideoImageFormat: null,
          defaultPixelFormat: null,
          defaultProResProfile: null
        }
      };
    }
    if (!context) {
      return null;
    }
    if (!context[composition.id]) {
      return null;
    }
    return context[composition.id];
  }, [
    composition,
    context,
    currentCompositionMetadata,
    selectedEditorProps,
    env.isPlayer
  ]);
};

// src/use-video.ts
var useVideo = () => {
  const { canvasContent, compositions, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);
  const selected = compositions.find((c) => {
    return canvasContent?.type === "composition" && c.id === canvasContent.compositionId;
  });
  const resolved = useResolvedVideoConfig(selected?.id ?? null);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    if (!resolved) {
      return null;
    }
    if (resolved.type === "error") {
      return null;
    }
    if (resolved.type === "loading") {
      return null;
    }
    if (!selected) {
      return null;
    }
    return {
      ...resolved.result,
      defaultProps: selected.defaultProps ?? {},
      id: selected.id,
      ...currentCompositionMetadata ?? {},
      component: selected.component
    };
  }, [currentCompositionMetadata, resolved, selected]);
};

// src/timeline-position-state.ts
var makeKey = () => {
  return `remotion.time-all`;
};
var persistCurrentFrame = (time) => {
  localStorage.setItem(makeKey(), JSON.stringify(time));
};
var getInitialFrameState = () => {
  const item = localStorage.getItem(makeKey()) ?? "{}";
  const obj = JSON.parse(item);
  return obj;
};
var getFrameForComposition = (composition) => {
  const item = localStorage.getItem(makeKey()) ?? "{}";
  const obj = JSON.parse(item);
  if (obj[composition] !== undefined) {
    return Number(obj[composition]);
  }
  if (typeof window === "undefined") {
    return 0;
  }
  return window.remotion_initialFrame ?? 0;
};
var useTimelinePosition = () => {
  const videoConfig = useVideo();
  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);
  const env = useRemotionEnvironment();
  if (!videoConfig) {
    return typeof window === "undefined" ? 0 : window.remotion_initialFrame ?? 0;
  }
  const unclamped = state.frame[videoConfig.id] ?? (env.isPlayer ? 0 : getFrameForComposition(videoConfig.id));
  return Math.min(videoConfig.durationInFrames - 1, unclamped);
};
var useTimelineSetFrame = () => {
  const { setFrame } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);
  return setFrame;
};
var usePlayingState = () => {
  const { playing, imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);
  const { setPlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [playing, setPlaying, imperativePlaying], [imperativePlaying, playing, setPlaying]);
};

// src/use-delay-render.tsx


// src/cancel-render.ts
var getErrorStackWithMessage = (error) => {
  const stack = error.stack ?? "";
  return stack.startsWith("Error:") ? stack : `${error.message}
${stack}`;
};
var isErrorLike = (err) => {
  if (err instanceof Error) {
    return true;
  }
  if (err === null) {
    return false;
  }
  if (typeof err !== "object") {
    return false;
  }
  if (!("stack" in err)) {
    return false;
  }
  if (typeof err.stack !== "string") {
    return false;
  }
  if (!("message" in err)) {
    return false;
  }
  if (typeof err.message !== "string") {
    return false;
  }
  return true;
};
function cancelRenderInternal(scope, err) {
  let error;
  if (isErrorLike(err)) {
    error = err;
    if (!error.stack) {
      error.stack = new Error(error.message).stack;
    }
  } else if (typeof err === "string") {
    error = Error(err);
  } else {
    error = Error("Rendering was cancelled");
  }
  if (scope) {
    scope.remotion_cancelledError = getErrorStackWithMessage(error);
  }
  throw error;
}
function cancelRender(err) {
  return cancelRenderInternal(typeof window !== "undefined" ? window : undefined, err);
}

// src/log.ts
var logLevels = ["trace", "verbose", "info", "warn", "error"];
var getNumberForLogLevel = (level) => {
  return logLevels.indexOf(level);
};
var isEqualOrBelowLogLevel = (currentLevel, level) => {
  return getNumberForLogLevel(currentLevel) <= getNumberForLogLevel(level);
};
var transformArgs = ({
  args,
  logLevel,
  tag
}) => {
  const arr = [...args];
  if (getRemotionEnvironment().isRendering && !getRemotionEnvironment().isClientSideRendering) {
    arr.unshift(Symbol.for(`__remotion_level_${logLevel}`));
  }
  if (tag && getRemotionEnvironment().isRendering && !getRemotionEnvironment().isClientSideRendering) {
    arr.unshift(Symbol.for(`__remotion_tag_${tag}`));
  }
  return arr;
};
var verbose = (options, ...args) => {
  if (isEqualOrBelowLogLevel(options.logLevel, "verbose")) {
    return console.debug(...transformArgs({ args, logLevel: "verbose", tag: options.tag }));
  }
};
var trace = (options, ...args) => {
  if (isEqualOrBelowLogLevel(options.logLevel, "trace")) {
    return console.debug(...transformArgs({ args, logLevel: "trace", tag: options.tag }));
  }
};
var info = (options, ...args) => {
  if (isEqualOrBelowLogLevel(options.logLevel, "info")) {
    return console.log(...transformArgs({ args, logLevel: "info", tag: options.tag }));
  }
};
var warn = (options, ...args) => {
  if (isEqualOrBelowLogLevel(options.logLevel, "warn")) {
    return console.warn(...transformArgs({ args, logLevel: "warn", tag: options.tag }));
  }
};
var error = (options, ...args) => {
  return console.error(...transformArgs({ args, logLevel: "error", tag: options.tag }));
};
var Log = {
  trace,
  verbose,
  info,
  warn,
  error
};

// src/delay-render.ts
if (typeof window !== "undefined") {
  window.remotion_renderReady = false;
  if (!window.remotion_delayRenderTimeouts) {
    window.remotion_delayRenderTimeouts = {};
  }
  window.remotion_delayRenderHandles = [];
}
var DELAY_RENDER_CALLSTACK_TOKEN = "The delayRender was called:";
var DELAY_RENDER_RETRIES_LEFT = "Retries left: ";
var DELAY_RENDER_RETRY_TOKEN = "- Rendering the frame will be retried.";
var DELAY_RENDER_CLEAR_TOKEN = "handle was cleared after";
var defaultTimeout = 30000;
var delayRenderInternal = ({
  scope,
  environment,
  label,
  options
}) => {
  if (typeof label !== "string" && label !== null) {
    throw new Error("The label parameter of delayRender() must be a string or undefined, got: " + JSON.stringify(label));
  }
  const handle = Math.random();
  scope.remotion_delayRenderHandles.push(handle);
  const called = Error().stack?.replace(/^Error/g, "") ?? "";
  if (environment.isRendering) {
    const timeoutToUse = (options?.timeoutInMilliseconds ?? scope.remotion_puppeteerTimeout ?? defaultTimeout) - 2000;
    const retriesLeft = (options?.retries ?? 0) - (scope.remotion_attempt - 1);
    scope.remotion_delayRenderTimeouts[handle] = {
      label: label ?? null,
      startTime: Date.now(),
      timeout: setTimeout(() => {
        const message = [
          `A delayRender()`,
          label ? `"${label}"` : null,
          `was called but not cleared after ${timeoutToUse}ms. See https://remotion.dev/docs/timeout for help.`,
          retriesLeft > 0 ? DELAY_RENDER_RETRIES_LEFT + retriesLeft : null,
          retriesLeft > 0 ? DELAY_RENDER_RETRY_TOKEN : null,
          DELAY_RENDER_CALLSTACK_TOKEN,
          called
        ].filter(truthy).join(" ");
        if (environment.isClientSideRendering) {
          scope.remotion_cancelledError = getErrorStackWithMessage(Error(message));
        } else {
          cancelRenderInternal(scope, Error(message));
        }
      }, timeoutToUse)
    };
  }
  scope.remotion_renderReady = false;
  return handle;
};
var delayRender = (label, options) => {
  if (typeof window === "undefined") {
    return Math.random();
  }
  return delayRenderInternal({
    scope: window,
    environment: getRemotionEnvironment(),
    label: label ?? null,
    options: options ?? {}
  });
};
var continueRenderInternal = ({
  scope,
  handle,
  environment,
  logLevel
}) => {
  if (typeof handle === "undefined") {
    throw new TypeError("The continueRender() method must be called with a parameter that is the return value of delayRender(). No value was passed.");
  }
  if (typeof handle !== "number") {
    throw new TypeError("The parameter passed into continueRender() must be the return value of delayRender() which is a number. Got: " + JSON.stringify(handle));
  }
  scope.remotion_delayRenderHandles = scope.remotion_delayRenderHandles.filter((h) => {
    if (h === handle) {
      if (environment.isRendering && scope !== undefined) {
        if (!scope.remotion_delayRenderTimeouts[handle]) {
          return false;
        }
        const { label, startTime, timeout } = scope.remotion_delayRenderTimeouts[handle];
        clearTimeout(timeout);
        const message = [
          label ? `"${label}"` : "A handle",
          DELAY_RENDER_CLEAR_TOKEN,
          `${Date.now() - startTime}ms`
        ].filter(truthy).join(" ");
        Log.verbose({ logLevel, tag: "delayRender()" }, message);
        delete scope.remotion_delayRenderTimeouts[handle];
      }
      return false;
    }
    return true;
  });
  if (scope.remotion_delayRenderHandles.length === 0) {
    scope.remotion_renderReady = true;
  }
};
var continueRender = (handle) => {
  if (typeof window === "undefined") {
    return;
  }
  continueRenderInternal({
    scope: window,
    handle,
    environment: getRemotionEnvironment(),
    logLevel: window.remotion_logLevel ?? "info"
  });
};

// src/log-level-context.tsx


var LogLevelContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  logLevel: "info",
  mountTime: 0
});
var useLogLevel = () => {
  const { logLevel } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);
  if (logLevel === null) {
    throw new Error("useLogLevel must be used within a LogLevelProvider");
  }
  return logLevel;
};
var useMountTime = () => {
  const { mountTime } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);
  if (mountTime === null) {
    throw new Error("useMountTime must be used within a LogLevelProvider");
  }
  return mountTime;
};

// src/use-delay-render.tsx
var DelayRenderContextType = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
var useDelayRender = () => {
  const environment = useRemotionEnvironment();
  const scope = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DelayRenderContextType) ?? (typeof window !== "undefined" ? window : undefined);
  const logLevel = useLogLevel();
  const delayRender2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((label, options) => {
    if (!scope) {
      return Math.random();
    }
    return delayRenderInternal({
      scope,
      environment,
      label: label ?? null,
      options: options ?? {}
    });
  }, [environment, scope]);
  const continueRender2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((handle) => {
    if (!scope) {
      return;
    }
    continueRenderInternal({
      scope,
      handle,
      environment,
      logLevel
    });
  }, [environment, logLevel, scope]);
  const cancelRender2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((err) => {
    return cancelRenderInternal(scope ?? (typeof window !== "undefined" ? window : undefined), err);
  }, [scope]);
  return { delayRender: delayRender2, continueRender: continueRender2, cancelRender: cancelRender2 };
};

// src/TimelineContext.tsx

var SetTimelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  setFrame: () => {
    throw new Error("default");
  },
  setPlaying: () => {
    throw new Error("default");
  }
});
var TimelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  frame: {},
  playing: false,
  playbackRate: 1,
  rootId: "",
  imperativePlaying: {
    current: false
  },
  setPlaybackRate: () => {
    throw new Error("default");
  },
  audioAndVideoTags: { current: [] }
});
var TimelineContextProvider = ({ children, frameState }) => {
  const [playing, setPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const imperativePlaying = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
  const [playbackRate, setPlaybackRate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);
  const audioAndVideoTags = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);
  const [remotionRootId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(random(null)));
  const [_frame, setFrame] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => getInitialFrameState());
  const frame = frameState ?? _frame;
  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();
  if (typeof window !== "undefined") {
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
      window.remotion_setFrame = (f, composition, attempt) => {
        window.remotion_attempt = attempt;
        const id = delayRender2(`Setting the current frame to ${f}`);
        let asyncUpdate = true;
        setFrame((s) => {
          const currentFrame = s[composition] ?? window.remotion_initialFrame;
          if (currentFrame === f) {
            asyncUpdate = false;
            return s;
          }
          return {
            ...s,
            [composition]: f
          };
        });
        if (asyncUpdate) {
          requestAnimationFrame(() => continueRender2(id));
        } else {
          continueRender2(id);
        }
      };
      window.remotion_isPlayer = false;
    }, [continueRender2, delayRender2]);
  }
  const timelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      frame,
      playing,
      imperativePlaying,
      rootId: remotionRootId,
      playbackRate,
      setPlaybackRate,
      audioAndVideoTags
    };
  }, [frame, playbackRate, playing, remotionRootId]);
  const setTimelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      setFrame,
      setPlaying
    };
  }, []);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {
    value: timelineContextValue,
    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {
      value: setTimelineContextValue,
      children
    })
  });
};

// src/nonce.ts

var NonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  getNonce: () => 0
});
var useNonce = () => {
  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);
  const [nonce, setNonce] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => context.getNonce());
  const lastContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(context);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (lastContext.current === context) {
      return;
    }
    lastContext.current = context;
    setNonce(context.getNonce);
  }, [context]);
  return nonce;
};

// src/use-video-config.ts


// src/CanUseRemotionHooks.tsx


var CanUseRemotionHooks = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);
var CanUseRemotionHooksProvider = ({ children }) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {
    value: true,
    children
  });
};

// src/use-unsafe-video-config.ts

var useUnsafeVideoConfig = () => {
  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);
  const ctxWidth = context?.width ?? null;
  const ctxHeight = context?.height ?? null;
  const ctxDuration = context?.durationInFrames ?? null;
  const video = useVideo();
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    if (!video) {
      return null;
    }
    const {
      id,
      durationInFrames,
      fps,
      height,
      width,
      defaultProps,
      props,
      defaultCodec,
      defaultOutName,
      defaultVideoImageFormat,
      defaultPixelFormat,
      defaultProResProfile
    } = video;
    return {
      id,
      width: ctxWidth ?? width,
      height: ctxHeight ?? height,
      fps,
      durationInFrames: ctxDuration ?? durationInFrames,
      defaultProps,
      props,
      defaultCodec,
      defaultOutName,
      defaultVideoImageFormat,
      defaultPixelFormat,
      defaultProResProfile
    };
  }, [ctxDuration, ctxHeight, ctxWidth, video]);
};

// src/use-video-config.ts
var useVideoConfig = () => {
  const videoConfig = useUnsafeVideoConfig();
  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);
  const isPlayer = useIsPlayer();
  if (!videoConfig) {
    if (typeof window !== "undefined" && window.remotion_isPlayer || isPlayer) {
      throw new Error([
        "No video config found. Likely reasons:",
        "- You are probably calling useVideoConfig() from outside the component passed to <Player />. See https://www.remotion.dev/docs/player/examples for how to set up the Player correctly.",
        "- You have multiple versions of Remotion installed which causes the React context to get lost."
      ].join("-"));
    }
    throw new Error("No video config found. You are probably calling useVideoConfig() from a component which has not been registered as a <Composition />. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions for more information.");
  }
  if (!context) {
    throw new Error("Called useVideoConfig() outside a Remotion composition.");
  }
  return videoConfig;
};

// src/freeze.tsx


// src/use-current-frame.ts

var useCurrentFrame = () => {
  const canUseRemotionHooks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);
  const env = useRemotionEnvironment();
  if (!canUseRemotionHooks) {
    if (env.isPlayer) {
      throw new Error(`useCurrentFrame can only be called inside a component that was passed to <Player>. See: https://www.remotion.dev/docs/player/examples`);
    }
    throw new Error(`useCurrentFrame() can only be called inside a component that was registered as a composition. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions`);
  }
  const frame = useTimelinePosition();
  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);
  const contextOffset = context ? context.cumulatedFrom + context.relativeFrom : 0;
  return frame - contextOffset;
};

// src/freeze.tsx

var Freeze = ({
  frame: frameToFreeze,
  children,
  active = true
}) => {
  const frame = useCurrentFrame();
  const videoConfig = useVideoConfig();
  if (typeof frameToFreeze === "undefined") {
    throw new Error(`The <Freeze /> component requires a 'frame' prop, but none was passed.`);
  }
  if (typeof frameToFreeze !== "number") {
    throw new Error(`The 'frame' prop of <Freeze /> must be a number, but is of type ${typeof frameToFreeze}`);
  }
  if (Number.isNaN(frameToFreeze)) {
    throw new Error(`The 'frame' prop of <Freeze /> must be a real number, but it is NaN.`);
  }
  if (!Number.isFinite(frameToFreeze)) {
    throw new Error(`The 'frame' prop of <Freeze /> must be a finite number, but it is ${frameToFreeze}.`);
  }
  const isActive = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    if (typeof active === "boolean") {
      return active;
    }
    if (typeof active === "function") {
      return active(frame);
    }
  }, [active, frame]);
  const timelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);
  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);
  const relativeFrom = sequenceContext?.relativeFrom ?? 0;
  const timelineValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    if (!isActive) {
      return timelineContext;
    }
    return {
      ...timelineContext,
      playing: false,
      imperativePlaying: {
        current: false
      },
      frame: {
        [videoConfig.id]: frameToFreeze + relativeFrom
      }
    };
  }, [isActive, timelineContext, videoConfig.id, frameToFreeze, relativeFrom]);
  const newSequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    if (!sequenceContext) {
      return null;
    }
    if (!isActive) {
      return sequenceContext;
    }
    return {
      ...sequenceContext,
      cumulatedFrom: 0
    };
  }, [sequenceContext, isActive]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {
    value: timelineValue,
    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {
      value: newSequenceContext,
      children
    })
  });
};

// src/Sequence.tsx

var RegularSequenceRefForwardingFunction = ({
  from = 0,
  durationInFrames = Infinity,
  children,
  name,
  height,
  width,
  showInTimeline = true,
  _remotionInternalLoopDisplay: loopDisplay,
  _remotionInternalStack: stack,
  _remotionInternalPremountDisplay: premountDisplay,
  _remotionInternalPostmountDisplay: postmountDisplay,
  ...other
}, ref) => {
  const { layout = "absolute-fill" } = other;
  const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(Math.random()));
  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);
  const { rootId } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);
  const cumulatedFrom = parentSequence ? parentSequence.cumulatedFrom + parentSequence.relativeFrom : 0;
  const nonce = useNonce();
  if (layout !== "absolute-fill" && layout !== "none") {
    throw new TypeError(`The layout prop of <Sequence /> expects either "absolute-fill" or "none", but you passed: ${layout}`);
  }
  if (layout === "none" && typeof other.style !== "undefined") {
    throw new TypeError('If layout="none", you may not pass a style.');
  }
  if (typeof durationInFrames !== "number") {
    throw new TypeError(`You passed to durationInFrames an argument of type ${typeof durationInFrames}, but it must be a number.`);
  }
  if (durationInFrames <= 0) {
    throw new TypeError(`durationInFrames must be positive, but got ${durationInFrames}`);
  }
  if (typeof from !== "number") {
    throw new TypeError(`You passed to the "from" props of your <Sequence> an argument of type ${typeof from}, but it must be a number.`);
  }
  if (!Number.isFinite(from)) {
    throw new TypeError(`The "from" prop of a sequence must be finite, but got ${from}.`);
  }
  const absoluteFrame = useTimelinePosition();
  const videoConfig = useVideoConfig();
  const parentSequenceDuration = parentSequence ? Math.min(parentSequence.durationInFrames - from, durationInFrames) : durationInFrames;
  const actualDurationInFrames = Math.max(0, Math.min(videoConfig.durationInFrames - from, parentSequenceDuration));
  const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);
  const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);
  const premounting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return parentSequence?.premounting || Boolean(other._remotionInternalIsPremounting);
  }, [other._remotionInternalIsPremounting, parentSequence?.premounting]);
  const postmounting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return parentSequence?.postmounting || Boolean(other._remotionInternalIsPostmounting);
  }, [other._remotionInternalIsPostmounting, parentSequence?.postmounting]);
  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      cumulatedFrom,
      relativeFrom: from,
      durationInFrames: actualDurationInFrames,
      parentFrom: parentSequence?.relativeFrom ?? 0,
      id,
      height: height ?? parentSequence?.height ?? null,
      width: width ?? parentSequence?.width ?? null,
      premounting,
      postmounting,
      premountDisplay: premountDisplay ?? null,
      postmountDisplay: postmountDisplay ?? null
    };
  }, [
    cumulatedFrom,
    from,
    actualDurationInFrames,
    parentSequence,
    id,
    height,
    width,
    premounting,
    postmounting,
    premountDisplay,
    postmountDisplay
  ]);
  const timelineClipName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return name ?? "";
  }, [name]);
  const env = useRemotionEnvironment();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!env.isStudio) {
      return;
    }
    registerSequence({
      from,
      duration: actualDurationInFrames,
      id,
      displayName: timelineClipName,
      parent: parentSequence?.id ?? null,
      type: "sequence",
      rootId,
      showInTimeline,
      nonce,
      loopDisplay,
      stack: stack ?? null,
      premountDisplay: premountDisplay ?? null,
      postmountDisplay: postmountDisplay ?? null
    });
    return () => {
      unregisterSequence(id);
    };
  }, [
    durationInFrames,
    id,
    name,
    registerSequence,
    timelineClipName,
    unregisterSequence,
    parentSequence?.id,
    actualDurationInFrames,
    rootId,
    from,
    showInTimeline,
    nonce,
    loopDisplay,
    stack,
    premountDisplay,
    postmountDisplay,
    env.isStudio
  ]);
  const endThreshold = Math.ceil(cumulatedFrom + from + durationInFrames - 1);
  const content = absoluteFrame < cumulatedFrom + from ? null : absoluteFrame > endThreshold ? null : children;
  const styleIfThere = other.layout === "none" ? undefined : other.style;
  const defaultStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      flexDirection: undefined,
      ...width ? { width } : {},
      ...height ? { height } : {},
      ...styleIfThere ?? {}
    };
  }, [height, styleIfThere, width]);
  if (ref !== null && layout === "none") {
    throw new TypeError('It is not supported to pass both a `ref` and `layout="none"` to <Sequence />.');
  }
  const isSequenceHidden = hidden[id] ?? false;
  if (isSequenceHidden) {
    return null;
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {
    value: contextValue,
    children: content === null ? null : other.layout === "none" ? content : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AbsoluteFill, {
      ref,
      style: defaultStyle,
      className: other.className,
      children: content
    })
  });
};
var RegularSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(RegularSequenceRefForwardingFunction);
var PremountedPostmountedSequenceRefForwardingFunction = (props, ref) => {
  const frame = useCurrentFrame();
  if (props.layout === "none") {
    throw new Error('`<Sequence>` with `premountFor` and `postmountFor` props does not support layout="none"');
  }
  const {
    style: passedStyle,
    from = 0,
    durationInFrames = Infinity,
    premountFor = 0,
    postmountFor = 0,
    styleWhilePremounted,
    styleWhilePostmounted,
    ...otherProps
  } = props;
  const endThreshold = Math.ceil(from + durationInFrames - 1);
  const premountingActive = frame < from && frame >= from - premountFor;
  const postmountingActive = frame > endThreshold && frame <= endThreshold + postmountFor;
  const freezeFrame = premountingActive ? from : postmountingActive ? from + durationInFrames - 1 : 0;
  const isFreezingActive = premountingActive || postmountingActive;
  const style = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      ...passedStyle,
      opacity: premountingActive || postmountingActive ? 0 : 1,
      pointerEvents: premountingActive || postmountingActive ? "none" : passedStyle?.pointerEvents ?? undefined,
      ...premountingActive ? styleWhilePremounted : {},
      ...postmountingActive ? styleWhilePostmounted : {}
    };
  }, [
    passedStyle,
    premountingActive,
    postmountingActive,
    styleWhilePremounted,
    styleWhilePostmounted
  ]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Freeze, {
    frame: freezeFrame,
    active: isFreezingActive,
    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {
      ref,
      from,
      durationInFrames,
      style,
      _remotionInternalPremountDisplay: premountFor,
      _remotionInternalPostmountDisplay: postmountFor,
      _remotionInternalIsPremounting: premountingActive,
      _remotionInternalIsPostmounting: postmountingActive,
      ...otherProps
    })
  });
};
var PremountedPostmountedSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(PremountedPostmountedSequenceRefForwardingFunction);
var SequenceRefForwardingFunction = (props, ref) => {
  const env = useRemotionEnvironment();
  if (props.layout !== "none" && !env.isRendering) {
    if (props.premountFor || props.postmountFor) {
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PremountedPostmountedSequence, {
        ...props,
        ref
      });
    }
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RegularSequence, {
    ...props,
    ref
  });
};
var Sequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SequenceRefForwardingFunction);
// src/animated-image/AnimatedImage.tsx


// src/animated-image/canvas.tsx


var calcArgs = (fit, frameSize, canvasSize) => {
  switch (fit) {
    case "fill": {
      return [
        0,
        0,
        frameSize.width,
        frameSize.height,
        0,
        0,
        canvasSize.width,
        canvasSize.height
      ];
    }
    case "contain": {
      const ratio = Math.min(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);
      const centerX = (canvasSize.width - frameSize.width * ratio) / 2;
      const centerY = (canvasSize.height - frameSize.height * ratio) / 2;
      return [
        0,
        0,
        frameSize.width,
        frameSize.height,
        centerX,
        centerY,
        frameSize.width * ratio,
        frameSize.height * ratio
      ];
    }
    case "cover": {
      const ratio = Math.max(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);
      const centerX = (canvasSize.width - frameSize.width * ratio) / 2;
      const centerY = (canvasSize.height - frameSize.height * ratio) / 2;
      return [
        0,
        0,
        frameSize.width,
        frameSize.height,
        centerX,
        centerY,
        frameSize.width * ratio,
        frameSize.height * ratio
      ];
    }
    default:
      throw new Error("Unknown fit: " + fit);
  }
};
var CanvasRefForwardingFunction = ({ width, height, fit, className, style }, ref) => {
  const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const draw = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((imageData) => {
    const canvas = canvasRef.current;
    const canvasWidth = width ?? imageData.displayWidth;
    const canvasHeight = height ?? imageData.displayHeight;
    if (!canvas) {
      throw new Error("Canvas ref is not set");
    }
    const ctx = canvasRef.current?.getContext("2d");
    if (!ctx) {
      throw new Error("Could not get 2d context");
    }
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    ctx.drawImage(imageData, ...calcArgs(fit, {
      height: imageData.displayHeight,
      width: imageData.displayWidth
    }, {
      width: canvasWidth,
      height: canvasHeight
    }));
  }, [fit, height, width]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {
    return {
      draw,
      getCanvas: () => {
        if (!canvasRef.current) {
          throw new Error("Canvas ref is not set");
        }
        return canvasRef.current;
      },
      clear: () => {
        const ctx = canvasRef.current?.getContext("2d");
        if (!ctx) {
          throw new Error("Could not get 2d context");
        }
        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
      }
    };
  }, [draw]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("canvas", {
    ref: canvasRef,
    className,
    style
  });
};
var Canvas = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(CanvasRefForwardingFunction);

// src/animated-image/decode-image.ts
var CACHE_SIZE = 5;
var getActualTime = ({
  loopBehavior,
  durationFound,
  timeInSec
}) => {
  return loopBehavior === "loop" ? durationFound ? timeInSec % durationFound : timeInSec : Math.min(timeInSec, durationFound || Infinity);
};
var decodeImage = async ({
  resolvedSrc,
  signal,
  currentTime,
  initialLoopBehavior
}) => {
  if (typeof ImageDecoder === "undefined") {
    throw new Error("Your browser does not support the WebCodecs ImageDecoder API.");
  }
  const res = await fetch(resolvedSrc, { signal });
  const { body } = res;
  if (!body) {
    throw new Error("Got no body");
  }
  const decoder = new ImageDecoder({
    data: body,
    type: res.headers.get("Content-Type") || "image/gif"
  });
  await decoder.completed;
  const { selectedTrack } = decoder.tracks;
  if (!selectedTrack) {
    throw new Error("No selected track");
  }
  const cache = [];
  let durationFound = null;
  const getFrameByIndex = async (frameIndex) => {
    const foundInCache = cache.find((c) => c.frameIndex === frameIndex);
    if (foundInCache && foundInCache.frame) {
      return foundInCache;
    }
    const frame = await decoder.decode({
      frameIndex,
      completeFramesOnly: true
    });
    if (foundInCache) {
      foundInCache.frame = frame.image;
    } else {
      cache.push({
        frame: frame.image,
        frameIndex,
        timeInSeconds: frame.image.timestamp / 1e6
      });
    }
    return {
      frame: frame.image,
      frameIndex,
      timeInSeconds: frame.image.timestamp / 1e6
    };
  };
  const clearCache = (closeToTimeInSec) => {
    const itemsInCache = cache.filter((c) => c.frame);
    const sortByClosestToCurrentTime = itemsInCache.sort((a, b) => {
      const aDiff = Math.abs(a.timeInSeconds - closeToTimeInSec);
      const bDiff = Math.abs(b.timeInSeconds - closeToTimeInSec);
      return aDiff - bDiff;
    });
    for (let i = 0;i < sortByClosestToCurrentTime.length; i++) {
      if (i < CACHE_SIZE) {
        continue;
      }
      const item = sortByClosestToCurrentTime[i];
      item.frame = null;
    }
  };
  const ensureFrameBeforeAndAfter = async ({
    timeInSec,
    loopBehavior
  }) => {
    const actualTimeInSec = getActualTime({
      durationFound,
      loopBehavior,
      timeInSec
    });
    const framesBefore = cache.filter((c) => c.timeInSeconds <= actualTimeInSec);
    const biggestIndex = framesBefore.map((c) => c.frameIndex).reduce((a, b) => Math.max(a, b), 0);
    let i = biggestIndex;
    while (true) {
      const f = await getFrameByIndex(i);
      i++;
      if (!f.frame) {
        throw new Error("No frame found");
      }
      if (!f.frame.duration) {
        break;
      }
      if (i === selectedTrack.frameCount && durationFound === null) {
        const duration = (f.frame.timestamp + f.frame.duration) / 1e6;
        durationFound = duration;
      }
      if (f.timeInSeconds > actualTimeInSec || i === selectedTrack.frameCount) {
        break;
      }
    }
    if (selectedTrack.frameCount - biggestIndex < 3 && loopBehavior === "loop") {
      await getFrameByIndex(0);
    }
    clearCache(actualTimeInSec);
  };
  await ensureFrameBeforeAndAfter({
    timeInSec: currentTime,
    loopBehavior: initialLoopBehavior
  });
  await ensureFrameBeforeAndAfter({
    timeInSec: currentTime,
    loopBehavior: initialLoopBehavior
  });
  const getFrame = async (timeInSec, loopBehavior) => {
    if (durationFound !== null && timeInSec > durationFound && loopBehavior === "clear-after-finish") {
      return null;
    }
    const actualTimeInSec = getActualTime({
      loopBehavior,
      durationFound,
      timeInSec
    });
    await ensureFrameBeforeAndAfter({ timeInSec: actualTimeInSec, loopBehavior });
    const itemsInCache = cache.filter((c) => c.frame);
    const closest = itemsInCache.reduce((a, b) => {
      const aDiff = Math.abs(a.timeInSeconds - actualTimeInSec);
      const bDiff = Math.abs(b.timeInSeconds - actualTimeInSec);
      return aDiff < bDiff ? a : b;
    });
    if (!closest.frame) {
      throw new Error("No frame found");
    }
    return closest;
  };
  return {
    getFrame,
    frameCount: selectedTrack.frameCount
  };
};

// src/animated-image/resolve-image-source.tsx
var resolveAnimatedImageSource = (src) => {
  if (typeof window === "undefined") {
    return src;
  }
  return new URL(src, window.origin).href;
};

// src/animated-image/AnimatedImage.tsx

var AnimatedImage = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({
  src,
  width,
  height,
  onError,
  loopBehavior = "loop",
  playbackRate = 1,
  fit = "fill",
  ...props
}, canvasRef) => {
  const mountState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ isMounted: true });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const { current } = mountState;
    current.isMounted = true;
    return () => {
      current.isMounted = false;
    };
  }, []);
  const resolvedSrc = resolveAnimatedImageSource(src);
  const [imageDecoder, setImageDecoder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);
  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();
  const [decodeHandle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => delayRender2(`Rendering <AnimatedImage/> with src="${resolvedSrc}"`));
  const frame = useCurrentFrame();
  const { fps } = useVideoConfig();
  const currentTime = frame / playbackRate / fps;
  const currentTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(currentTime);
  currentTimeRef.current = currentTime;
  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(canvasRef, () => {
    const c = ref.current?.getCanvas();
    if (!c) {
      throw new Error("Canvas ref is not set");
    }
    return c;
  }, []);
  const [initialLoopBehavior] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => loopBehavior);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const controller = new AbortController;
    decodeImage({
      resolvedSrc,
      signal: controller.signal,
      currentTime: currentTimeRef.current,
      initialLoopBehavior
    }).then((d) => {
      setImageDecoder(d);
      continueRender2(decodeHandle);
    }).catch((err) => {
      if (err.name === "AbortError") {
        continueRender2(decodeHandle);
        return;
      }
      if (onError) {
        onError?.(err);
        continueRender2(decodeHandle);
      } else {
        cancelRender(err);
      }
    });
    return () => {
      controller.abort();
    };
  }, [
    resolvedSrc,
    decodeHandle,
    onError,
    initialLoopBehavior,
    continueRender2
  ]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
    if (!imageDecoder) {
      return;
    }
    const delay = delayRender2(`Rendering frame at ${currentTime} of <AnimatedImage src="${src}"/>`);
    imageDecoder.getFrame(currentTime, loopBehavior).then((videoFrame) => {
      if (mountState.current.isMounted) {
        if (videoFrame === null) {
          ref.current?.clear();
        } else {
          ref.current?.draw(videoFrame.frame);
        }
      }
      continueRender2(delay);
    }).catch((err) => {
      if (onError) {
        onError(err);
        continueRender2(delay);
      } else {
        cancelRender(err);
      }
    });
  }, [
    currentTime,
    imageDecoder,
    loopBehavior,
    onError,
    src,
    continueRender2,
    delayRender2
  ]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Canvas, {
    ref,
    width,
    height,
    fit,
    ...props
  });
});
// src/Artifact.tsx


// src/RenderAssetManager.tsx


// src/validation/validate-artifact.ts
var validateArtifactFilename = (filename) => {
  if (typeof filename !== "string") {
    throw new TypeError(`The "filename" must be a string, but you passed a value of type ${typeof filename}`);
  }
  if (filename.trim() === "") {
    throw new Error("The `filename` must not be empty");
  }
  if (!filename.match(/^([0-9a-zA-Z-!_.*'()/:&$@=;+,?]+)/g)) {
    throw new Error('The `filename` must match "/^([0-9a-zA-Z-!_.*\'()/:&$@=;+,?]+)/g". Use forward slashes only, even on Windows.');
  }
};
var validateContent = (content) => {
  if (typeof content !== "string" && !(content instanceof Uint8Array)) {
    throw new TypeError(`The "content" must be a string or Uint8Array, but you passed a value of type ${typeof content}`);
  }
  if (typeof content === "string" && content.trim() === "") {
    throw new Error("The `content` must not be empty");
  }
};
var validateRenderAsset = (artifact) => {
  if (artifact.type !== "artifact") {
    return;
  }
  validateArtifactFilename(artifact.filename);
  if (artifact.contentType === "thumbnail") {
    return;
  }
  validateContent(artifact.content);
};

// src/RenderAssetManager.tsx

var RenderAssetManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  registerRenderAsset: () => {
    return;
  },
  unregisterRenderAsset: () => {
    return;
  },
  renderAssets: []
});
var RenderAssetManagerProvider = ({ children, collectAssets }) => {
  const [renderAssets, setRenderAssets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
  const renderAssetsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);
  const registerRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((renderAsset) => {
    validateRenderAsset(renderAsset);
    renderAssetsRef.current = [...renderAssetsRef.current, renderAsset];
    setRenderAssets(renderAssetsRef.current);
  }, []);
  if (collectAssets) {
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(collectAssets, () => {
      return {
        collectAssets: () => {
          const assets = renderAssetsRef.current;
          renderAssetsRef.current = [];
          setRenderAssets([]);
          return assets;
        }
      };
    }, []);
  }
  const unregisterRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {
    renderAssetsRef.current = renderAssetsRef.current.filter((a) => a.id !== id);
    setRenderAssets(renderAssetsRef.current);
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
    if (typeof window !== "undefined") {
      window.remotion_collectAssets = () => {
        const assets = renderAssetsRef.current;
        renderAssetsRef.current = [];
        setRenderAssets([]);
        return assets;
      };
    }
  }, []);
  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      registerRenderAsset,
      unregisterRenderAsset,
      renderAssets
    };
  }, [renderAssets, registerRenderAsset, unregisterRenderAsset]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {
    value: contextValue,
    children
  });
};

// src/Artifact.tsx
var ArtifactThumbnail = Symbol("Thumbnail");
var Artifact = ({ filename, content, downloadBehavior }) => {
  const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);
  const env = useRemotionEnvironment();
  const frame = useCurrentFrame();
  const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {
    return String(Math.random());
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
    if (!env.isRendering) {
      return;
    }
    if (content instanceof Uint8Array) {
      registerRenderAsset({
        type: "artifact",
        id,
        content: btoa(new TextDecoder("utf8").decode(content)),
        filename,
        frame,
        contentType: "binary",
        downloadBehavior: downloadBehavior ?? null
      });
    } else if (content === ArtifactThumbnail) {
      registerRenderAsset({
        type: "artifact",
        id,
        filename,
        frame,
        contentType: "thumbnail",
        downloadBehavior: downloadBehavior ?? null
      });
    } else {
      registerRenderAsset({
        type: "artifact",
        id,
        content,
        filename,
        frame,
        contentType: "text",
        downloadBehavior: downloadBehavior ?? null
      });
    }
    return () => {
      return unregisterRenderAsset(id);
    };
  }, [
    content,
    env.isRendering,
    filename,
    frame,
    id,
    registerRenderAsset,
    unregisterRenderAsset,
    downloadBehavior
  ]);
  return null;
};
Artifact.Thumbnail = ArtifactThumbnail;
// src/audio/Audio.tsx


// src/absolute-src.ts
var getAbsoluteSrc = (relativeSrc) => {
  if (typeof window === "undefined") {
    return relativeSrc;
  }
  if (relativeSrc.startsWith("http://") || relativeSrc.startsWith("https://") || relativeSrc.startsWith("file://") || relativeSrc.startsWith("blob:") || relativeSrc.startsWith("data:")) {
    return relativeSrc;
  }
  return new URL(relativeSrc, window.origin).href;
};

// src/calculate-media-duration.ts
var calculateMediaDuration = ({
  trimAfter,
  mediaDurationInFrames,
  playbackRate,
  trimBefore
}) => {
  let duration = mediaDurationInFrames;
  if (typeof trimAfter !== "undefined") {
    duration = trimAfter;
  }
  if (typeof trimBefore !== "undefined") {
    duration -= trimBefore;
  }
  const actualDuration = duration / playbackRate;
  return Math.floor(actualDuration);
};

// src/loop/index.tsx


var LoopContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
var useLoop = () => {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LoopContext);
};
var Loop = ({ durationInFrames, times = Infinity, children, name, ...props }) => {
  const currentFrame = useCurrentFrame();
  const { durationInFrames: compDuration } = useVideoConfig();
  validateDurationInFrames(durationInFrames, {
    component: "of the <Loop /> component",
    allowFloats: true
  });
  if (typeof times !== "number") {
    throw new TypeError(`You passed to "times" an argument of type ${typeof times}, but it must be a number.`);
  }
  if (times !== Infinity && times % 1 !== 0) {
    throw new TypeError(`The "times" prop of a loop must be an integer, but got ${times}.`);
  }
  if (times < 0) {
    throw new TypeError(`The "times" prop of a loop must be at least 0, but got ${times}`);
  }
  const maxTimes = Math.ceil(compDuration / durationInFrames);
  const actualTimes = Math.min(maxTimes, times);
  const style = props.layout === "none" ? undefined : props.style;
  const maxFrame = durationInFrames * (actualTimes - 1);
  const iteration = Math.floor(currentFrame / durationInFrames);
  const start = iteration * durationInFrames;
  const from = Math.min(start, maxFrame);
  const loopDisplay = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      numberOfTimes: Math.min(compDuration / durationInFrames, times),
      startOffset: -from,
      durationInFrames
    };
  }, [compDuration, durationInFrames, from, times]);
  const loopContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      iteration: Math.floor(currentFrame / durationInFrames),
      durationInFrames
    };
  }, [currentFrame, durationInFrames]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LoopContext.Provider, {
    value: loopContext,
    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {
      durationInFrames,
      from,
      name: name ?? "<Loop>",
      _remotionInternalLoopDisplay: loopDisplay,
      layout: props.layout,
      style,
      children
    })
  });
};
Loop.useLoop = useLoop;

// src/prefetch.ts


// src/playback-logging.ts
var playbackLogging = ({
  logLevel,
  tag,
  message,
  mountTime
}) => {
  const tags = [mountTime ? Date.now() - mountTime + "ms " : null, tag].filter(Boolean).join(" ");
  Log.trace({ logLevel, tag: null }, `[${tags}]`, message);
};

// src/prefetch-state.tsx


var PreloadContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});
var preloads = {};
var updaters = [];
var setPreloads = (updater) => {
  preloads = updater(preloads);
  updaters.forEach((u) => u());
};
var PrefetchProvider = ({ children }) => {
  const [_preloads, _setPreloads] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => preloads);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const updaterFunction = () => {
      _setPreloads(preloads);
    };
    updaters.push(updaterFunction);
    return () => {
      updaters = updaters.filter((u) => u !== updaterFunction);
    };
  }, []);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {
    value: _preloads,
    children
  });
};

// src/prefetch.ts
var removeAndGetHashFragment = (src) => {
  const hashIndex = src.indexOf("#");
  if (hashIndex === -1) {
    return null;
  }
  return hashIndex;
};
var getSrcWithoutHash = (src) => {
  const hashIndex = removeAndGetHashFragment(src);
  if (hashIndex === null) {
    return src;
  }
  return src.slice(0, hashIndex);
};
var usePreload = (src) => {
  const preloads2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PreloadContext);
  const hashFragmentIndex = removeAndGetHashFragment(src);
  const withoutHashFragment = getSrcWithoutHash(src);
  if (!preloads2[withoutHashFragment]) {
    return src;
  }
  if (hashFragmentIndex !== null) {
    return preloads2[withoutHashFragment] + src.slice(hashFragmentIndex);
  }
  return preloads2[withoutHashFragment];
};
var blobToBase64 = function(blob) {
  const reader = new FileReader;
  return new Promise((resolve, reject) => {
    reader.onload = function() {
      const dataUrl = reader.result;
      resolve(dataUrl);
    };
    reader.onerror = (err) => {
      return reject(err);
    };
    reader.readAsDataURL(blob);
  });
};
var getBlobFromReader = async ({
  reader,
  contentType,
  contentLength,
  onProgress
}) => {
  let receivedLength = 0;
  const chunks = [];
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    chunks.push(value);
    receivedLength += value.length;
    if (onProgress) {
      onProgress({ loadedBytes: receivedLength, totalBytes: contentLength });
    }
  }
  const chunksAll = new Uint8Array(receivedLength);
  let position = 0;
  for (const chunk of chunks) {
    chunksAll.set(chunk, position);
    position += chunk.length;
  }
  return new Blob([chunksAll], {
    type: contentType ?? undefined
  });
};
var prefetch = (src, options) => {
  const method = options?.method ?? "blob-url";
  const logLevel = options?.logLevel ?? "info";
  const srcWithoutHash = getSrcWithoutHash(src);
  if (getRemotionEnvironment().isRendering) {
    return {
      free: () => {
        return;
      },
      waitUntilDone: () => Promise.resolve(srcWithoutHash)
    };
  }
  Log.verbose({ logLevel, tag: "prefetch" }, `Starting prefetch ${srcWithoutHash}`);
  let canceled = false;
  let objectUrl = null;
  let resolve = () => {
    return;
  };
  let reject = () => {
    return;
  };
  const waitUntilDone = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  const controller = new AbortController;
  let canBeAborted = true;
  fetch(srcWithoutHash, {
    signal: controller.signal,
    credentials: options?.credentials ?? undefined
  }).then((res) => {
    canBeAborted = false;
    if (canceled) {
      return null;
    }
    if (!res.ok) {
      throw new Error(`HTTP error, status = ${res.status}`);
    }
    const headerContentType = res.headers.get("Content-Type");
    const contentType = options?.contentType ?? headerContentType;
    const hasProperContentType = contentType && (contentType.startsWith("video/") || contentType.startsWith("audio/") || contentType.startsWith("image/"));
    if (!hasProperContentType) {
      console.warn(`Called prefetch() on ${srcWithoutHash} which returned a "Content-Type" of ${headerContentType}. Prefetched content should have a proper content type (video/... or audio/...) or a contentType passed the options of prefetch(). Otherwise, prefetching will not work properly in all browsers.`);
    }
    if (!res.body) {
      throw new Error(`HTTP response of ${srcWithoutHash} has no body`);
    }
    const reader = res.body.getReader();
    return getBlobFromReader({
      reader,
      contentType: options?.contentType ?? headerContentType ?? null,
      contentLength: res.headers.get("Content-Length") ? parseInt(res.headers.get("Content-Length"), 10) : null,
      onProgress: options?.onProgress
    });
  }).then((buf) => {
    if (!buf) {
      return;
    }
    const actualBlob = options?.contentType ? new Blob([buf], { type: options.contentType }) : buf;
    if (method === "base64") {
      return blobToBase64(actualBlob);
    }
    return URL.createObjectURL(actualBlob);
  }).then((url) => {
    if (canceled) {
      return;
    }
    playbackLogging({
      logLevel,
      tag: "prefetch",
      message: `Finished prefetch ${srcWithoutHash} with method ${method}`,
      mountTime: null
    });
    objectUrl = url;
    setPreloads((p) => ({
      ...p,
      [srcWithoutHash]: objectUrl
    }));
    resolve(objectUrl);
  }).catch((err) => {
    if (err?.message.includes("free() called")) {
      return;
    }
    reject(err);
  });
  return {
    free: () => {
      playbackLogging({
        logLevel,
        tag: "prefetch",
        message: `Freeing ${srcWithoutHash}`,
        mountTime: null
      });
      if (objectUrl) {
        if (method === "blob-url") {
          URL.revokeObjectURL(objectUrl);
        }
        setPreloads((p) => {
          const copy = { ...p };
          delete copy[srcWithoutHash];
          return copy;
        });
      } else {
        canceled = true;
        if (canBeAborted) {
          try {
            controller.abort(new Error("free() called"));
          } catch {}
        }
      }
    },
    waitUntilDone: () => {
      return waitUntilDone;
    }
  };
};

// src/validate-media-props.ts
var validateMediaProps = (props, component) => {
  if (typeof props.volume !== "number" && typeof props.volume !== "function" && typeof props.volume !== "undefined") {
    throw new TypeError(`You have passed a volume of type ${typeof props.volume} to your <${component} /> component. Volume must be a number or a function with the signature '(frame: number) => number' undefined.`);
  }
  if (typeof props.volume === "number" && props.volume < 0) {
    throw new TypeError(`You have passed a volume below 0 to your <${component} /> component. Volume must be between 0 and 1`);
  }
  if (typeof props.playbackRate !== "number" && typeof props.playbackRate !== "undefined") {
    throw new TypeError(`You have passed a playbackRate of type ${typeof props.playbackRate} to your <${component} /> component. Playback rate must a real number or undefined.`);
  }
  if (typeof props.playbackRate === "number" && (isNaN(props.playbackRate) || !Number.isFinite(props.playbackRate) || props.playbackRate <= 0)) {
    throw new TypeError(`You have passed a playbackRate of ${props.playbackRate} to your <${component} /> component. Playback rate must be a real number above 0.`);
  }
};

// src/validate-start-from-props.ts
var validateStartFromProps = (startFrom, endAt) => {
  if (typeof startFrom !== "undefined") {
    if (typeof startFrom !== "number") {
      throw new TypeError(`type of startFrom prop must be a number, instead got type ${typeof startFrom}.`);
    }
    if (isNaN(startFrom) || startFrom === Infinity) {
      throw new TypeError("startFrom prop can not be NaN or Infinity.");
    }
    if (startFrom < 0) {
      throw new TypeError(`startFrom must be greater than equal to 0 instead got ${startFrom}.`);
    }
  }
  if (typeof endAt !== "undefined") {
    if (typeof endAt !== "number") {
      throw new TypeError(`type of endAt prop must be a number, instead got type ${typeof endAt}.`);
    }
    if (isNaN(endAt)) {
      throw new TypeError("endAt prop can not be NaN.");
    }
    if (endAt <= 0) {
      throw new TypeError(`endAt must be a positive number, instead got ${endAt}.`);
    }
  }
  if (endAt < startFrom) {
    throw new TypeError("endAt prop must be greater than startFrom prop.");
  }
};
var validateTrimProps = (trimBefore, trimAfter) => {
  if (typeof trimBefore !== "undefined") {
    if (typeof trimBefore !== "number") {
      throw new TypeError(`type of trimBefore prop must be a number, instead got type ${typeof trimBefore}.`);
    }
    if (isNaN(trimBefore) || trimBefore === Infinity) {
      throw new TypeError("trimBefore prop can not be NaN or Infinity.");
    }
    if (trimBefore < 0) {
      throw new TypeError(`trimBefore must be greater than equal to 0 instead got ${trimBefore}.`);
    }
  }
  if (typeof trimAfter !== "undefined") {
    if (typeof trimAfter !== "number") {
      throw new TypeError(`type of trimAfter prop must be a number, instead got type ${typeof trimAfter}.`);
    }
    if (isNaN(trimAfter)) {
      throw new TypeError("trimAfter prop can not be NaN.");
    }
    if (trimAfter <= 0) {
      throw new TypeError(`trimAfter must be a positive number, instead got ${trimAfter}.`);
    }
  }
  if (trimAfter <= trimBefore) {
    throw new TypeError("trimAfter prop must be greater than trimBefore prop.");
  }
};
var validateMediaTrimProps = ({
  startFrom,
  endAt,
  trimBefore,
  trimAfter
}) => {
  if (typeof startFrom !== "undefined" && typeof trimBefore !== "undefined") {
    throw new TypeError("Cannot use both startFrom and trimBefore props. Use trimBefore instead as startFrom is deprecated.");
  }
  if (typeof endAt !== "undefined" && typeof trimAfter !== "undefined") {
    throw new TypeError("Cannot use both endAt and trimAfter props. Use trimAfter instead as endAt is deprecated.");
  }
  const hasNewProps = typeof trimBefore !== "undefined" || typeof trimAfter !== "undefined";
  const hasOldProps = typeof startFrom !== "undefined" || typeof endAt !== "undefined";
  if (hasNewProps) {
    validateTrimProps(trimBefore, trimAfter);
  } else if (hasOldProps) {
    validateStartFromProps(startFrom, endAt);
  }
};
var resolveTrimProps = ({
  startFrom,
  endAt,
  trimBefore,
  trimAfter
}) => {
  const trimBeforeValue = trimBefore ?? startFrom ?? undefined;
  const trimAfterValue = trimAfter ?? endAt ?? undefined;
  return { trimBeforeValue, trimAfterValue };
};

// src/video/duration-state.tsx


var durationReducer = (state, action) => {
  switch (action.type) {
    case "got-duration": {
      const absoluteSrc = getAbsoluteSrc(action.src);
      if (state[absoluteSrc] === action.durationInSeconds) {
        return state;
      }
      return {
        ...state,
        [absoluteSrc]: action.durationInSeconds
      };
    }
    default:
      return state;
  }
};
var DurationsContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  durations: {},
  setDurations: () => {
    throw new Error("context missing");
  }
});
var DurationsContextProvider = ({ children }) => {
  const [durations, setDurations] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(durationReducer, {});
  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      durations,
      setDurations
    };
  }, [durations]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContext.Provider, {
    value,
    children
  });
};

// src/audio/AudioForPreview.tsx


// src/get-cross-origin-value.ts
var getCrossOriginValue = ({
  crossOrigin,
  requestsVideoFrame,
  isClientSideRendering
}) => {
  if (crossOrigin !== undefined && crossOrigin !== null) {
    return crossOrigin;
  }
  if (isClientSideRendering) {
    return "anonymous";
  }
  if (requestsVideoFrame) {
    return "anonymous";
  }
  return;
};

// src/use-amplification.ts


// src/audio/shared-audio-tags.tsx


// src/play-and-handle-not-allowed-error.ts
var playAndHandleNotAllowedError = ({
  mediaRef,
  mediaType,
  onAutoPlayError,
  logLevel,
  mountTime,
  reason,
  isPlayer
}) => {
  const { current } = mediaRef;
  if (!current) {
    return;
  }
  playbackLogging({
    logLevel,
    tag: "play",
    message: `Attempting to play ${current.src}. Reason: ${reason}`,
    mountTime
  });
  const prom = current.play();
  if (!prom.catch) {
    return;
  }
  prom.catch((err) => {
    if (!current) {
      return;
    }
    if (err.message.includes("request was interrupted by a call to pause")) {
      return;
    }
    if (err.message.includes("The operation was aborted.")) {
      return;
    }
    if (err.message.includes("The fetching process for the media resource was aborted by the user agent")) {
      return;
    }
    if (err.message.includes("request was interrupted by a new load request")) {
      return;
    }
    if (err.message.includes("because the media was removed from the document")) {
      return;
    }
    if (err.message.includes("user didn't interact with the document") && current.muted) {
      return;
    }
    console.log(`Could not play ${mediaType} due to following error: `, err);
    if (!current.muted) {
      if (onAutoPlayError) {
        onAutoPlayError();
        return;
      }
      if (mediaType === "video" && isPlayer) {
        Log.info({ logLevel, tag: "<" + mediaType + ">" }, `The video will be muted and we'll retry playing it.`);
        Log.info({ logLevel, tag: "<" + mediaType + ">" }, "Use onAutoPlayError() to handle this error yourself.");
        current.muted = true;
        current.play();
      }
    }
  });
};

// src/audio/shared-element-source-node.ts
var makeSharedElementSourceNode = ({
  audioContext,
  ref
}) => {
  let connected = null;
  let disposed = false;
  return {
    attemptToConnect: () => {
      if (disposed) {
        throw new Error("SharedElementSourceNode has been disposed");
      }
      if (!connected && ref.current) {
        const mediaElementSourceNode = audioContext.createMediaElementSource(ref.current);
        connected = mediaElementSourceNode;
      }
    },
    get: () => {
      if (!connected) {
        throw new Error("Audio element not connected");
      }
      return connected;
    },
    cleanup: () => {
      if (connected) {
        connected.disconnect();
        connected = null;
      }
      disposed = true;
    }
  };
};

// src/audio/use-audio-context.ts

var warned = false;
var warnOnce = (logLevel) => {
  if (warned) {
    return;
  }
  warned = true;
  if (typeof window !== "undefined") {
    Log.warn({ logLevel, tag: null }, "AudioContext is not supported in this browser");
  }
};
var useSingletonAudioContext = ({
  logLevel,
  latencyHint,
  audioEnabled
}) => {
  const env = useRemotionEnvironment();
  const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    if (env.isRendering) {
      return null;
    }
    if (!audioEnabled) {
      return null;
    }
    if (typeof AudioContext === "undefined") {
      warnOnce(logLevel);
      return null;
    }
    return new AudioContext({
      latencyHint,
      sampleRate: 48000
    });
  }, [logLevel, latencyHint, env.isRendering, audioEnabled]);
  return audioContext;
};

// src/audio/shared-audio-tags.tsx

var EMPTY_AUDIO = "data:audio/mp3;base64,/+MYxAAJcAV8AAgAABn//////+/gQ5BAMA+D4Pg+BAQBAEAwD4Pg+D4EBAEAQDAPg++hYBH///hUFQVBUFREDQNHmf///////+MYxBUGkAGIMAAAAP/29Xt6lUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDUAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV";
var compareProps = (obj1, obj2) => {
  const keysA = Object.keys(obj1).sort();
  const keysB = Object.keys(obj2).sort();
  if (keysA.length !== keysB.length) {
    return false;
  }
  for (let i = 0;i < keysA.length; i++) {
    if (keysA[i] !== keysB[i]) {
      return false;
    }
    if (obj1[keysA[i]] !== obj2[keysB[i]]) {
      return false;
    }
  }
  return true;
};
var didPropChange = (key, newProp, prevProp) => {
  if (key === "src" && !prevProp.startsWith("data:") && !newProp.startsWith("data:")) {
    return new URL(prevProp, window.origin).toString() !== new URL(newProp, window.origin).toString();
  }
  if (prevProp === newProp) {
    return false;
  }
  return true;
};
var SharedAudioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
var SharedAudioContextProvider = ({ children, numberOfAudioTags, audioLatencyHint, audioEnabled }) => {
  const audios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);
  const [initialNumberOfAudioTags] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(numberOfAudioTags);
  if (numberOfAudioTags !== initialNumberOfAudioTags) {
    throw new Error("The number of shared audio tags has changed dynamically. Once you have set this property, you cannot change it afterwards.");
  }
  const logLevel = useLogLevel();
  const audioContext = useSingletonAudioContext({
    logLevel,
    latencyHint: audioLatencyHint,
    audioEnabled
  });
  const refs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return new Array(numberOfAudioTags).fill(true).map(() => {
      const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();
      return {
        id: Math.random(),
        ref,
        mediaElementSourceNode: audioContext ? makeSharedElementSourceNode({
          audioContext,
          ref
        }) : null
      };
    });
  }, [audioContext, numberOfAudioTags]);
  const effectToUse = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect ?? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;
  effectToUse(() => {
    return () => {
      requestAnimationFrame(() => {
        refs.forEach(({ mediaElementSourceNode }) => {
          mediaElementSourceNode?.cleanup();
        });
      });
    };
  }, [refs]);
  const takenAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(numberOfAudioTags).fill(false));
  const rerenderAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
    refs.forEach(({ ref, id }) => {
      const data = audios.current?.find((a) => a.id === id);
      const { current } = ref;
      if (!current) {
        return;
      }
      if (data === undefined) {
        current.src = EMPTY_AUDIO;
        return;
      }
      if (!data) {
        throw new TypeError("Expected audio data to be there");
      }
      Object.keys(data.props).forEach((key) => {
        if (didPropChange(key, data.props[key], current[key])) {
          current[key] = data.props[key];
        }
      });
    });
  }, [refs]);
  const registerAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((options) => {
    const { aud, audioId, premounting, postmounting } = options;
    const found = audios.current?.find((a) => a.audioId === audioId);
    if (found) {
      return found;
    }
    const firstFreeAudio = takenAudios.current.findIndex((a) => a === false);
    if (firstFreeAudio === -1) {
      throw new Error(`Tried to simultaneously mount ${numberOfAudioTags + 1} <Html5Audio /> tags at the same time. With the current settings, the maximum amount of <Html5Audio /> tags is limited to ${numberOfAudioTags} at the same time. Remotion pre-mounts silent audio tags to help avoid browser autoplay restrictions. See https://remotion.dev/docs/player/autoplay#using-the-numberofsharedaudiotags-prop for more information on how to increase this limit.`);
    }
    const { id, ref, mediaElementSourceNode } = refs[firstFreeAudio];
    const cloned = [...takenAudios.current];
    cloned[firstFreeAudio] = id;
    takenAudios.current = cloned;
    const newElem = {
      props: aud,
      id,
      el: ref,
      audioId,
      mediaElementSourceNode,
      premounting,
      audioMounted: Boolean(ref.current),
      postmounting,
      cleanupOnMediaTagUnmount: () => {}
    };
    audios.current?.push(newElem);
    rerenderAudios();
    return newElem;
  }, [numberOfAudioTags, refs, rerenderAudios]);
  const unregisterAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {
    const cloned = [...takenAudios.current];
    const index = refs.findIndex((r) => r.id === id);
    if (index === -1) {
      throw new TypeError("Error occured in ");
    }
    cloned[index] = false;
    takenAudios.current = cloned;
    audios.current = audios.current?.filter((a) => a.id !== id);
    rerenderAudios();
  }, [refs, rerenderAudios]);
  const updateAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({
    aud,
    audioId,
    id,
    premounting,
    postmounting
  }) => {
    let changed = false;
    audios.current = audios.current?.map((prevA) => {
      const audioMounted = Boolean(prevA.el.current);
      if (prevA.audioMounted !== audioMounted) {
        changed = true;
      }
      if (prevA.id === id) {
        const isTheSame = compareProps(aud, prevA.props) && prevA.premounting === premounting && prevA.postmounting === postmounting;
        if (isTheSame) {
          return prevA;
        }
        changed = true;
        return {
          ...prevA,
          props: aud,
          premounting,
          postmounting,
          audioId,
          audioMounted
        };
      }
      return prevA;
    });
    if (changed) {
      rerenderAudios();
    }
  }, [rerenderAudios]);
  const mountTime = useMountTime();
  const env = useRemotionEnvironment();
  const playAllAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
    refs.forEach((ref) => {
      const audio = audios.current.find((a) => a.el === ref.ref);
      if (audio?.premounting) {
        return;
      }
      playAndHandleNotAllowedError({
        mediaRef: ref.ref,
        mediaType: "audio",
        onAutoPlayError: null,
        logLevel,
        mountTime,
        reason: "playing all audios",
        isPlayer: env.isPlayer
      });
    });
    audioContext?.resume();
  }, [audioContext, logLevel, mountTime, refs, env.isPlayer]);
  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      registerAudio,
      unregisterAudio,
      updateAudio,
      playAllAudios,
      numberOfAudioTags,
      audioContext
    };
  }, [
    numberOfAudioTags,
    playAllAudios,
    registerAudio,
    unregisterAudio,
    updateAudio,
    audioContext
  ]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(SharedAudioContext.Provider, {
    value,
    children: [
      refs.map(({ id, ref }) => {
        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("audio", {
          ref,
          preload: "metadata",
          src: EMPTY_AUDIO
        }, id);
      }),
      children
    ]
  });
};
var useSharedAudio = ({
  aud,
  audioId,
  premounting,
  postmounting
}) => {
  const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);
  const [elem] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {
    if (ctx && ctx.numberOfAudioTags > 0) {
      return ctx.registerAudio({ aud, audioId, premounting, postmounting });
    }
    const el = react__WEBPACK_IMPORTED_MODULE_0__.createRef();
    const mediaElementSourceNode = ctx?.audioContext ? makeSharedElementSourceNode({
      audioContext: ctx.audioContext,
      ref: el
    }) : null;
    return {
      el,
      id: Math.random(),
      props: aud,
      audioId,
      mediaElementSourceNode,
      premounting,
      audioMounted: Boolean(el.current),
      postmounting,
      cleanupOnMediaTagUnmount: () => {
        mediaElementSourceNode?.cleanup();
      }
    };
  });
  const effectToUse = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect ?? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;
  if (typeof document !== "undefined") {
    effectToUse(() => {
      if (ctx && ctx.numberOfAudioTags > 0) {
        ctx.updateAudio({ id: elem.id, aud, audioId, premounting, postmounting });
      }
    }, [aud, ctx, elem.id, audioId, premounting, postmounting]);
    effectToUse(() => {
      return () => {
        if (ctx && ctx.numberOfAudioTags > 0) {
          ctx.unregisterAudio(elem.id);
        }
      };
    }, [ctx, elem.id]);
  }
  return elem;
};

// src/is-approximately-the-same.ts
var FLOATING_POINT_ERROR_THRESHOLD = 0.00001;
var isApproximatelyTheSame = (num1, num2) => {
  return Math.abs(num1 - num2) < FLOATING_POINT_ERROR_THRESHOLD;
};

// src/video/video-fragment.ts

var toSeconds = (time, fps) => {
  return Math.round(time / fps * 100) / 100;
};
var isSafari = () => {
  if (typeof window === "undefined") {
    return false;
  }
  const isAppleWebKit = /AppleWebKit/.test(window.navigator.userAgent);
  if (!isAppleWebKit) {
    return false;
  }
  const isNotChrome = !window.navigator.userAgent.includes("Chrome/");
  return isNotChrome;
};
var isIosSafari = () => {
  if (typeof window === "undefined") {
    return false;
  }
  const isIpadIPodIPhone = /iP(ad|od|hone)/i.test(window.navigator.userAgent);
  return isIpadIPodIPhone && isSafari();
};
var isIOSSafariAndBlob = (actualSrc) => {
  return isIosSafari() && actualSrc.startsWith("blob:");
};
var getVideoFragmentStart = ({
  actualFrom,
  fps
}) => {
  return toSeconds(Math.max(0, -actualFrom), fps);
};
var getVideoFragmentEnd = ({
  duration,
  fps
}) => {
  return toSeconds(duration, fps);
};
var appendVideoFragment = ({
  actualSrc,
  actualFrom,
  duration,
  fps
}) => {
  if (isIOSSafariAndBlob(actualSrc)) {
    return actualSrc;
  }
  if (actualSrc.startsWith("data:")) {
    return actualSrc;
  }
  const existingHash = Boolean(new URL(actualSrc, (typeof window === "undefined" ? null : window.location.href) ?? "http://localhost:3000").hash);
  if (existingHash) {
    return actualSrc;
  }
  if (!Number.isFinite(actualFrom)) {
    return actualSrc;
  }
  const withStartHash = `${actualSrc}#t=${getVideoFragmentStart({ actualFrom, fps })}`;
  if (!Number.isFinite(duration)) {
    return withStartHash;
  }
  return `${withStartHash},${getVideoFragmentEnd({ duration, fps })}`;
};
var isSubsetOfDuration = ({
  prevStartFrom,
  newStartFrom,
  prevDuration,
  newDuration,
  fps
}) => {
  const previousFrom = getVideoFragmentStart({ actualFrom: prevStartFrom, fps });
  const newFrom = getVideoFragmentStart({ actualFrom: newStartFrom, fps });
  const previousEnd = getVideoFragmentEnd({ duration: prevDuration, fps });
  const newEnd = getVideoFragmentEnd({ duration: newDuration, fps });
  if (newFrom < previousFrom) {
    return false;
  }
  if (newEnd > previousEnd) {
    return false;
  }
  return true;
};
var useAppendVideoFragment = ({
  actualSrc: initialActualSrc,
  actualFrom: initialActualFrom,
  duration: initialDuration,
  fps
}) => {
  const actualFromRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualFrom);
  const actualDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialDuration);
  const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualSrc);
  if (!isSubsetOfDuration({
    prevStartFrom: actualFromRef.current,
    newStartFrom: initialActualFrom,
    prevDuration: actualDuration.current,
    newDuration: initialDuration,
    fps
  }) || initialActualSrc !== actualSrc.current) {
    actualFromRef.current = initialActualFrom;
    actualDuration.current = initialDuration;
    actualSrc.current = initialActualSrc;
  }
  const appended = appendVideoFragment({
    actualSrc: actualSrc.current,
    actualFrom: actualFromRef.current,
    duration: actualDuration.current,
    fps
  });
  return appended;
};

// src/use-amplification.ts
var warned2 = false;
var warnSafariOnce = (logLevel) => {
  if (warned2) {
    return;
  }
  warned2 = true;
  Log.warn({ logLevel, tag: null }, "In Safari, setting a volume and a playback rate at the same time is buggy.");
  Log.warn({ logLevel, tag: null }, "In Desktop Safari, only volumes <= 1 will be applied.");
  Log.warn({ logLevel, tag: null }, logLevel, "In Mobile Safari, the volume will be ignored and set to 1 if a playbackRate is set.");
};
var useVolume = ({
  mediaRef,
  volume,
  logLevel,
  source,
  shouldUseWebAudioApi
}) => {
  const audioStuffRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const currentVolumeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(volume);
  currentVolumeRef.current = volume;
  const sharedAudioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);
  if (!sharedAudioContext) {
    throw new Error("useAmplification must be used within a SharedAudioContext");
  }
  const { audioContext } = sharedAudioContext;
  if (typeof window !== "undefined") {
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
      if (!audioContext) {
        return;
      }
      if (!mediaRef.current) {
        return;
      }
      if (!shouldUseWebAudioApi) {
        return;
      }
      if (mediaRef.current.playbackRate !== 1 && isSafari()) {
        warnSafariOnce(logLevel);
        return;
      }
      if (!source) {
        return;
      }
      const gainNode = new GainNode(audioContext, {
        gain: currentVolumeRef.current
      });
      source.attemptToConnect();
      source.get().connect(gainNode);
      gainNode.connect(audioContext.destination);
      audioStuffRef.current = {
        gainNode
      };
      Log.trace({ logLevel, tag: null }, `Starting to amplify ${mediaRef.current?.src}. Gain = ${currentVolumeRef.current}, playbackRate = ${mediaRef.current?.playbackRate}`);
      return () => {
        audioStuffRef.current = null;
        gainNode.disconnect();
        source.get().disconnect();
      };
    }, [logLevel, mediaRef, audioContext, source, shouldUseWebAudioApi]);
  }
  if (audioStuffRef.current) {
    const valueToSet = volume;
    if (!isApproximatelyTheSame(audioStuffRef.current.gainNode.gain.value, valueToSet)) {
      audioStuffRef.current.gainNode.gain.value = valueToSet;
      Log.trace({ logLevel, tag: null }, `Setting gain to ${valueToSet} for ${mediaRef.current?.src}`);
    }
  }
  const safariCase = isSafari() && mediaRef.current && mediaRef.current?.playbackRate !== 1;
  const shouldUseTraditionalVolume = safariCase || !shouldUseWebAudioApi;
  if (shouldUseTraditionalVolume && mediaRef.current && !isApproximatelyTheSame(volume, mediaRef.current?.volume)) {
    mediaRef.current.volume = Math.min(volume, 1);
  }
  return audioStuffRef;
};

// src/use-media-in-timeline.ts


// src/audio/use-audio-frame.ts

var useMediaStartsAt = () => {
  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);
  const startsAt = Math.min(0, parentSequence?.relativeFrom ?? 0);
  return startsAt;
};
var useFrameForVolumeProp = (behavior) => {
  const loop = Loop.useLoop();
  const frame = useCurrentFrame();
  const startsAt = useMediaStartsAt();
  if (behavior === "repeat" || loop === null) {
    return frame + startsAt;
  }
  return frame + startsAt + loop.durationInFrames * loop.iteration;
};

// src/get-asset-file-name.ts
var getAssetDisplayName = (filename) => {
  if (/data:|blob:/.test(filename.substring(0, 5))) {
    return "Data URL";
  }
  const splitted = filename.split("/").map((s) => s.split("\\")).flat(1);
  return splitted[splitted.length - 1];
};

// src/volume-prop.ts
var evaluateVolume = ({
  frame,
  volume,
  mediaVolume = 1
}) => {
  if (typeof volume === "number") {
    return volume * mediaVolume;
  }
  if (typeof volume === "undefined") {
    return Number(mediaVolume);
  }
  const evaluated = volume(frame) * mediaVolume;
  if (typeof evaluated !== "number") {
    throw new TypeError(`You passed in a a function to the volume prop but it did not return a number but a value of type ${typeof evaluated} for frame ${frame}`);
  }
  if (Number.isNaN(evaluated)) {
    throw new TypeError(`You passed in a function to the volume prop but it returned NaN for frame ${frame}.`);
  }
  if (!Number.isFinite(evaluated)) {
    throw new TypeError(`You passed in a function to the volume prop but it returned a non-finite number for frame ${frame}.`);
  }
  return Math.max(0, evaluated);
};

// src/use-media-in-timeline.ts
var didWarn = {};
var warnOnce2 = (message) => {
  if (didWarn[message]) {
    return;
  }
  console.warn(message);
  didWarn[message] = true;
};
var useBasicMediaInTimeline = ({
  volume,
  mediaVolume,
  mediaType,
  src,
  displayName,
  trimBefore,
  trimAfter,
  playbackRate
}) => {
  if (!src) {
    throw new Error("No src passed");
  }
  const startsAt = useMediaStartsAt();
  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);
  const videoConfig = useVideoConfig();
  const [initialVolume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => volume);
  const mediaDuration = calculateMediaDuration({
    mediaDurationInFrames: videoConfig.durationInFrames,
    playbackRate,
    trimBefore,
    trimAfter
  });
  const duration = parentSequence ? Math.min(parentSequence.durationInFrames, mediaDuration) : mediaDuration;
  const volumes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    if (typeof volume === "number") {
      return volume;
    }
    return new Array(Math.floor(Math.max(0, duration + startsAt))).fill(true).map((_, i) => {
      return evaluateVolume({
        frame: i + startsAt,
        volume,
        mediaVolume
      });
    }).join(",");
  }, [duration, startsAt, volume, mediaVolume]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (typeof volume === "number" && volume !== initialVolume) {
      warnOnce2(`Remotion: The ${mediaType} with src ${src} has changed it's volume. Prefer the callback syntax for setting volume to get better timeline display: https://www.remotion.dev/docs/audio/volume`);
    }
  }, [initialVolume, mediaType, src, volume]);
  const doesVolumeChange = typeof volume === "function";
  const nonce = useNonce();
  const { rootId } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);
  const env = useRemotionEnvironment();
  return {
    volumes,
    duration,
    doesVolumeChange,
    nonce,
    rootId,
    isStudio: env.isStudio,
    finalDisplayName: displayName ?? getAssetDisplayName(src)
  };
};
var useMediaInTimeline = ({
  volume,
  mediaVolume,
  src,
  mediaType,
  playbackRate,
  displayName,
  id,
  stack,
  showInTimeline,
  premountDisplay,
  postmountDisplay,
  loopDisplay
}) => {
  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);
  const startsAt = useMediaStartsAt();
  const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);
  const {
    volumes,
    duration,
    doesVolumeChange,
    nonce,
    rootId,
    isStudio,
    finalDisplayName
  } = useBasicMediaInTimeline({
    volume,
    mediaVolume,
    mediaType,
    src,
    displayName,
    trimAfter: undefined,
    trimBefore: undefined,
    playbackRate
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!src) {
      throw new Error("No src passed");
    }
    if (!isStudio && window.process?.env?.NODE_ENV !== "test") {
      return;
    }
    if (!showInTimeline) {
      return;
    }
    registerSequence({
      type: mediaType,
      src,
      id,
      duration,
      from: 0,
      parent: parentSequence?.id ?? null,
      displayName: finalDisplayName,
      rootId,
      volume: volumes,
      showInTimeline: true,
      nonce,
      startMediaFrom: 0 - startsAt,
      doesVolumeChange,
      loopDisplay,
      playbackRate,
      stack,
      premountDisplay,
      postmountDisplay
    });
    return () => {
      unregisterSequence(id);
    };
  }, [
    duration,
    id,
    parentSequence,
    src,
    registerSequence,
    unregisterSequence,
    volumes,
    doesVolumeChange,
    nonce,
    mediaType,
    startsAt,
    playbackRate,
    stack,
    showInTimeline,
    premountDisplay,
    postmountDisplay,
    isStudio,
    loopDisplay,
    rootId,
    finalDisplayName
  ]);
};

// src/use-media-playback.ts


// src/buffer-until-first-frame.ts


// src/use-buffer-state.ts


// src/buffering.tsx


var useBufferManager = (logLevel, mountTime) => {
  const [blocks, setBlocks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
  const [onBufferingCallbacks, setOnBufferingCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
  const [onResumeCallbacks, setOnResumeCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
  const env = useRemotionEnvironment();
  const rendering = env.isRendering;
  const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
  const addBlock = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((block) => {
    if (rendering) {
      return {
        unblock: () => {
          return;
        }
      };
    }
    setBlocks((b) => [...b, block]);
    return {
      unblock: () => {
        setBlocks((b) => {
          const newArr = b.filter((bx) => bx !== block);
          if (newArr.length === b.length) {
            return b;
          }
          return newArr;
        });
      }
    };
  }, [rendering]);
  const listenForBuffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback) => {
    setOnBufferingCallbacks((c) => [...c, callback]);
    return {
      remove: () => {
        setOnBufferingCallbacks((c) => c.filter((cb) => cb !== callback));
      }
    };
  }, []);
  const listenForResume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback) => {
    setOnResumeCallbacks((c) => [...c, callback]);
    return {
      remove: () => {
        setOnResumeCallbacks((c) => c.filter((cb) => cb !== callback));
      }
    };
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (rendering) {
      return;
    }
    if (blocks.length > 0) {
      onBufferingCallbacks.forEach((c) => c());
      playbackLogging({
        logLevel,
        message: "Player is entering buffer state",
        mountTime,
        tag: "player"
      });
    }
  }, [blocks]);
  if (typeof window !== "undefined") {
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
      if (rendering) {
        return;
      }
      if (blocks.length === 0) {
        onResumeCallbacks.forEach((c) => c());
        playbackLogging({
          logLevel,
          message: "Player is exiting buffer state",
          mountTime,
          tag: "player"
        });
      }
    }, [blocks]);
  }
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return { addBlock, listenForBuffering, listenForResume, buffering };
  }, [addBlock, buffering, listenForBuffering, listenForResume]);
};
var BufferingContextReact = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
var BufferingProvider = ({ children }) => {
  const { logLevel, mountTime } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LogLevelContext);
  const bufferManager = useBufferManager(logLevel ?? "info", mountTime);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {
    value: bufferManager,
    children
  });
};
var useIsPlayerBuffering = (bufferManager) => {
  const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(bufferManager.buffering.current);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const onBuffer = () => {
      setIsBuffering(true);
    };
    const onResume = () => {
      setIsBuffering(false);
    };
    bufferManager.listenForBuffering(onBuffer);
    bufferManager.listenForResume(onResume);
    return () => {
      bufferManager.listenForBuffering(() => {
        return;
      });
      bufferManager.listenForResume(() => {
        return;
      });
    };
  }, [bufferManager]);
  return isBuffering;
};

// src/use-buffer-state.ts
var useBufferState = () => {
  const buffer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);
  const addBlock = buffer ? buffer.addBlock : null;
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({
    delayPlayback: () => {
      if (!addBlock) {
        throw new Error("Tried to enable the buffering state, but a Remotion context was not found. This API can only be called in a component that was passed to the Remotion Player or a <Composition>. Or you might have experienced a version mismatch - run `npx remotion versions` and ensure all packages have the same version. This error is thrown by the buffer state https://remotion.dev/docs/player/buffer-state");
      }
      const { unblock } = addBlock({
        id: String(Math.random())
      });
      return { unblock };
    }
  }), [addBlock]);
};

// src/buffer-until-first-frame.ts
var isSafariWebkit = () => {
  const isSafari2 = /^((?!chrome|android).)*safari/i.test(window.navigator.userAgent);
  return isSafari2;
};
var useBufferUntilFirstFrame = ({
  mediaRef,
  mediaType,
  onVariableFpsVideoDetected,
  pauseWhenBuffering,
  logLevel,
  mountTime
}) => {
  const bufferingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
  const { delayPlayback } = useBufferState();
  const bufferUntilFirstFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((requestedTime) => {
    if (mediaType !== "video") {
      return;
    }
    if (!pauseWhenBuffering) {
      return;
    }
    const current = mediaRef.current;
    if (!current) {
      return;
    }
    if (current.readyState >= current.HAVE_FUTURE_DATA && !isSafariWebkit()) {
      playbackLogging({
        logLevel,
        message: `Not using buffer until first frame, because readyState is ${current.readyState} and is not Safari or Desktop Chrome`,
        mountTime,
        tag: "buffer"
      });
      return;
    }
    if (!current.requestVideoFrameCallback) {
      playbackLogging({
        logLevel,
        message: `Not using buffer until first frame, because requestVideoFrameCallback is not supported`,
        mountTime,
        tag: "buffer"
      });
      return;
    }
    bufferingRef.current = true;
    playbackLogging({
      logLevel,
      message: `Buffering ${mediaRef.current?.src} until the first frame is received`,
      mountTime,
      tag: "buffer"
    });
    const playback = delayPlayback();
    const unblock = () => {
      playback.unblock();
      current.removeEventListener("ended", unblock, {
        once: true
      });
      current.removeEventListener("pause", unblock, {
        once: true
      });
      bufferingRef.current = false;
    };
    const onEndedOrPauseOrCanPlay = () => {
      unblock();
    };
    current.requestVideoFrameCallback((_, info2) => {
      const differenceFromRequested = Math.abs(info2.mediaTime - requestedTime);
      if (differenceFromRequested > 0.5) {
        onVariableFpsVideoDetected();
      }
      unblock();
    });
    current.addEventListener("ended", onEndedOrPauseOrCanPlay, { once: true });
    current.addEventListener("pause", onEndedOrPauseOrCanPlay, { once: true });
    current.addEventListener("canplay", onEndedOrPauseOrCanPlay, {
      once: true
    });
  }, [
    delayPlayback,
    logLevel,
    mediaRef,
    mediaType,
    mountTime,
    onVariableFpsVideoDetected,
    pauseWhenBuffering
  ]);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      isBuffering: () => bufferingRef.current,
      bufferUntilFirstFrame
    };
  }, [bufferUntilFirstFrame]);
};

// src/media-tag-current-time-timestamp.ts

var useCurrentTimeOfMediaTagWithUpdateTimeStamp = (mediaRef) => {
  const lastUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useRef({
    time: mediaRef.current?.currentTime ?? 0,
    lastUpdate: performance.now()
  });
  const nowCurrentTime = mediaRef.current?.currentTime ?? null;
  if (nowCurrentTime !== null) {
    if (lastUpdate.current.time !== nowCurrentTime) {
      lastUpdate.current.time = nowCurrentTime;
      lastUpdate.current.lastUpdate = performance.now();
    }
  }
  return lastUpdate;
};

// src/seek.ts
var seek = ({
  mediaRef,
  time,
  logLevel,
  why,
  mountTime
}) => {
  const timeToSet = isIosSafari() ? Number(time.toFixed(1)) : time;
  playbackLogging({
    logLevel,
    tag: "seek",
    message: `Seeking from ${mediaRef.currentTime} to ${timeToSet}. src= ${mediaRef.src} Reason: ${why}`,
    mountTime
  });
  mediaRef.currentTime = timeToSet;
  return timeToSet;
};

// src/use-media-buffering.ts

var useMediaBuffering = ({
  element,
  shouldBuffer,
  isPremounting,
  isPostmounting,
  logLevel,
  mountTime,
  src
}) => {
  const buffer = useBufferState();
  const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    let cleanupFns = [];
    const { current } = element;
    if (!current) {
      return;
    }
    if (!shouldBuffer) {
      return;
    }
    if (isPremounting || isPostmounting) {
      if ((isPremounting || isPostmounting) && current.readyState < current.HAVE_FUTURE_DATA) {
        if (!navigator.userAgent.includes("Firefox/")) {
          playbackLogging({
            logLevel,
            message: `Calling .load() on ${current.src} because readyState is ${current.readyState} and it is not Firefox. Element is premounted ${current.playbackRate}`,
            tag: "load",
            mountTime
          });
          const previousPlaybackRate = current.playbackRate;
          current.load();
          current.playbackRate = previousPlaybackRate;
        }
      }
      return;
    }
    const cleanup = (reason) => {
      let didDoSomething = false;
      cleanupFns.forEach((fn) => {
        fn(reason);
        didDoSomething = true;
      });
      cleanupFns = [];
      setIsBuffering((previous) => {
        if (previous) {
          didDoSomething = true;
        }
        return false;
      });
      if (didDoSomething) {
        playbackLogging({
          logLevel,
          message: `Unmarking as buffering: ${current.src}. Reason: ${reason}`,
          tag: "buffer",
          mountTime
        });
      }
    };
    const blockMedia = (reason) => {
      setIsBuffering(true);
      playbackLogging({
        logLevel,
        message: `Marking as buffering: ${current.src}. Reason: ${reason}`,
        tag: "buffer",
        mountTime
      });
      const { unblock } = buffer.delayPlayback();
      const onCanPlay = () => {
        cleanup('"canplay" was fired');
        init();
      };
      const onError = () => {
        cleanup('"error" event was occurred');
        init();
      };
      current.addEventListener("canplay", onCanPlay, {
        once: true
      });
      cleanupFns.push(() => {
        current.removeEventListener("canplay", onCanPlay);
      });
      current.addEventListener("error", onError, {
        once: true
      });
      cleanupFns.push(() => {
        current.removeEventListener("error", onError);
      });
      cleanupFns.push((cleanupReason) => {
        playbackLogging({
          logLevel,
          message: `Unblocking ${current.src} from buffer. Reason: ${cleanupReason}`,
          tag: "buffer",
          mountTime
        });
        unblock();
      });
    };
    const init = () => {
      if (current.readyState < current.HAVE_FUTURE_DATA) {
        blockMedia(`readyState is ${current.readyState}, which is less than HAVE_FUTURE_DATA`);
        if (!navigator.userAgent.includes("Firefox/")) {
          playbackLogging({
            logLevel,
            message: `Calling .load() on ${src} because readyState is ${current.readyState} and it is not Firefox. ${current.playbackRate}`,
            tag: "load",
            mountTime
          });
          const previousPlaybackRate = current.playbackRate;
          current.load();
          current.playbackRate = previousPlaybackRate;
        }
      } else {
        const onWaiting = () => {
          blockMedia('"waiting" event was fired');
        };
        current.addEventListener("waiting", onWaiting);
        cleanupFns.push(() => {
          current.removeEventListener("waiting", onWaiting);
        });
      }
    };
    init();
    return () => {
      cleanup("element was unmounted or prop changed");
    };
  }, [
    buffer,
    src,
    element,
    isPremounting,
    isPostmounting,
    logLevel,
    shouldBuffer,
    mountTime
  ]);
  return isBuffering;
};

// src/use-request-video-callback-time.ts

var useRequestVideoCallbackTime = ({
  mediaRef,
  mediaType,
  lastSeek,
  onVariableFpsVideoDetected
}) => {
  const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const { current } = mediaRef;
    if (current) {
      currentTime.current = {
        time: current.currentTime,
        lastUpdate: performance.now()
      };
    } else {
      currentTime.current = null;
      return;
    }
    if (mediaType !== "video") {
      currentTime.current = null;
      return;
    }
    const videoTag = current;
    if (!videoTag.requestVideoFrameCallback) {
      return;
    }
    let cancel = () => {
      return;
    };
    const request = () => {
      if (!videoTag) {
        return;
      }
      const cb = videoTag.requestVideoFrameCallback((_, info2) => {
        if (currentTime.current !== null) {
          const difference = Math.abs(currentTime.current.time - info2.mediaTime);
          const differenceToLastSeek = Math.abs(lastSeek.current === null ? Infinity : info2.mediaTime - lastSeek.current);
          if (difference > 0.5 && differenceToLastSeek > 0.5 && info2.mediaTime > currentTime.current.time) {
            onVariableFpsVideoDetected();
          }
        }
        currentTime.current = {
          time: info2.mediaTime,
          lastUpdate: performance.now()
        };
        request();
      });
      cancel = () => {
        videoTag.cancelVideoFrameCallback(cb);
        cancel = () => {
          return;
        };
      };
    };
    request();
    return () => {
      cancel();
    };
  }, [lastSeek, mediaRef, mediaType, onVariableFpsVideoDetected]);
  return currentTime;
};

// src/interpolate.ts
function interpolateFunction(input, inputRange, outputRange, options) {
  const { extrapolateLeft, extrapolateRight, easing } = options;
  let result = input;
  const [inputMin, inputMax] = inputRange;
  const [outputMin, outputMax] = outputRange;
  if (result < inputMin) {
    if (extrapolateLeft === "identity") {
      return result;
    }
    if (extrapolateLeft === "clamp") {
      result = inputMin;
    } else if (extrapolateLeft === "wrap") {
      const range = inputMax - inputMin;
      result = ((result - inputMin) % range + range) % range + inputMin;
    } else if (extrapolateLeft === "extend") {}
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity") {
      return result;
    }
    if (extrapolateRight === "clamp") {
      result = inputMax;
    } else if (extrapolateRight === "wrap") {
      const range = inputMax - inputMin;
      result = ((result - inputMin) % range + range) % range + inputMin;
    } else if (extrapolateRight === "extend") {}
  }
  if (outputMin === outputMax) {
    return outputMin;
  }
  result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  let i;
  for (i = 1;i < inputRange.length - 1; ++i) {
    if (inputRange[i] >= input) {
      break;
    }
  }
  return i - 1;
}
function checkValidInputRange(arr) {
  for (let i = 1;i < arr.length; ++i) {
    if (!(arr[i] > arr[i - 1])) {
      throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(",")}]`);
    }
  }
}
function checkInfiniteRange(name, arr) {
  if (arr.length < 2) {
    throw new Error(name + " must have at least 2 elements");
  }
  for (const element of arr) {
    if (typeof element !== "number") {
      throw new Error(`${name} must contain only numbers`);
    }
    if (!Number.isFinite(element)) {
      throw new Error(`${name} must contain only finite numbers, but got [${arr.join(",")}]`);
    }
  }
}
function interpolate(input, inputRange, outputRange, options) {
  if (typeof input === "undefined") {
    throw new Error("input can not be undefined");
  }
  if (typeof inputRange === "undefined") {
    throw new Error("inputRange can not be undefined");
  }
  if (typeof outputRange === "undefined") {
    throw new Error("outputRange can not be undefined");
  }
  if (inputRange.length !== outputRange.length) {
    throw new Error("inputRange (" + inputRange.length + ") and outputRange (" + outputRange.length + ") must have the same length");
  }
  checkInfiniteRange("inputRange", inputRange);
  checkInfiniteRange("outputRange", outputRange);
  checkValidInputRange(inputRange);
  const easing = options?.easing ?? ((num) => num);
  let extrapolateLeft = "extend";
  if (options?.extrapolateLeft !== undefined) {
    extrapolateLeft = options.extrapolateLeft;
  }
  let extrapolateRight = "extend";
  if (options?.extrapolateRight !== undefined) {
    extrapolateRight = options.extrapolateRight;
  }
  if (typeof input !== "number") {
    throw new TypeError("Cannot interpolate an input which is not a number");
  }
  const range = findRange(input, inputRange);
  return interpolateFunction(input, [inputRange[range], inputRange[range + 1]], [outputRange[range], outputRange[range + 1]], {
    easing,
    extrapolateLeft,
    extrapolateRight
  });
}

// src/video/get-current-time.ts
var getExpectedMediaFrameUncorrected = ({
  frame,
  playbackRate,
  startFrom
}) => {
  return interpolate(frame, [-1, startFrom, startFrom + 1], [-1, startFrom, startFrom + playbackRate]);
};
var getMediaTime = ({
  fps,
  frame,
  playbackRate,
  startFrom
}) => {
  const expectedFrame = getExpectedMediaFrameUncorrected({
    frame,
    playbackRate,
    startFrom
  });
  const msPerFrame = 1000 / fps;
  return expectedFrame * msPerFrame / 1000;
};

// src/warn-about-non-seekable-media.ts
var alreadyWarned = {};
var warnAboutNonSeekableMedia = (ref, type) => {
  if (ref === null) {
    return;
  }
  if (ref.seekable.length === 0) {
    return;
  }
  if (ref.seekable.length > 1) {
    return;
  }
  if (alreadyWarned[ref.src]) {
    return;
  }
  const range = { start: ref.seekable.start(0), end: ref.seekable.end(0) };
  if (range.start === 0 && range.end === 0) {
    const msg = [
      `The media ${ref.src} cannot be seeked. This could be one of few reasons:`,
      "1) The media resource was replaced while the video is playing but it was not loaded yet.",
      "2) The media does not support seeking.",
      "3) The media was loaded with security headers prventing it from being included.",
      "Please see https://remotion.dev/docs/non-seekable-media for assistance."
    ].join(`
`);
    if (type === "console-error") {
      console.error(msg);
    } else if (type === "console-warning") {
      console.warn(`The media ${ref.src} does not support seeking. The video will render fine, but may not play correctly in the Remotion Studio and in the <Player>. See https://remotion.dev/docs/non-seekable-media for an explanation.`);
    } else {
      throw new Error(msg);
    }
    alreadyWarned[ref.src] = true;
  }
};

// src/use-media-playback.ts
var useMediaPlayback = ({
  mediaRef,
  src,
  mediaType,
  playbackRate: localPlaybackRate,
  onlyWarnForMediaSeekingError,
  acceptableTimeshift,
  pauseWhenBuffering,
  isPremounting,
  isPostmounting,
  onAutoPlayError
}) => {
  const { playbackRate: globalPlaybackRate } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);
  const frame = useCurrentFrame();
  const absoluteFrame = useTimelinePosition();
  const [playing] = usePlayingState();
  const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);
  const { fps } = useVideoConfig();
  const mediaStartsAt = useMediaStartsAt();
  const lastSeekDueToShift = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const lastSeek = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const logLevel = useLogLevel();
  const mountTime = useMountTime();
  if (!buffering) {
    throw new Error("useMediaPlayback must be used inside a <BufferingContext>");
  }
  const isVariableFpsVideoMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});
  const onVariableFpsVideoDetected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
    if (!src) {
      return;
    }
    if (isVariableFpsVideoMap.current[src]) {
      return;
    }
    Log.verbose({ logLevel, tag: null }, `Detected ${src} as a variable FPS video. Disabling buffering while seeking.`);
    isVariableFpsVideoMap.current[src] = true;
  }, [logLevel, src]);
  const rvcCurrentTime = useRequestVideoCallbackTime({
    mediaRef,
    mediaType,
    lastSeek,
    onVariableFpsVideoDetected
  });
  const mediaTagCurrentTime = useCurrentTimeOfMediaTagWithUpdateTimeStamp(mediaRef);
  const desiredUnclampedTime = getMediaTime({
    frame,
    playbackRate: localPlaybackRate,
    startFrom: -mediaStartsAt,
    fps
  });
  const isMediaTagBuffering = useMediaBuffering({
    element: mediaRef,
    shouldBuffer: pauseWhenBuffering,
    isPremounting,
    isPostmounting,
    logLevel,
    mountTime,
    src: src ?? null
  });
  const { bufferUntilFirstFrame, isBuffering } = useBufferUntilFirstFrame({
    mediaRef,
    mediaType,
    onVariableFpsVideoDetected,
    pauseWhenBuffering,
    logLevel,
    mountTime
  });
  const playbackRate = localPlaybackRate * globalPlaybackRate;
  const acceptableTimeShiftButLessThanDuration = (() => {
    const DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK = 0.45;
    const DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_AMPLIFICATION = DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK + 0.2;
    const defaultAcceptableTimeshift = DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_AMPLIFICATION;
    if (mediaRef.current?.duration) {
      return Math.min(mediaRef.current.duration, acceptableTimeshift ?? defaultAcceptableTimeshift);
    }
    return acceptableTimeshift ?? defaultAcceptableTimeshift;
  })();
  const isPlayerBuffering = useIsPlayerBuffering(buffering);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (mediaRef.current?.paused) {
      return;
    }
    if (!playing) {
      playbackLogging({
        logLevel,
        tag: "pause",
        message: `Pausing ${mediaRef.current?.src} because ${isPremounting ? "media is premounting" : isPostmounting ? "media is postmounting" : "Player is not playing"}`,
        mountTime
      });
      mediaRef.current?.pause();
      return;
    }
    const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();
    const playerBufferingNotStateButLive = buffering.buffering.current;
    if (playerBufferingNotStateButLive && !isMediaTagBufferingOrStalled) {
      playbackLogging({
        logLevel,
        tag: "pause",
        message: `Pausing ${mediaRef.current?.src} because player is buffering but media tag is not`,
        mountTime
      });
      mediaRef.current?.pause();
    }
  }, [
    isBuffering,
    isMediaTagBuffering,
    buffering,
    isPlayerBuffering,
    isPremounting,
    logLevel,
    mediaRef,
    mediaType,
    mountTime,
    playing,
    isPostmounting
  ]);
  const env = useRemotionEnvironment();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
    const playbackRateToSet = Math.max(0, playbackRate);
    if (mediaRef.current && mediaRef.current.playbackRate !== playbackRateToSet) {
      mediaRef.current.playbackRate = playbackRateToSet;
    }
  }, [mediaRef, playbackRate]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const tagName = mediaType === "audio" ? "<Html5Audio>" : "<Html5Video>";
    if (!mediaRef.current) {
      throw new Error(`No ${mediaType} ref found`);
    }
    if (!src) {
      throw new Error(`No 'src' attribute was passed to the ${tagName} element.`);
    }
    const { duration } = mediaRef.current;
    const shouldBeTime = !Number.isNaN(duration) && Number.isFinite(duration) ? Math.min(duration, desiredUnclampedTime) : desiredUnclampedTime;
    const mediaTagTime = mediaTagCurrentTime.current.time;
    const rvcTime = rvcCurrentTime.current?.time ?? null;
    const isVariableFpsVideo = isVariableFpsVideoMap.current[src];
    const timeShiftMediaTag = Math.abs(shouldBeTime - mediaTagTime);
    const timeShiftRvcTag = rvcTime ? Math.abs(shouldBeTime - rvcTime) : null;
    const mostRecentTimeshift = rvcCurrentTime.current?.lastUpdate && rvcCurrentTime.current.time > mediaTagCurrentTime.current.lastUpdate ? timeShiftRvcTag : timeShiftMediaTag;
    const timeShift = timeShiftRvcTag && !isVariableFpsVideo ? mostRecentTimeshift : timeShiftMediaTag;
    if (timeShift > acceptableTimeShiftButLessThanDuration && lastSeekDueToShift.current !== shouldBeTime) {
      lastSeek.current = seek({
        mediaRef: mediaRef.current,
        time: shouldBeTime,
        logLevel,
        why: `because time shift is too big. shouldBeTime = ${shouldBeTime}, isTime = ${mediaTagTime}, requestVideoCallbackTime = ${rvcTime}, timeShift = ${timeShift}${isVariableFpsVideo ? ", isVariableFpsVideo = true" : ""}, isPremounting = ${isPremounting}, isPostmounting = ${isPostmounting}, pauseWhenBuffering = ${pauseWhenBuffering}`,
        mountTime
      });
      lastSeekDueToShift.current = lastSeek.current;
      if (playing) {
        if (playbackRate > 0) {
          bufferUntilFirstFrame(shouldBeTime);
        }
        if (mediaRef.current.paused) {
          playAndHandleNotAllowedError({
            mediaRef,
            mediaType,
            onAutoPlayError,
            logLevel,
            mountTime,
            reason: "player is playing but media tag is paused, and just seeked",
            isPlayer: env.isPlayer
          });
        }
      }
      if (!onlyWarnForMediaSeekingError) {
        warnAboutNonSeekableMedia(mediaRef.current, onlyWarnForMediaSeekingError ? "console-warning" : "console-error");
      }
      return;
    }
    const seekThreshold = playing ? 0.15 : 0.01;
    const makesSenseToSeek = Math.abs(mediaRef.current.currentTime - shouldBeTime) > seekThreshold;
    const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();
    const isSomethingElseBuffering = buffering.buffering.current && !isMediaTagBufferingOrStalled;
    if (!playing || isSomethingElseBuffering) {
      if (makesSenseToSeek) {
        lastSeek.current = seek({
          mediaRef: mediaRef.current,
          time: shouldBeTime,
          logLevel,
          why: `not playing or something else is buffering. time offset is over seek threshold (${seekThreshold})`,
          mountTime
        });
      }
      return;
    }
    if (!playing || buffering.buffering.current) {
      return;
    }
    const pausedCondition = mediaRef.current.paused && !mediaRef.current.ended;
    const firstFrameCondition = absoluteFrame === 0;
    if (pausedCondition || firstFrameCondition) {
      const reason = pausedCondition ? "media tag is paused" : "absolute frame is 0";
      if (makesSenseToSeek) {
        lastSeek.current = seek({
          mediaRef: mediaRef.current,
          time: shouldBeTime,
          logLevel,
          why: `is over timeshift threshold (threshold = ${seekThreshold}) and ${reason}`,
          mountTime
        });
      }
      playAndHandleNotAllowedError({
        mediaRef,
        mediaType,
        onAutoPlayError,
        logLevel,
        mountTime,
        reason: `player is playing and ${reason}`,
        isPlayer: env.isPlayer
      });
      if (!isVariableFpsVideo && playbackRate > 0) {
        bufferUntilFirstFrame(shouldBeTime);
      }
    }
  }, [
    absoluteFrame,
    acceptableTimeShiftButLessThanDuration,
    bufferUntilFirstFrame,
    buffering.buffering,
    rvcCurrentTime,
    logLevel,
    desiredUnclampedTime,
    isBuffering,
    isMediaTagBuffering,
    mediaRef,
    mediaType,
    onlyWarnForMediaSeekingError,
    playbackRate,
    playing,
    src,
    onAutoPlayError,
    isPremounting,
    isPostmounting,
    pauseWhenBuffering,
    mountTime,
    mediaTagCurrentTime,
    env.isPlayer
  ]);
};

// src/use-media-tag.ts

var useMediaTag = ({
  mediaRef,
  id,
  mediaType,
  onAutoPlayError,
  isPremounting,
  isPostmounting
}) => {
  const { audioAndVideoTags, imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);
  const logLevel = useLogLevel();
  const mountTime = useMountTime();
  const env = useRemotionEnvironment();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const tag = {
      id,
      play: (reason) => {
        if (!imperativePlaying.current) {
          return;
        }
        if (isPremounting || isPostmounting) {
          return;
        }
        return playAndHandleNotAllowedError({
          mediaRef,
          mediaType,
          onAutoPlayError,
          logLevel,
          mountTime,
          reason,
          isPlayer: env.isPlayer
        });
      }
    };
    audioAndVideoTags.current.push(tag);
    return () => {
      audioAndVideoTags.current = audioAndVideoTags.current.filter((a) => a.id !== id);
    };
  }, [
    audioAndVideoTags,
    id,
    mediaRef,
    mediaType,
    onAutoPlayError,
    imperativePlaying,
    isPremounting,
    isPostmounting,
    logLevel,
    mountTime,
    env.isPlayer
  ]);
};

// src/volume-position-state.ts

var MediaVolumeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  mediaMuted: false,
  mediaVolume: 1
});
var SetMediaVolumeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  setMediaMuted: () => {
    throw new Error("default");
  },
  setMediaVolume: () => {
    throw new Error("default");
  }
});
var useMediaVolumeState = () => {
  const { mediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);
  const { setMediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return [mediaVolume, setMediaVolume];
  }, [mediaVolume, setMediaVolume]);
};
var useMediaMutedState = () => {
  const { mediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);
  const { setMediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return [mediaMuted, setMediaMuted];
  }, [mediaMuted, setMediaMuted]);
};

// src/volume-safeguard.ts
var warnAboutTooHighVolume = (volume) => {
  if (volume >= 100) {
    throw new Error(`Volume was set to ${volume}, but regular volume is 1, not 100. Did you forget to divide by 100? Set a volume of less than 100 to dismiss this error.`);
  }
};

// src/audio/AudioForPreview.tsx

var AudioForDevelopmentForwardRefFunction = (props, ref) => {
  const [initialShouldPreMountAudioElements] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.shouldPreMountAudioTags);
  if (props.shouldPreMountAudioTags !== initialShouldPreMountAudioElements) {
    throw new Error("Cannot change the behavior for pre-mounting audio tags dynamically.");
  }
  const logLevel = useLogLevel();
  const {
    volume,
    muted,
    playbackRate,
    shouldPreMountAudioTags,
    src,
    onDuration,
    acceptableTimeShiftInSeconds,
    _remotionInternalNeedsDurationCalculation,
    _remotionInternalNativeLoopPassed,
    _remotionInternalStack,
    allowAmplificationDuringRender,
    name,
    pauseWhenBuffering,
    showInTimeline,
    loopVolumeCurveBehavior,
    stack,
    crossOrigin,
    delayRenderRetries,
    delayRenderTimeoutInMilliseconds,
    toneFrequency,
    useWebAudioApi,
    onError,
    onNativeError,
    audioStreamIndex,
    ...nativeProps
  } = props;
  const _propsValid = true;
  if (!_propsValid) {
    throw new Error("typecheck error");
  }
  const [mediaVolume] = useMediaVolumeState();
  const [mediaMuted] = useMediaMutedState();
  const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? "repeat");
  const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);
  if (!src) {
    throw new TypeError("No 'src' was passed to <Html5Audio>.");
  }
  const preloadedSrc = usePreload(src);
  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);
  const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(Math.random()));
  const isSequenceHidden = hidden[timelineId] ?? false;
  const userPreferredVolume = evaluateVolume({
    frame: volumePropFrame,
    volume,
    mediaVolume
  });
  warnAboutTooHighVolume(userPreferredVolume);
  const crossOriginValue = getCrossOriginValue({
    crossOrigin,
    requestsVideoFrame: false,
    isClientSideRendering: false
  });
  const propsToPass = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,
      src: preloadedSrc,
      loop: _remotionInternalNativeLoopPassed,
      crossOrigin: crossOriginValue,
      ...nativeProps
    };
  }, [
    _remotionInternalNativeLoopPassed,
    isSequenceHidden,
    mediaMuted,
    muted,
    nativeProps,
    preloadedSrc,
    userPreferredVolume,
    crossOriginValue
  ]);
  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `audio-${random(src ?? "")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}-muted:${props.muted}-loop:${props.loop}`, [
    src,
    sequenceContext?.relativeFrom,
    sequenceContext?.cumulatedFrom,
    sequenceContext?.durationInFrames,
    props.muted,
    props.loop
  ]);
  const {
    el: audioRef,
    mediaElementSourceNode,
    cleanupOnMediaTagUnmount
  } = useSharedAudio({
    aud: propsToPass,
    audioId: id,
    premounting: Boolean(sequenceContext?.premounting),
    postmounting: Boolean(sequenceContext?.postmounting)
  });
  useMediaInTimeline({
    volume,
    mediaVolume,
    src,
    mediaType: "audio",
    playbackRate: playbackRate ?? 1,
    displayName: name ?? null,
    id: timelineId,
    stack: _remotionInternalStack,
    showInTimeline,
    premountDisplay: sequenceContext?.premountDisplay ?? null,
    postmountDisplay: sequenceContext?.postmountDisplay ?? null,
    loopDisplay: undefined
  });
  useMediaPlayback({
    mediaRef: audioRef,
    src,
    mediaType: "audio",
    playbackRate: playbackRate ?? 1,
    onlyWarnForMediaSeekingError: false,
    acceptableTimeshift: acceptableTimeShiftInSeconds ?? null,
    isPremounting: Boolean(sequenceContext?.premounting),
    isPostmounting: Boolean(sequenceContext?.postmounting),
    pauseWhenBuffering,
    onAutoPlayError: null
  });
  useMediaTag({
    id: timelineId,
    isPostmounting: Boolean(sequenceContext?.postmounting),
    isPremounting: Boolean(sequenceContext?.premounting),
    mediaRef: audioRef,
    mediaType: "audio",
    onAutoPlayError: null
  });
  useVolume({
    logLevel,
    mediaRef: audioRef,
    source: mediaElementSourceNode,
    volume: userPreferredVolume,
    shouldUseWebAudioApi: useWebAudioApi ?? false
  });
  const effectToUse = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect ?? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;
  effectToUse(() => {
    return () => {
      requestAnimationFrame(() => {
        cleanupOnMediaTagUnmount();
      });
    };
  }, [cleanupOnMediaTagUnmount]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {
    return audioRef.current;
  }, [audioRef]);
  const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDuration);
  currentOnDurationCallback.current = onDuration;
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const { current } = audioRef;
    if (!current) {
      return;
    }
    if (current.duration) {
      currentOnDurationCallback.current?.(current.src, current.duration);
      return;
    }
    const onLoadedMetadata = () => {
      currentOnDurationCallback.current?.(current.src, current.duration);
    };
    current.addEventListener("loadedmetadata", onLoadedMetadata);
    return () => {
      current.removeEventListener("loadedmetadata", onLoadedMetadata);
    };
  }, [audioRef, src]);
  if (initialShouldPreMountAudioElements) {
    return null;
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("audio", {
    ref: audioRef,
    preload: "metadata",
    crossOrigin: crossOriginValue,
    ...propsToPass
  });
};
var AudioForPreview = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForDevelopmentForwardRefFunction);

// src/audio/AudioForRendering.tsx


var AudioForRenderingRefForwardingFunction = (props, ref) => {
  const audioRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const {
    volume: volumeProp,
    playbackRate,
    allowAmplificationDuringRender,
    onDuration,
    toneFrequency,
    _remotionInternalNeedsDurationCalculation,
    _remotionInternalNativeLoopPassed,
    acceptableTimeShiftInSeconds,
    name,
    onNativeError,
    delayRenderRetries,
    delayRenderTimeoutInMilliseconds,
    loopVolumeCurveBehavior,
    pauseWhenBuffering,
    audioStreamIndex,
    ...nativeProps
  } = props;
  const absoluteFrame = useTimelinePosition();
  const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? "repeat");
  const frame = useCurrentFrame();
  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);
  const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);
  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();
  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `audio-${random(props.src ?? "")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}`, [
    props.src,
    sequenceContext?.relativeFrom,
    sequenceContext?.cumulatedFrom,
    sequenceContext?.durationInFrames
  ]);
  const volume = evaluateVolume({
    volume: volumeProp,
    frame: volumePropFrame,
    mediaVolume: 1
  });
  warnAboutTooHighVolume(volume);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {
    return audioRef.current;
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!props.src) {
      throw new Error("No src passed");
    }
    if (!window.remotion_audioEnabled) {
      return;
    }
    if (props.muted) {
      return;
    }
    if (volume <= 0) {
      return;
    }
    registerRenderAsset({
      type: "audio",
      src: getAbsoluteSrc(props.src),
      id,
      frame: absoluteFrame,
      volume,
      mediaFrame: frame,
      playbackRate: props.playbackRate ?? 1,
      toneFrequency: toneFrequency ?? 1,
      audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0)),
      audioStreamIndex: audioStreamIndex ?? 0
    });
    return () => unregisterRenderAsset(id);
  }, [
    props.muted,
    props.src,
    registerRenderAsset,
    absoluteFrame,
    id,
    unregisterRenderAsset,
    volume,
    volumePropFrame,
    frame,
    playbackRate,
    props.playbackRate,
    toneFrequency,
    sequenceContext?.relativeFrom,
    audioStreamIndex
  ]);
  const { src } = props;
  const needsToRenderAudioTag = ref || _remotionInternalNeedsDurationCalculation;
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
    if (window.process?.env?.NODE_ENV === "test") {
      return;
    }
    if (!needsToRenderAudioTag) {
      return;
    }
    const newHandle = delayRender2("Loading <Html5Audio> duration with src=" + src, {
      retries: delayRenderRetries ?? undefined,
      timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined
    });
    const { current } = audioRef;
    const didLoad = () => {
      if (current?.duration) {
        onDuration(current.src, current.duration);
      }
      continueRender2(newHandle);
    };
    if (current?.duration) {
      onDuration(current.src, current.duration);
      continueRender2(newHandle);
    } else {
      current?.addEventListener("loadedmetadata", didLoad, { once: true });
    }
    return () => {
      current?.removeEventListener("loadedmetadata", didLoad);
      continueRender2(newHandle);
    };
  }, [
    src,
    onDuration,
    needsToRenderAudioTag,
    delayRenderRetries,
    delayRenderTimeoutInMilliseconds,
    continueRender2,
    delayRender2
  ]);
  if (!needsToRenderAudioTag) {
    return null;
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("audio", {
    ref: audioRef,
    ...nativeProps,
    onError: onNativeError
  });
};
var AudioForRendering = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForRenderingRefForwardingFunction);

// src/audio/Audio.tsx

var AudioRefForwardingFunction = (props, ref) => {
  const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);
  const {
    startFrom,
    endAt,
    trimBefore,
    trimAfter,
    name,
    stack,
    pauseWhenBuffering,
    showInTimeline,
    onError: onRemotionError,
    ...otherProps
  } = props;
  const { loop, ...propsOtherThanLoop } = props;
  const { fps } = useVideoConfig();
  const environment = useRemotionEnvironment();
  if (environment.isClientSideRendering) {
    throw new Error("<Html5Audio> is not supported in @remotion/web-renderer. Use <Audio> from @remotion/media instead. See https://remotion.dev/docs/client-side-rendering/limitations");
  }
  const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);
  if (typeof props.src !== "string") {
    throw new TypeError(`The \`<Html5Audio>\` tag requires a string for \`src\`, but got ${JSON.stringify(props.src)} instead.`);
  }
  const preloadedSrc = usePreload(props.src);
  const onError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {
    console.log(e.currentTarget.error);
    const errMessage = `Could not play audio with src ${preloadedSrc}: ${e.currentTarget.error}. See https://remotion.dev/docs/media-playback-error for help.`;
    if (loop) {
      if (onRemotionError) {
        onRemotionError(new Error(errMessage));
        return;
      }
      cancelRender(new Error(errMessage));
    } else {
      onRemotionError?.(new Error(errMessage));
      console.warn(errMessage);
    }
  }, [loop, onRemotionError, preloadedSrc]);
  const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds) => {
    setDurations({ type: "got-duration", durationInSeconds, src });
  }, [setDurations]);
  const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props.src)];
  validateMediaTrimProps({ startFrom, endAt, trimBefore, trimAfter });
  const { trimBeforeValue, trimAfterValue } = resolveTrimProps({
    startFrom,
    endAt,
    trimBefore,
    trimAfter
  });
  if (loop && durationFetched !== undefined) {
    if (!Number.isFinite(durationFetched)) {
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Audio, {
        ...propsOtherThanLoop,
        ref,
        _remotionInternalNativeLoopPassed: true
      });
    }
    const duration = durationFetched * fps;
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {
      layout: "none",
      durationInFrames: calculateMediaDuration({
        trimAfter: trimAfterValue,
        mediaDurationInFrames: duration,
        playbackRate: props.playbackRate ?? 1,
        trimBefore: trimBeforeValue
      }),
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Audio, {
        ...propsOtherThanLoop,
        ref,
        _remotionInternalNativeLoopPassed: true
      })
    });
  }
  if (typeof trimBeforeValue !== "undefined" || typeof trimAfterValue !== "undefined") {
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {
      layout: "none",
      from: 0 - (trimBeforeValue ?? 0),
      showInTimeline: false,
      durationInFrames: trimAfterValue,
      name,
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Audio, {
        _remotionInternalNeedsDurationCalculation: Boolean(loop),
        pauseWhenBuffering: pauseWhenBuffering ?? false,
        ...otherProps,
        ref
      })
    });
  }
  validateMediaProps({ playbackRate: props.playbackRate, volume: props.volume }, "Html5Audio");
  if (environment.isRendering) {
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForRendering, {
      onDuration,
      ...props,
      ref,
      onNativeError: onError,
      _remotionInternalNeedsDurationCalculation: Boolean(loop)
    });
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForPreview, {
    _remotionInternalNativeLoopPassed: props._remotionInternalNativeLoopPassed ?? false,
    _remotionInternalStack: stack ?? null,
    shouldPreMountAudioTags: audioContext !== null && audioContext.numberOfAudioTags > 0,
    ...props,
    ref,
    onNativeError: onError,
    onDuration,
    pauseWhenBuffering: pauseWhenBuffering ?? false,
    _remotionInternalNeedsDurationCalculation: Boolean(loop),
    showInTimeline: showInTimeline ?? true
  });
};
var Html5Audio = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioRefForwardingFunction);
addSequenceStackTraces(Html5Audio);
var Audio = Html5Audio;
// src/Composition.tsx



// src/Folder.tsx


// src/validation/validate-folder-name.ts
var getRegex = () => /^([a-zA-Z0-9-\u4E00-\u9FFF])+$/g;
var isFolderNameValid = (name) => name.match(getRegex());
var validateFolderName = (name) => {
  if (name === undefined || name === null) {
    throw new TypeError("You must pass a name to a <Folder />.");
  }
  if (typeof name !== "string") {
    throw new TypeError(`The "name" you pass into <Folder /> must be a string. Got: ${typeof name}`);
  }
  if (!isFolderNameValid(name)) {
    throw new Error(`Folder name can only contain a-z, A-Z, 0-9 and -. You passed ${name}`);
  }
};
var invalidFolderNameErrorMessage = (/* unused pure expression or super */ null && (`Folder name must match ${String(getRegex())}`));

// src/Folder.tsx

var FolderContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  folderName: null,
  parentName: null
});
var Folder = ({ name, children }) => {
  const parent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);
  const { registerFolder, unregisterFolder } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);
  validateFolderName(name);
  const parentNameArr = [parent.parentName, parent.folderName].filter(truthy);
  const parentName = parentNameArr.length === 0 ? null : parentNameArr.join("/");
  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      folderName: name,
      parentName
    };
  }, [name, parentName]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    registerFolder(name, parentName);
    return () => {
      unregisterFolder(name, parentName);
    };
  }, [name, parent.folderName, parentName, registerFolder, unregisterFolder]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FolderContext.Provider, {
    value,
    children
  });
};

// src/loading-indicator.tsx

var rotate = {
  transform: `rotate(90deg)`
};
var ICON_SIZE = 40;
var label = {
  color: "white",
  fontSize: 14,
  fontFamily: "sans-serif"
};
var container = {
  justifyContent: "center",
  alignItems: "center"
};
var Loading = () => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(AbsoluteFill, {
    style: container,
    id: "remotion-comp-loading",
    children: [
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("style", {
        type: "text/css",
        children: `
				@keyframes anim {
					from {
						opacity: 0
					}
					to {
						opacity: 1
					}
				}
				#remotion-comp-loading {
					animation: anim 2s;
					animation-fill-mode: forwards;
				}
			`
      }),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("svg", {
        width: ICON_SIZE,
        height: ICON_SIZE,
        viewBox: "-100 -100 400 400",
        style: rotate,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("path", {
          fill: "#555",
          stroke: "#555",
          strokeWidth: "100",
          strokeLinejoin: "round",
          d: "M 2 172 a 196 100 0 0 0 195 5 A 196 240 0 0 0 100 2.259 A 196 240 0 0 0 2 172 z"
        })
      }),
      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)("p", {
        style: label,
        children: [
          "Resolving ",
          "<Suspense>",
          "..."
        ]
      })
    ]
  });
};

// src/portal-node.ts
var _portalNode = null;
var portalNode = () => {
  if (!_portalNode) {
    if (typeof document === "undefined") {
      throw new Error("Tried to call an API that only works in the browser from outside the browser");
    }
    _portalNode = document.createElement("div");
    _portalNode.style.position = "absolute";
    _portalNode.style.top = "0px";
    _portalNode.style.left = "0px";
    _portalNode.style.right = "0px";
    _portalNode.style.bottom = "0px";
    _portalNode.style.width = "100%";
    _portalNode.style.height = "100%";
    _portalNode.style.display = "flex";
    _portalNode.style.flexDirection = "column";
    const containerNode = document.createElement("div");
    containerNode.style.position = "fixed";
    containerNode.style.top = -999999 + "px";
    containerNode.appendChild(_portalNode);
    document.body.appendChild(containerNode);
  }
  return _portalNode;
};

// src/use-lazy-component.ts

var useLazyComponent = ({
  compProps,
  componentName,
  noSuspense
}) => {
  const lazy = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    if ("component" in compProps) {
      if (typeof document === "undefined" || noSuspense) {
        return compProps.component;
      }
      if (typeof compProps.component === "undefined") {
        throw new Error(`A value of \`undefined\` was passed to the \`component\` prop. Check the value you are passing to the <${componentName}/> component.`);
      }
      return compProps.component;
    }
    if ("lazyComponent" in compProps && typeof compProps.lazyComponent !== "undefined") {
      if (typeof compProps.lazyComponent === "undefined") {
        throw new Error(`A value of \`undefined\` was passed to the \`lazyComponent\` prop. Check the value you are passing to the <${componentName}/> component.`);
      }
      return react__WEBPACK_IMPORTED_MODULE_0__.lazy(compProps.lazyComponent);
    }
    throw new Error("You must pass either 'component' or 'lazyComponent'");
  }, [compProps.component, compProps.lazyComponent]);
  return lazy;
};

// src/validation/validate-composition-id.ts
var getRegex2 = () => /^([a-zA-Z0-9-\u4E00-\u9FFF])+$/g;
var isCompositionIdValid = (id) => id.match(getRegex2());
var validateCompositionId = (id) => {
  if (!isCompositionIdValid(id)) {
    throw new Error(`Composition id can only contain a-z, A-Z, 0-9, CJK characters and -. You passed ${id}`);
  }
};
var invalidCompositionErrorMessage = `Composition ID must match ${String(getRegex2())}`;

// src/validation/validate-default-props.ts
var validateDefaultAndInputProps = (defaultProps, name, compositionId) => {
  if (!defaultProps) {
    return;
  }
  if (typeof defaultProps !== "object") {
    throw new Error(`"${name}" must be an object, but you passed a value of type ${typeof defaultProps}`);
  }
  if (Array.isArray(defaultProps)) {
    throw new Error(`"${name}" must be an object, an array was passed ${compositionId ? `for composition "${compositionId}"` : ""}`);
  }
};

// src/Composition.tsx

var Fallback = () => {
  const { continueRender: continueRender2, delayRender: delayRender2 } = useDelayRender();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const fallback = delayRender2("Waiting for Root component to unsuspend");
    return () => continueRender2(fallback);
  }, [continueRender2, delayRender2]);
  return null;
};
var InnerComposition = ({
  width,
  height,
  fps,
  durationInFrames,
  id,
  defaultProps,
  schema,
  ...compProps
}) => {
  const compManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);
  const { registerComposition, unregisterComposition } = compManager;
  const video = useVideo();
  const lazy = useLazyComponent({
    compProps,
    componentName: "Composition",
    noSuspense: false
  });
  const nonce = useNonce();
  const isPlayer = useIsPlayer();
  const environment = useRemotionEnvironment();
  const canUseComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);
  if (typeof window !== "undefined") {
    window.remotion_seenCompositionIds = Array.from(new Set([...window.remotion_seenCompositionIds ?? [], id]));
  }
  if (canUseComposition) {
    if (isPlayer) {
      throw new Error("<Composition> was mounted inside the `component` that was passed to the <Player>. See https://remotion.dev/docs/wrong-composition-mount for help.");
    }
    throw new Error("<Composition> mounted inside another composition. See https://remotion.dev/docs/wrong-composition-mount for help.");
  }
  const { folderName, parentName } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!id) {
      throw new Error("No id for composition passed.");
    }
    validateCompositionId(id);
    validateDefaultAndInputProps(defaultProps, "defaultProps", id);
    registerComposition({
      durationInFrames: durationInFrames ?? undefined,
      fps: fps ?? undefined,
      height: height ?? undefined,
      width: width ?? undefined,
      id,
      folderName,
      component: lazy,
      defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),
      nonce,
      parentFolderName: parentName,
      schema: schema ?? null,
      calculateMetadata: compProps.calculateMetadata ?? null
    });
    return () => {
      unregisterComposition(id);
    };
  }, [
    durationInFrames,
    fps,
    height,
    lazy,
    id,
    folderName,
    defaultProps,
    width,
    nonce,
    parentName,
    schema,
    compProps.calculateMetadata,
    registerComposition,
    unregisterComposition
  ]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    window.dispatchEvent(new CustomEvent(PROPS_UPDATED_EXTERNALLY, {
      detail: {
        resetUnsaved: id
      }
    }));
  }, [defaultProps, id]);
  const resolved = useResolvedVideoConfig(id);
  if (environment.isStudio && video && video.component === lazy && video.id === id) {
    const Comp = lazy;
    if (resolved === null || resolved.type !== "success" && resolved.type !== "success-and-refreshing") {
      return null;
    }
    return (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {
        fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loading, {}),
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {
          ...resolved.result.props ?? {}
        })
      })
    }), portalNode());
  }
  if (environment.isRendering && video && video.component === lazy && video.id === id) {
    const Comp = lazy;
    if (resolved === null || resolved.type !== "success" && resolved.type !== "success-and-refreshing") {
      return null;
    }
    return (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {
        fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Fallback, {}),
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {
          ...resolved.result.props ?? {}
        })
      })
    }), portalNode());
  }
  return null;
};
var Composition = (props2) => {
  const { onlyRenderComposition } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);
  if (onlyRenderComposition && onlyRenderComposition !== props2.id) {
    return null;
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InnerComposition, {
    ...props2
  });
};
// src/bezier.ts
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
var float32ArraySupported = typeof Float32Array === "function";
function a(aA1, aA2) {
  return 1 - 3 * aA2 + 3 * aA1;
}
function b(aA1, aA2) {
  return 3 * aA2 - 6 * aA1;
}
function c(aA1) {
  return 3 * aA1;
}
function calcBezier(aT, aA1, aA2) {
  return ((a(aA1, aA2) * aT + b(aA1, aA2)) * aT + c(aA1)) * aT;
}
function getSlope(aT, aA1, aA2) {
  return 3 * a(aA1, aA2) * aT * aT + 2 * b(aA1, aA2) * aT + c(aA1);
}
function binarySubdivide({
  aX,
  _aA,
  _aB,
  mX1,
  mX2
}) {
  let currentX;
  let currentT;
  let i = 0;
  let aA = _aA;
  let aB = _aB;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}
function newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {
  let aGuessT = _aGuessT;
  for (let i = 0;i < NEWTON_ITERATIONS; ++i) {
    const currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
function bezier(mX1, mY1, mX2, mY2) {
  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {
    throw new Error("bezier x values must be in [0, 1] range");
  }
  const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  if (mX1 !== mY1 || mX2 !== mY2) {
    for (let i = 0;i < kSplineTableSize; ++i) {
      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
  }
  function getTForX(aX) {
    let intervalStart = 0;
    let currentSample = 1;
    const lastSample = kSplineTableSize - 1;
    for (;currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    const guessForT = intervalStart + dist * kSampleStepSize;
    const initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    }
    if (initialSlope === 0) {
      return guessForT;
    }
    return binarySubdivide({
      aX,
      _aA: intervalStart,
      _aB: intervalStart + kSampleStepSize,
      mX1,
      mX2
    });
  }
  return function(x) {
    if (mX1 === mY1 && mX2 === mY2) {
      return x;
    }
    if (x === 0) {
      return 0;
    }
    if (x === 1) {
      return 1;
    }
    return calcBezier(getTForX(x), mY1, mY2);
  };
}

// src/easing.ts
class Easing {
  static step0(n) {
    return n > 0 ? 1 : 0;
  }
  static step1(n) {
    return n >= 1 ? 1 : 0;
  }
  static linear(t) {
    return t;
  }
  static ease(t) {
    return Easing.bezier(0.42, 0, 1, 1)(t);
  }
  static quad(t) {
    return t * t;
  }
  static cubic(t) {
    return t * t * t;
  }
  static poly(n) {
    return (t) => t ** n;
  }
  static sin(t) {
    return 1 - Math.cos(t * Math.PI / 2);
  }
  static circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  static exp(t) {
    return 2 ** (10 * (t - 1));
  }
  static elastic(bounciness = 1) {
    const p = bounciness * Math.PI;
    return (t) => 1 - Math.cos(t * Math.PI / 2) ** 3 * Math.cos(t * p);
  }
  static back(s = 1.70158) {
    return (t) => t * t * ((s + 1) * t - s);
  }
  static bounce(t) {
    if (t < 1 / 2.75) {
      return 7.5625 * t * t;
    }
    if (t < 2 / 2.75) {
      const t2_ = t - 1.5 / 2.75;
      return 7.5625 * t2_ * t2_ + 0.75;
    }
    if (t < 2.5 / 2.75) {
      const t2_ = t - 2.25 / 2.75;
      return 7.5625 * t2_ * t2_ + 0.9375;
    }
    const t2 = t - 2.625 / 2.75;
    return 7.5625 * t2 * t2 + 0.984375;
  }
  static bezier(x1, y1, x2, y2) {
    return bezier(x1, y1, x2, y2);
  }
  static in(easing) {
    return easing;
  }
  static out(easing) {
    return (t) => 1 - easing(1 - t);
  }
  static inOut(easing) {
    return (t) => {
      if (t < 0.5) {
        return easing(t * 2) / 2;
      }
      return 1 - easing((1 - t) * 2) / 2;
    };
  }
}
// src/v5-flag.ts
var ENABLE_V5_BREAKING_CHANGES = false;

// src/get-static-files.ts
var warnedServer = false;
var warnedPlayer = false;
var warnServerOnce = () => {
  if (warnedServer) {
    return;
  }
  warnedServer = true;
  console.warn("Called getStaticFiles() on the server. The API is only available in the browser. An empty array was returned.");
};
var warnPlayerOnce = () => {
  if (warnedPlayer) {
    return;
  }
  warnedPlayer = true;
  console.warn("Called getStaticFiles() while using the Remotion Player. The API is only available while using the Remotion Studio. An empty array was returned.");
};
var getStaticFiles = () => {
  if (ENABLE_V5_BREAKING_CHANGES) {
    throw new Error("getStaticFiles() has moved into the `@remotion/studio` package. Update your imports.");
  }
  if (typeof document === "undefined") {
    warnServerOnce();
    return [];
  }
  if (window.remotion_isPlayer) {
    warnPlayerOnce();
    return [];
  }
  return window.remotion_staticFiles;
};
// src/IFrame.tsx


var IFrameRefForwarding = ({
  onLoad,
  onError,
  delayRenderRetries,
  delayRenderTimeoutInMilliseconds,
  ...props2
}, ref) => {
  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();
  const [handle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => delayRender2(`Loading <IFrame> with source ${props2.src}`, {
    retries: delayRenderRetries ?? undefined,
    timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined
  }));
  const didLoad = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {
    continueRender2(handle);
    onLoad?.(e);
  }, [handle, onLoad, continueRender2]);
  const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {
    continueRender2(handle);
    if (onError) {
      onError(e);
    } else {
      console.error("Error loading iframe:", e, "Handle the event using the onError() prop to make this message disappear.");
    }
  }, [handle, onError, continueRender2]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("iframe", {
    referrerPolicy: "strict-origin-when-cross-origin",
    ...props2,
    ref,
    onError: didGetError,
    onLoad: didLoad
  });
};
var IFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(IFrameRefForwarding);
// src/Img.tsx


function exponentialBackoff(errorCount) {
  return 1000 * 2 ** (errorCount - 1);
}
var ImgRefForwarding = ({
  onError,
  maxRetries = 2,
  src,
  pauseWhenLoading,
  delayRenderRetries,
  delayRenderTimeoutInMilliseconds,
  onImageFrame,
  crossOrigin,
  ...props2
}, ref) => {
  const imageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const errors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});
  const { delayPlayback } = useBufferState();
  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);
  if (!src) {
    throw new Error('No "src" prop was passed to <Img>.');
  }
  const _propsValid = true;
  if (!_propsValid) {
    throw new Error("typecheck error");
  }
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {
    return imageRef.current;
  }, []);
  const actualSrc = usePreload(src);
  const retryIn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((timeout) => {
    if (!imageRef.current) {
      return;
    }
    const currentSrc = imageRef.current.src;
    setTimeout(() => {
      if (!imageRef.current) {
        return;
      }
      const newSrc = imageRef.current?.src;
      if (newSrc !== currentSrc) {
        return;
      }
      imageRef.current.removeAttribute("src");
      imageRef.current.setAttribute("src", newSrc);
    }, timeout);
  }, []);
  const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {
    if (!errors.current) {
      return;
    }
    errors.current[imageRef.current?.src] = (errors.current[imageRef.current?.src] ?? 0) + 1;
    if (onError && (errors.current[imageRef.current?.src] ?? 0) > maxRetries) {
      onError(e);
      return;
    }
    if ((errors.current[imageRef.current?.src] ?? 0) <= maxRetries) {
      const backoff = exponentialBackoff(errors.current[imageRef.current?.src] ?? 0);
      console.warn(`Could not load image with source ${imageRef.current?.src}, retrying again in ${backoff}ms`);
      retryIn(backoff);
      return;
    }
    cancelRender("Error loading image with src: " + imageRef.current?.src);
  }, [maxRetries, onError, retryIn]);
  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();
  if (typeof window !== "undefined") {
    const isPremounting = Boolean(sequenceContext?.premounting);
    const isPostmounting = Boolean(sequenceContext?.postmounting);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
      if (window.process?.env?.NODE_ENV === "test") {
        if (imageRef.current) {
          imageRef.current.src = actualSrc;
        }
        return;
      }
      const { current } = imageRef;
      if (!current) {
        return;
      }
      const newHandle = delayRender2("Loading <Img> with src=" + actualSrc, {
        retries: delayRenderRetries ?? undefined,
        timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined
      });
      const unblock = pauseWhenLoading && !isPremounting && !isPostmounting ? delayPlayback().unblock : () => {
        return;
      };
      let unmounted = false;
      const onComplete = () => {
        if (unmounted) {
          continueRender2(newHandle);
          return;
        }
        if ((errors.current[imageRef.current?.src] ?? 0) > 0) {
          delete errors.current[imageRef.current?.src];
          console.info(`Retry successful - ${imageRef.current?.src} is now loaded`);
        }
        if (current) {
          onImageFrame?.(current);
        }
        unblock();
        continueRender2(newHandle);
      };
      if (!imageRef.current) {
        onComplete();
        return;
      }
      current.src = actualSrc;
      current.decode().then(onComplete).catch((err) => {
        console.warn(err);
        if (current.complete) {
          onComplete();
        } else {
          current.addEventListener("load", onComplete);
        }
      });
      return () => {
        unmounted = true;
        current.removeEventListener("load", onComplete);
        unblock();
        continueRender2(newHandle);
      };
    }, [
      actualSrc,
      delayPlayback,
      delayRenderRetries,
      delayRenderTimeoutInMilliseconds,
      pauseWhenLoading,
      isPremounting,
      isPostmounting,
      onImageFrame,
      continueRender2,
      delayRender2
    ]);
  }
  const { isClientSideRendering } = useRemotionEnvironment();
  const crossOriginValue = getCrossOriginValue({
    crossOrigin,
    requestsVideoFrame: false,
    isClientSideRendering
  });
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("img", {
    ...props2,
    ref: imageRef,
    crossOrigin: crossOriginValue,
    onError: didGetError,
    decoding: "sync"
  });
};
var Img = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ImgRefForwarding);
// src/internals.ts


// src/CompositionManager.tsx

var compositionsRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();

// src/CompositionManagerProvider.tsx


var CompositionManagerProvider = ({
  children,
  onlyRenderComposition,
  currentCompositionMetadata,
  initialCompositions,
  initialCanvasContent
}) => {
  const [folders, setFolders] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
  const [canvasContent, setCanvasContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialCanvasContent);
  const [compositions, setCompositions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialCompositions);
  const currentcompositionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(compositions);
  const updateCompositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updateComps) => {
    setCompositions((comps) => {
      const updated = updateComps(comps);
      currentcompositionsRef.current = updated;
      return updated;
    });
  }, []);
  const registerComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((comp) => {
    updateCompositions((comps) => {
      if (comps.find((c2) => c2.id === comp.id)) {
        throw new Error(`Multiple composition with id ${comp.id} are registered.`);
      }
      const value = [...comps, comp].slice().sort((a2, b2) => a2.nonce - b2.nonce);
      return value;
    });
  }, [updateCompositions]);
  const unregisterComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {
    setCompositions((comps) => {
      return comps.filter((c2) => c2.id !== id);
    });
  }, []);
  const registerFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent) => {
    setFolders((prevFolders) => {
      return [
        ...prevFolders,
        {
          name,
          parent
        }
      ];
    });
  }, []);
  const unregisterFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent) => {
    setFolders((prevFolders) => {
      return prevFolders.filter((p) => !(p.name === name && p.parent === parent));
    });
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(compositionsRef, () => {
    return {
      getCompositions: () => currentcompositionsRef.current
    };
  }, []);
  const updateCompositionDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id, newDefaultProps) => {
    setCompositions((comps) => {
      const updated = comps.map((c2) => {
        if (c2.id === id) {
          return {
            ...c2,
            defaultProps: newDefaultProps
          };
        }
        return c2;
      });
      return updated;
    });
  }, []);
  const compositionManagerSetters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      registerComposition,
      unregisterComposition,
      registerFolder,
      unregisterFolder,
      setCanvasContent,
      updateCompositionDefaultProps,
      onlyRenderComposition
    };
  }, [
    registerComposition,
    registerFolder,
    unregisterComposition,
    unregisterFolder,
    updateCompositionDefaultProps,
    onlyRenderComposition
  ]);
  const compositionManagerContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      compositions,
      folders,
      currentCompositionMetadata,
      canvasContent
    };
  }, [compositions, folders, currentCompositionMetadata, canvasContent]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {
    value: compositionManagerContextValue,
    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionSetters.Provider, {
      value: compositionManagerSetters,
      children
    })
  });
};

// src/default-css.ts
var exports_default_css = {};
__export(exports_default_css, {
  makeDefaultPreviewCSS: () => makeDefaultPreviewCSS,
  injectCSS: () => injectCSS,
  OBJECTFIT_CONTAIN_CLASS_NAME: () => OBJECTFIT_CONTAIN_CLASS_NAME
});
var injected = {};
var injectCSS = (css) => {
  if (typeof document === "undefined") {
    return () => {};
  }
  if (injected[css]) {
    return () => {};
  }
  const head = document.head || document.getElementsByTagName("head")[0];
  const style = document.createElement("style");
  style.appendChild(document.createTextNode(css));
  head.prepend(style);
  injected[css] = style;
  return () => {
    const styleElement = injected[css];
    if (styleElement) {
      if (styleElement.parentNode) {
        styleElement.parentNode.removeChild(styleElement);
      }
      delete injected[css];
    }
  };
};
var OBJECTFIT_CONTAIN_CLASS_NAME = "__remotion_objectfitcontain";
var makeDefaultPreviewCSS = (scope, backgroundColor) => {
  if (!scope) {
    return `
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
	    background-color: ${backgroundColor};
    }
    .${OBJECTFIT_CONTAIN_CLASS_NAME} {
      object-fit: contain;
    }
    `;
  }
  return `
    ${scope} * {
      box-sizing: border-box;
    }
    ${scope} *:-webkit-full-screen {
      width: 100%;
      height: 100%;
    }
    ${scope} .${OBJECTFIT_CONTAIN_CLASS_NAME} {
      object-fit: contain;
    }
  `;
};

// src/get-preview-dom-element.ts
var REMOTION_STUDIO_CONTAINER_ELEMENT = "__remotion-studio-container";
var getPreviewDomElement = () => {
  return document.getElementById(REMOTION_STUDIO_CONTAINER_ELEMENT);
};

// src/max-video-cache-size.ts

var MaxMediaCacheSizeContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);

// src/register-root.ts
var Root = null;
var listeners = [];
var registerRoot = (comp) => {
  if (!comp) {
    throw new Error(`You must pass a React component to registerRoot(), but ${JSON.stringify(comp)} was passed.`);
  }
  if (Root) {
    throw new Error("registerRoot() was called more than once.");
  }
  Root = comp;
  listeners.forEach((l) => {
    l(comp);
  });
};
var getRoot = () => {
  return Root;
};
var waitForRoot = (fn) => {
  if (Root) {
    fn(Root);
    return () => {
      return;
    };
  }
  listeners.push(fn);
  return () => {
    listeners = listeners.filter((l) => l !== fn);
  };
};

// src/RemotionRoot.tsx


// src/use-media-enabled.tsx


var MediaEnabledContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
var useVideoEnabled = () => {
  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaEnabledContext);
  if (!context) {
    return window.remotion_videoEnabled;
  }
  if (context.videoEnabled === null) {
    return window.remotion_videoEnabled;
  }
  return context.videoEnabled;
};
var useAudioEnabled = () => {
  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaEnabledContext);
  if (!context) {
    return window.remotion_audioEnabled;
  }
  if (context.audioEnabled === null) {
    return window.remotion_audioEnabled;
  }
  return context.audioEnabled;
};
var MediaEnabledProvider = ({
  children,
  videoEnabled,
  audioEnabled
}) => {
  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({ videoEnabled, audioEnabled }), [videoEnabled, audioEnabled]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MediaEnabledContext.Provider, {
    value,
    children
  });
};

// src/RemotionRoot.tsx

var RemotionRootContexts = ({
  children,
  numberOfAudioTags,
  logLevel,
  audioLatencyHint,
  videoEnabled,
  audioEnabled,
  frameState,
  nonceContextSeed
}) => {
  const nonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    let counter = 0;
    return {
      getNonce: () => counter++
    };
  }, [nonceContextSeed]);
  const logging = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return { logLevel, mountTime: Date.now() };
  }, [logLevel]);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LogLevelContext.Provider, {
    value: logging,
    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {
      value: nonceContext,
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContextProvider, {
        frameState,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MediaEnabledProvider, {
          videoEnabled,
          audioEnabled,
          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsProvider, {
            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PrefetchProvider, {
              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManagerProvider, {
                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SharedAudioContextProvider, {
                  numberOfAudioTags,
                  audioLatencyHint,
                  audioEnabled,
                  children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContextProvider, {
                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingProvider, {
                      children
                    })
                  })
                })
              })
            })
          })
        })
      })
    })
  });
};

// src/codec.ts
var validCodecs = [
  "h264",
  "h265",
  "vp8",
  "vp9",
  "mp3",
  "aac",
  "wav",
  "prores",
  "h264-mkv",
  "h264-ts",
  "gif"
];

// src/validation/validate-default-codec.ts
function validateCodec(defaultCodec, location, name) {
  if (typeof defaultCodec === "undefined") {
    return;
  }
  if (typeof defaultCodec !== "string") {
    throw new TypeError(`The "${name}" prop ${location} must be a string, but you passed a value of type ${typeof defaultCodec}.`);
  }
  if (!validCodecs.includes(defaultCodec)) {
    throw new Error(`The "${name}" prop ${location} must be one of ${validCodecs.join(", ")}, but you passed ${defaultCodec}.`);
  }
}

// src/resolve-video-config.ts
var validateCalculated = ({
  calculated,
  compositionId,
  compositionFps,
  compositionHeight,
  compositionWidth,
  compositionDurationInFrames
}) => {
  const calculateMetadataErrorLocation = `calculated by calculateMetadata() for the composition "${compositionId}"`;
  const defaultErrorLocation = `of the "<Composition />" component with the id "${compositionId}"`;
  const width = calculated?.width ?? compositionWidth ?? undefined;
  validateDimension(width, "width", calculated?.width ? calculateMetadataErrorLocation : defaultErrorLocation);
  const height = calculated?.height ?? compositionHeight ?? undefined;
  validateDimension(height, "height", calculated?.height ? calculateMetadataErrorLocation : defaultErrorLocation);
  const fps = calculated?.fps ?? compositionFps ?? null;
  validateFps(fps, calculated?.fps ? calculateMetadataErrorLocation : defaultErrorLocation, false);
  const durationInFrames = calculated?.durationInFrames ?? compositionDurationInFrames ?? null;
  validateDurationInFrames(durationInFrames, {
    allowFloats: false,
    component: `of the "<Composition />" component with the id "${compositionId}"`
  });
  const defaultCodec = calculated?.defaultCodec;
  validateCodec(defaultCodec, calculateMetadataErrorLocation, "defaultCodec");
  const defaultOutName = calculated?.defaultOutName;
  const defaultVideoImageFormat = calculated?.defaultVideoImageFormat;
  const defaultPixelFormat = calculated?.defaultPixelFormat;
  const defaultProResProfile = calculated?.defaultProResProfile;
  return {
    width,
    height,
    fps,
    durationInFrames,
    defaultCodec,
    defaultOutName,
    defaultVideoImageFormat,
    defaultPixelFormat,
    defaultProResProfile
  };
};
var resolveVideoConfig = ({
  calculateMetadata,
  signal,
  defaultProps,
  inputProps: originalProps,
  compositionId,
  compositionDurationInFrames,
  compositionFps,
  compositionHeight,
  compositionWidth
}) => {
  const calculatedProm = calculateMetadata ? calculateMetadata({
    defaultProps,
    props: originalProps,
    abortSignal: signal,
    compositionId,
    isRendering: getRemotionEnvironment().isRendering
  }) : null;
  if (calculatedProm !== null && typeof calculatedProm === "object" && "then" in calculatedProm) {
    return calculatedProm.then((c2) => {
      const {
        height,
        width,
        durationInFrames,
        fps,
        defaultCodec,
        defaultOutName,
        defaultVideoImageFormat,
        defaultPixelFormat,
        defaultProResProfile
      } = validateCalculated({
        calculated: c2,
        compositionDurationInFrames,
        compositionFps,
        compositionHeight,
        compositionWidth,
        compositionId
      });
      return {
        width,
        height,
        fps,
        durationInFrames,
        id: compositionId,
        defaultProps: serializeThenDeserializeInStudio(defaultProps),
        props: serializeThenDeserializeInStudio(c2.props ?? originalProps),
        defaultCodec: defaultCodec ?? null,
        defaultOutName: defaultOutName ?? null,
        defaultVideoImageFormat: defaultVideoImageFormat ?? null,
        defaultPixelFormat: defaultPixelFormat ?? null,
        defaultProResProfile: defaultProResProfile ?? null
      };
    });
  }
  const data = validateCalculated({
    calculated: calculatedProm,
    compositionDurationInFrames,
    compositionFps,
    compositionHeight,
    compositionWidth,
    compositionId
  });
  if (calculatedProm === null) {
    return {
      ...data,
      id: compositionId,
      defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),
      props: serializeThenDeserializeInStudio(originalProps),
      defaultCodec: null,
      defaultOutName: null,
      defaultVideoImageFormat: null,
      defaultPixelFormat: null,
      defaultProResProfile: null
    };
  }
  return {
    ...data,
    id: compositionId,
    defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),
    props: serializeThenDeserializeInStudio(calculatedProm.props ?? originalProps),
    defaultCodec: calculatedProm.defaultCodec ?? null,
    defaultOutName: calculatedProm.defaultOutName ?? null,
    defaultVideoImageFormat: calculatedProm.defaultVideoImageFormat ?? null,
    defaultPixelFormat: calculatedProm.defaultPixelFormat ?? null,
    defaultProResProfile: calculatedProm.defaultProResProfile ?? null
  };
};
var resolveVideoConfigOrCatch = (params) => {
  try {
    const promiseOrReturnValue = resolveVideoConfig(params);
    return {
      type: "success",
      result: promiseOrReturnValue
    };
  } catch (err) {
    return {
      type: "error",
      error: err
    };
  }
};

// src/setup-env-variables.ts
var getEnvVariables = () => {
  if (getRemotionEnvironment().isRendering) {
    const param = window.remotion_envVariables;
    if (!param) {
      return {};
    }
    return { ...JSON.parse(param), NODE_ENV: "production" };
  }
  if (false) // removed by dead control flow
{}
  return {
    NODE_ENV: "production"
  };
};
var setupEnvVariables = () => {
  const env = getEnvVariables();
  if (!window.process) {
    window.process = {};
  }
  if (!window.process.env) {
    window.process.env = {};
  }
  Object.keys(env).forEach((key) => {
    window.process.env[key] = env[key];
  });
};

// src/use-current-scale.ts

var CurrentScaleContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
var PreviewSizeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  setSize: () => {
    return;
  },
  size: { size: "auto", translation: { x: 0, y: 0 } }
});
var calculateScale = ({
  canvasSize,
  compositionHeight,
  compositionWidth,
  previewSize
}) => {
  const heightRatio = canvasSize.height / compositionHeight;
  const widthRatio = canvasSize.width / compositionWidth;
  const ratio = Math.min(heightRatio, widthRatio);
  if (previewSize === "auto") {
    if (ratio === 0) {
      return 1;
    }
    return ratio;
  }
  return Number(previewSize);
};
var useCurrentScale = (options) => {
  const hasContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CurrentScaleContext);
  const zoomContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreviewSizeContext);
  const config = useUnsafeVideoConfig();
  const env = useRemotionEnvironment();
  if (hasContext === null || config === null || zoomContext === null) {
    if (options?.dontThrowIfOutsideOfRemotion) {
      return 1;
    }
    if (env.isRendering) {
      return 1;
    }
    throw new Error([
      "useCurrentScale() was called outside of a Remotion context.",
      "This hook can only be called in a component that is being rendered by Remotion.",
      "If you want to this hook to return 1 outside of Remotion, pass {dontThrowIfOutsideOfRemotion: true} as an option.",
      "If you think you called this hook in a Remotion component, make sure all versions of Remotion are aligned."
    ].join(`
`));
  }
  if (hasContext.type === "scale") {
    return hasContext.scale;
  }
  return calculateScale({
    canvasSize: hasContext.canvasSize,
    compositionHeight: config.height,
    compositionWidth: config.width,
    previewSize: zoomContext.size.size
  });
};

// src/video/OffthreadVideo.tsx


// src/video/OffthreadVideoForRendering.tsx


// src/video/offthread-video-source.ts
var getOffthreadVideoSource = ({
  src,
  transparent,
  currentTime,
  toneMapped
}) => {
  return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(Math.max(0, currentTime))}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;
};

// src/video/OffthreadVideoForRendering.tsx

var OffthreadVideoForRendering = ({
  onError,
  volume: volumeProp,
  playbackRate,
  src,
  muted,
  allowAmplificationDuringRender,
  transparent,
  toneMapped,
  toneFrequency,
  name,
  loopVolumeCurveBehavior,
  delayRenderRetries,
  delayRenderTimeoutInMilliseconds,
  onVideoFrame,
  crossOrigin,
  audioStreamIndex,
  ...props2
}) => {
  const absoluteFrame = useTimelinePosition();
  const frame = useCurrentFrame();
  const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior);
  const videoConfig = useUnsafeVideoConfig();
  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);
  const mediaStartsAt = useMediaStartsAt();
  const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);
  if (!src) {
    throw new TypeError("No `src` was passed to <OffthreadVideo>.");
  }
  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `offthreadvideo-${random(src)}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`, [
    src,
    sequenceContext?.cumulatedFrom,
    sequenceContext?.relativeFrom,
    sequenceContext?.durationInFrames
  ]);
  if (!videoConfig) {
    throw new Error("No video config found");
  }
  const volume = evaluateVolume({
    volume: volumeProp,
    frame: volumePropsFrame,
    mediaVolume: 1
  });
  warnAboutTooHighVolume(volume);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!src) {
      throw new Error("No src passed");
    }
    if (!window.remotion_audioEnabled) {
      return;
    }
    if (muted) {
      return;
    }
    if (volume <= 0) {
      return;
    }
    registerRenderAsset({
      type: "video",
      src: getAbsoluteSrc(src),
      id,
      frame: absoluteFrame,
      volume,
      mediaFrame: frame,
      playbackRate,
      toneFrequency,
      audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0)),
      audioStreamIndex
    });
    return () => unregisterRenderAsset(id);
  }, [
    muted,
    src,
    registerRenderAsset,
    id,
    unregisterRenderAsset,
    volume,
    frame,
    absoluteFrame,
    playbackRate,
    toneFrequency,
    sequenceContext?.relativeFrom,
    audioStreamIndex
  ]);
  const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return getExpectedMediaFrameUncorrected({
      frame,
      playbackRate: playbackRate || 1,
      startFrom: -mediaStartsAt
    }) / videoConfig.fps;
  }, [frame, mediaStartsAt, playbackRate, videoConfig.fps]);
  const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return getOffthreadVideoSource({
      src,
      currentTime,
      transparent,
      toneMapped
    });
  }, [toneMapped, currentTime, src, transparent]);
  const [imageSrc, setImageSrc] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);
  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
    if (!window.remotion_videoEnabled) {
      return;
    }
    const cleanup = [];
    setImageSrc(null);
    const controller = new AbortController;
    const newHandle = delayRender2(`Fetching ${actualSrc} from server`, {
      retries: delayRenderRetries ?? undefined,
      timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined
    });
    const execute = async () => {
      try {
        const res = await fetch(actualSrc, {
          signal: controller.signal,
          cache: "no-store"
        });
        if (res.status !== 200) {
          if (res.status === 500) {
            const json = await res.json();
            if (json.error) {
              const cleanedUpErrorMessage = json.error.replace(/^Error: /, "");
              throw new Error(cleanedUpErrorMessage);
            }
          }
          throw new Error(`Server returned status ${res.status} while fetching ${actualSrc}`);
        }
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        cleanup.push(() => URL.revokeObjectURL(url));
        setImageSrc({
          src: url,
          handle: newHandle
        });
      } catch (err) {
        if (err.message.includes("aborted")) {
          continueRender2(newHandle);
          return;
        }
        if (controller.signal.aborted) {
          continueRender2(newHandle);
          return;
        }
        if (err.message.includes("Failed to fetch")) {
          err = new Error(`Failed to fetch ${actualSrc}. This could be caused by Chrome rejecting the request because the disk space is low. Consider increasing the disk size of your environment.`, { cause: err });
        }
        if (onError) {
          onError(err);
        } else {
          cancelRender(err);
        }
      }
    };
    execute();
    cleanup.push(() => {
      if (controller.signal.aborted) {
        return;
      }
      controller.abort();
    });
    return () => {
      cleanup.forEach((c2) => c2());
    };
  }, [
    actualSrc,
    delayRenderRetries,
    delayRenderTimeoutInMilliseconds,
    onError,
    continueRender2,
    delayRender2
  ]);
  const onErr = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
    if (onError) {
      onError?.(new Error("Failed to load image with src " + imageSrc));
    } else {
      cancelRender("Failed to load image with src " + imageSrc);
    }
  }, [imageSrc, onError]);
  const className = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return [OBJECTFIT_CONTAIN_CLASS_NAME, props2.className].filter(truthy).join(" ");
  }, [props2.className]);
  const onImageFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((img) => {
    if (onVideoFrame) {
      onVideoFrame(img);
    }
  }, [onVideoFrame]);
  if (!imageSrc || !window.remotion_videoEnabled) {
    return null;
  }
  continueRender2(imageSrc.handle);
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Img, {
    src: imageSrc.src,
    delayRenderRetries,
    delayRenderTimeoutInMilliseconds,
    onImageFrame,
    ...props2,
    onError: onErr,
    className
  });
};

// src/video/VideoForPreview.tsx


// src/video/emit-video-frame.ts

var useEmitVideoFrame = ({
  ref,
  onVideoFrame
}) => {
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const { current } = ref;
    if (!current) {
      return;
    }
    if (!onVideoFrame) {
      return;
    }
    let handle = 0;
    const callback = () => {
      if (!ref.current) {
        return;
      }
      onVideoFrame(ref.current);
      handle = ref.current.requestVideoFrameCallback(callback);
    };
    callback();
    return () => {
      current.cancelVideoFrameCallback(handle);
    };
  }, [onVideoFrame, ref]);
};

// src/video/VideoForPreview.tsx

var VideoForDevelopmentRefForwardingFunction = (props2, ref) => {
  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);
  if (!context) {
    throw new Error("SharedAudioContext not found");
  }
  const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const sharedSource = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    if (!context.audioContext) {
      return null;
    }
    return makeSharedElementSourceNode({
      audioContext: context.audioContext,
      ref: videoRef
    });
  }, [context.audioContext]);
  const effectToUse = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect ?? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;
  effectToUse(() => {
    return () => {
      requestAnimationFrame(() => {
        sharedSource?.cleanup();
      });
    };
  }, [sharedSource]);
  const {
    volume,
    muted,
    playbackRate,
    onlyWarnForMediaSeekingError,
    src,
    onDuration,
    acceptableTimeShift,
    acceptableTimeShiftInSeconds,
    toneFrequency,
    name,
    _remotionInternalNativeLoopPassed,
    _remotionInternalStack,
    style,
    pauseWhenBuffering,
    showInTimeline,
    loopVolumeCurveBehavior,
    onError,
    onAutoPlayError,
    onVideoFrame,
    crossOrigin,
    delayRenderRetries,
    delayRenderTimeoutInMilliseconds,
    allowAmplificationDuringRender,
    useWebAudioApi,
    audioStreamIndex,
    ...nativeProps
  } = props2;
  const _propsValid = true;
  if (!_propsValid) {
    throw new Error("typecheck error");
  }
  const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? "repeat");
  const { fps, durationInFrames } = useVideoConfig();
  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);
  const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);
  const logLevel = useLogLevel();
  const mountTime = useMountTime();
  const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(Math.random()));
  const isSequenceHidden = hidden[timelineId] ?? false;
  if (typeof acceptableTimeShift !== "undefined") {
    throw new Error("acceptableTimeShift has been removed. Use acceptableTimeShiftInSeconds instead.");
  }
  const [mediaVolume] = useMediaVolumeState();
  const [mediaMuted] = useMediaMutedState();
  const userPreferredVolume = evaluateVolume({
    frame: volumePropFrame,
    volume,
    mediaVolume
  });
  warnAboutTooHighVolume(userPreferredVolume);
  useMediaInTimeline({
    volume,
    mediaVolume,
    mediaType: "video",
    src,
    playbackRate: props2.playbackRate ?? 1,
    displayName: name ?? null,
    id: timelineId,
    stack: _remotionInternalStack,
    showInTimeline,
    premountDisplay: parentSequence?.premountDisplay ?? null,
    postmountDisplay: parentSequence?.postmountDisplay ?? null,
    loopDisplay: undefined
  });
  useMediaPlayback({
    mediaRef: videoRef,
    src,
    mediaType: "video",
    playbackRate: props2.playbackRate ?? 1,
    onlyWarnForMediaSeekingError,
    acceptableTimeshift: acceptableTimeShiftInSeconds ?? null,
    isPremounting: Boolean(parentSequence?.premounting),
    isPostmounting: Boolean(parentSequence?.postmounting),
    pauseWhenBuffering,
    onAutoPlayError: onAutoPlayError ?? null
  });
  useMediaTag({
    id: timelineId,
    isPostmounting: Boolean(parentSequence?.postmounting),
    isPremounting: Boolean(parentSequence?.premounting),
    mediaRef: videoRef,
    mediaType: "video",
    onAutoPlayError: onAutoPlayError ?? null
  });
  useVolume({
    logLevel,
    mediaRef: videoRef,
    volume: userPreferredVolume,
    source: sharedSource,
    shouldUseWebAudioApi: useWebAudioApi ?? false
  });
  const actualFrom = parentSequence ? parentSequence.relativeFrom : 0;
  const duration = parentSequence ? Math.min(parentSequence.durationInFrames, durationInFrames) : durationInFrames;
  const preloadedSrc = usePreload(src);
  const actualSrc = useAppendVideoFragment({
    actualSrc: preloadedSrc,
    actualFrom,
    duration,
    fps
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {
    return videoRef.current;
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => playbackLogging({
    logLevel,
    message: `Mounting video with source = ${actualSrc}, v=${VERSION}, user agent=${typeof navigator === "undefined" ? "server" : navigator.userAgent}`,
    tag: "video",
    mountTime
  }));
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const { current } = videoRef;
    if (!current) {
      return;
    }
    const errorHandler = () => {
      if (current.error) {
        console.error("Error occurred in video", current?.error);
        if (onError) {
          const err = new Error(`Code ${current.error.code}: ${current.error.message}`);
          onError(err);
          return;
        }
        throw new Error(`The browser threw an error while playing the video ${src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);
      } else {
        if (onError) {
          const err = new Error(`The browser threw an error while playing the video ${src}`);
          onError(err);
          return;
        }
        throw new Error("The browser threw an error while playing the video");
      }
    };
    current.addEventListener("error", errorHandler, { once: true });
    return () => {
      current.removeEventListener("error", errorHandler);
    };
  }, [onError, src]);
  const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDuration);
  currentOnDurationCallback.current = onDuration;
  useEmitVideoFrame({ ref: videoRef, onVideoFrame });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const { current } = videoRef;
    if (!current) {
      return;
    }
    if (current.duration) {
      currentOnDurationCallback.current?.(src, current.duration);
      return;
    }
    const onLoadedMetadata = () => {
      currentOnDurationCallback.current?.(src, current.duration);
    };
    current.addEventListener("loadedmetadata", onLoadedMetadata);
    return () => {
      current.removeEventListener("loadedmetadata", onLoadedMetadata);
    };
  }, [src]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const { current } = videoRef;
    if (!current) {
      return;
    }
    if (isIosSafari()) {
      current.preload = "metadata";
    } else {
      current.preload = "auto";
    }
  }, []);
  const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    return {
      ...style,
      opacity: isSequenceHidden ? 0 : style?.opacity ?? 1
    };
  }, [isSequenceHidden, style]);
  const crossOriginValue = getCrossOriginValue({
    crossOrigin,
    requestsVideoFrame: Boolean(onVideoFrame),
    isClientSideRendering: false
  });
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("video", {
    ref: videoRef,
    muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,
    playsInline: true,
    src: actualSrc,
    loop: _remotionInternalNativeLoopPassed,
    style: actualStyle,
    disableRemotePlayback: true,
    crossOrigin: crossOriginValue,
    ...nativeProps
  });
};
var VideoForPreview = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForDevelopmentRefForwardingFunction);

// src/video/OffthreadVideo.tsx

var InnerOffthreadVideo = (props2) => {
  const {
    startFrom,
    endAt,
    trimBefore,
    trimAfter,
    name,
    pauseWhenBuffering,
    stack,
    showInTimeline,
    ...otherProps
  } = props2;
  const environment = useRemotionEnvironment();
  if (environment.isClientSideRendering) {
    throw new Error("<OffthreadVideo> is not supported in @remotion/web-renderer. Use <Video> from @remotion/media instead. See https://remotion.dev/docs/client-side-rendering/limitations");
  }
  const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
    return;
  }, []);
  if (typeof props2.src !== "string") {
    throw new TypeError(`The \`<OffthreadVideo>\` tag requires a string for \`src\`, but got ${JSON.stringify(props2.src)} instead.`);
  }
  validateMediaTrimProps({ startFrom, endAt, trimBefore, trimAfter });
  const { trimBeforeValue, trimAfterValue } = resolveTrimProps({
    startFrom,
    endAt,
    trimBefore,
    trimAfter
  });
  if (typeof trimBeforeValue !== "undefined" || typeof trimAfterValue !== "undefined") {
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {
      layout: "none",
      from: 0 - (trimBeforeValue ?? 0),
      showInTimeline: false,
      durationInFrames: trimAfterValue,
      name,
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InnerOffthreadVideo, {
        pauseWhenBuffering: pauseWhenBuffering ?? false,
        ...otherProps,
        trimAfter: undefined,
        name: undefined,
        showInTimeline,
        trimBefore: undefined,
        stack: undefined,
        startFrom: undefined,
        endAt: undefined
      })
    });
  }
  validateMediaProps(props2, "Video");
  if (environment.isRendering) {
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideoForRendering, {
      pauseWhenBuffering: pauseWhenBuffering ?? false,
      ...otherProps,
      trimAfter: undefined,
      name: undefined,
      showInTimeline,
      trimBefore: undefined,
      stack: undefined,
      startFrom: undefined,
      endAt: undefined
    });
  }
  const {
    transparent,
    toneMapped,
    onAutoPlayError,
    onVideoFrame,
    crossOrigin,
    delayRenderRetries,
    delayRenderTimeoutInMilliseconds,
    ...propsForPreview
  } = otherProps;
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {
    _remotionInternalStack: stack ?? null,
    onDuration,
    onlyWarnForMediaSeekingError: true,
    pauseWhenBuffering: pauseWhenBuffering ?? false,
    showInTimeline: showInTimeline ?? true,
    onAutoPlayError: onAutoPlayError ?? undefined,
    onVideoFrame: onVideoFrame ?? null,
    crossOrigin,
    ...propsForPreview,
    _remotionInternalNativeLoopPassed: false
  });
};
var OffthreadVideo = ({
  src,
  acceptableTimeShiftInSeconds,
  allowAmplificationDuringRender,
  audioStreamIndex,
  className,
  crossOrigin,
  delayRenderRetries,
  delayRenderTimeoutInMilliseconds,
  id,
  loopVolumeCurveBehavior,
  muted,
  name,
  onAutoPlayError,
  onError,
  onVideoFrame,
  pauseWhenBuffering,
  playbackRate,
  showInTimeline,
  style,
  toneFrequency,
  toneMapped,
  transparent,
  trimAfter,
  trimBefore,
  useWebAudioApi,
  volume,
  _remotionInternalNativeLoopPassed,
  endAt,
  stack,
  startFrom,
  imageFormat
}) => {
  if (imageFormat) {
    throw new TypeError(`The \`<OffthreadVideo>\` tag does no longer accept \`imageFormat\`. Use the \`transparent\` prop if you want to render a transparent video.`);
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InnerOffthreadVideo, {
    acceptableTimeShiftInSeconds,
    allowAmplificationDuringRender: allowAmplificationDuringRender ?? true,
    audioStreamIndex: audioStreamIndex ?? 0,
    className,
    crossOrigin,
    delayRenderRetries,
    delayRenderTimeoutInMilliseconds,
    id,
    loopVolumeCurveBehavior: loopVolumeCurveBehavior ?? "repeat",
    muted: muted ?? false,
    name,
    onAutoPlayError: onAutoPlayError ?? null,
    onError,
    onVideoFrame,
    pauseWhenBuffering: pauseWhenBuffering ?? true,
    playbackRate: playbackRate ?? 1,
    toneFrequency: toneFrequency ?? 1,
    showInTimeline: showInTimeline ?? true,
    src,
    stack,
    startFrom,
    _remotionInternalNativeLoopPassed: _remotionInternalNativeLoopPassed ?? false,
    endAt,
    style,
    toneMapped: toneMapped ?? true,
    transparent: transparent ?? false,
    trimAfter,
    trimBefore,
    useWebAudioApi: useWebAudioApi ?? false,
    volume
  });
};
addSequenceStackTraces(OffthreadVideo);

// src/watch-static-file.ts
var WATCH_REMOTION_STATIC_FILES = "remotion_staticFilesChanged";
var watchStaticFile = (fileName, callback) => {
  if (ENABLE_V5_BREAKING_CHANGES) {
    throw new Error("watchStaticFile() has moved into the `@remotion/studio` package. Update your imports.");
  }
  if (!getRemotionEnvironment().isStudio) {
    console.warn("The watchStaticFile() API is only available while using the Remotion Studio.");
    return { cancel: () => {
      return;
    } };
  }
  const withoutStaticBase = fileName.startsWith(window.remotion_staticBase) ? fileName.replace(window.remotion_staticBase, "") : fileName;
  const withoutLeadingSlash = withoutStaticBase.startsWith("/") ? withoutStaticBase.slice(1) : withoutStaticBase;
  let prevFileData = window.remotion_staticFiles.find((file) => file.name === withoutLeadingSlash);
  const checkFile = (event) => {
    const staticFiles = event.detail.files;
    const newFileData = staticFiles.find((file) => file.name === withoutLeadingSlash);
    if (!newFileData) {
      if (prevFileData !== undefined) {
        callback(null);
      }
      prevFileData = undefined;
      return;
    }
    if (prevFileData === undefined || prevFileData.lastModified !== newFileData.lastModified) {
      callback(newFileData);
      prevFileData = newFileData;
    }
  };
  window.addEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);
  const cancel = () => {
    return window.removeEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);
  };
  return { cancel };
};

// src/wrap-remotion-context.tsx


function useRemotionContexts() {
  const compositionManagerCtx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositionManager);
  const timelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(TimelineContext);
  const setTimelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SetTimelineContext);
  const sequenceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceContext);
  const nonceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NonceContext);
  const canUseRemotionHooksContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CanUseRemotionHooks);
  const preloadContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreloadContext);
  const resolveCompositionContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ResolveCompositionContext);
  const renderAssetManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RenderAssetManager);
  const sequenceManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceManager);
  const bufferManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(BufferingContextReact);
  const logLevelContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({
    compositionManagerCtx,
    timelineContext,
    setTimelineContext,
    sequenceContext,
    nonceContext,
    canUseRemotionHooksContext,
    preloadContext,
    resolveCompositionContext,
    renderAssetManagerContext,
    sequenceManagerContext,
    bufferManagerContext,
    logLevelContext
  }), [
    compositionManagerCtx,
    nonceContext,
    sequenceContext,
    setTimelineContext,
    timelineContext,
    canUseRemotionHooksContext,
    preloadContext,
    resolveCompositionContext,
    renderAssetManagerContext,
    sequenceManagerContext,
    bufferManagerContext,
    logLevelContext
  ]);
}
var RemotionContextProvider = (props2) => {
  const { children, contexts } = props2;
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LogLevelContext.Provider, {
    value: contexts.logLevelContext,
    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {
      value: contexts.canUseRemotionHooksContext,
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {
        value: contexts.nonceContext,
        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {
          value: contexts.preloadContext,
          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {
            value: contexts.compositionManagerCtx,
            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {
              value: contexts.sequenceManagerContext,
              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {
                value: contexts.renderAssetManagerContext,
                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {
                  value: contexts.resolveCompositionContext,
                  children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {
                    value: contexts.timelineContext,
                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {
                      value: contexts.setTimelineContext,
                      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {
                        value: contexts.sequenceContext,
                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {
                          value: contexts.bufferManagerContext,
                          children
                        })
                      })
                    })
                  })
                })
              })
            })
          })
        })
      })
    })
  });
};

// src/internals.ts
var compositionSelectorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();
var Internals = {
  MaxMediaCacheSizeContext,
  useUnsafeVideoConfig,
  useFrameForVolumeProp,
  useTimelinePosition,
  evaluateVolume,
  getAbsoluteSrc,
  Timeline: exports_timeline_position_state,
  validateMediaTrimProps,
  validateMediaProps,
  resolveTrimProps,
  VideoForPreview,
  CompositionManager,
  CompositionSetters,
  SequenceManager,
  SequenceVisibilityToggleContext,
  RemotionRootContexts,
  CompositionManagerProvider,
  useVideo,
  getRoot,
  useMediaVolumeState,
  useMediaMutedState,
  useMediaInTimeline,
  useLazyComponent,
  truthy,
  SequenceContext,
  useRemotionContexts,
  RemotionContextProvider,
  CSSUtils: exports_default_css,
  setupEnvVariables,
  MediaVolumeContext,
  SetMediaVolumeContext,
  getRemotionEnvironment,
  SharedAudioContext,
  SharedAudioContextProvider,
  invalidCompositionErrorMessage,
  calculateMediaDuration,
  isCompositionIdValid,
  getPreviewDomElement,
  compositionsRef,
  portalNode,
  waitForRoot,
  SetTimelineContext,
  CanUseRemotionHooksProvider,
  CanUseRemotionHooks,
  PrefetchProvider,
  DurationsContextProvider,
  IsPlayerContextProvider,
  useIsPlayer,
  EditorPropsProvider,
  EditorPropsContext,
  usePreload,
  NonceContext,
  resolveVideoConfig,
  resolveVideoConfigOrCatch,
  ResolveCompositionContext,
  useResolvedVideoConfig,
  resolveCompositionsRef,
  REMOTION_STUDIO_CONTAINER_ELEMENT,
  RenderAssetManager,
  persistCurrentFrame,
  useTimelineSetFrame,
  isIosSafari,
  WATCH_REMOTION_STATIC_FILES,
  addSequenceStackTraces,
  useMediaStartsAt,
  BufferingProvider,
  BufferingContextReact,
  enableSequenceStackTraces,
  CurrentScaleContext,
  PreviewSizeContext,
  calculateScale,
  editorPropsProviderRef,
  PROPS_UPDATED_EXTERNALLY,
  validateRenderAsset,
  Log,
  LogLevelContext,
  useLogLevel,
  playbackLogging,
  timeValueRef,
  compositionSelectorRef,
  RemotionEnvironmentContext,
  warnAboutTooHighVolume,
  AudioForPreview,
  OBJECTFIT_CONTAIN_CLASS_NAME,
  InnerOffthreadVideo,
  useBasicMediaInTimeline,
  getInputPropsOverride,
  setInputPropsOverride,
  useVideoEnabled,
  useAudioEnabled,
  useIsPlayerBuffering,
  TimelinePosition: exports_timeline_position_state,
  DelayRenderContextType,
  TimelineContext,
  RenderAssetManagerProvider
};
// src/interpolate-colors.ts
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...args) {
  return "\\(\\s*(" + args.join(")\\s*,\\s*(") + ")\\s*\\)";
}
function getMatchers() {
  const cachedMatchers = {
    rgb: undefined,
    rgba: undefined,
    hsl: undefined,
    hsla: undefined,
    hex3: undefined,
    hex4: undefined,
    hex5: undefined,
    hex6: undefined,
    hex8: undefined
  };
  if (cachedMatchers.rgb === undefined) {
    cachedMatchers.rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
    cachedMatchers.rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
    cachedMatchers.hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
    cachedMatchers.hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
    cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;
    cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;
  }
  return cachedMatchers;
}
function hue2rgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslToRgb(h, s, l) {
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b2 = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b2 * 255) << 8;
}
function parse255(str) {
  const int = Number.parseInt(str, 10);
  if (int < 0) {
    return 0;
  }
  if (int > 255) {
    return 255;
  }
  return int;
}
function parse360(str) {
  const int = Number.parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = Number.parseFloat(str);
  if (num < 0) {
    return 0;
  }
  if (num > 1) {
    return 255;
  }
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = Number.parseFloat(str);
  if (int < 0) {
    return 0;
  }
  if (int > 100) {
    return 1;
  }
  return int / 100;
}
var colorNames = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
function normalizeColor(color) {
  const matchers = getMatchers();
  let match;
  if (matchers.hex6) {
    if (match = matchers.hex6.exec(color)) {
      return Number.parseInt(match[1] + "ff", 16) >>> 0;
    }
  }
  if (colorNames[color] !== undefined) {
    return colorNames[color];
  }
  if (matchers.rgb) {
    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;
    }
  }
  if (matchers.rgba) {
    if (match = matchers.rgba.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
    }
  }
  if (matchers.hex3) {
    if (match = matchers.hex3.exec(color)) {
      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + "ff", 16) >>> 0;
    }
  }
  if (matchers.hex8) {
    if (match = matchers.hex8.exec(color)) {
      return Number.parseInt(match[1], 16) >>> 0;
    }
  }
  if (matchers.hex4) {
    if (match = matchers.hex4.exec(color)) {
      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
    }
  }
  if (matchers.hsl) {
    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;
    }
  }
  if (matchers.hsla) {
    if (match = matchers.hsla.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
    }
  }
  throw new Error(`invalid color string ${color} provided`);
}
var opacity = (c2) => {
  return (c2 >> 24 & 255) / 255;
};
var red = (c2) => {
  return c2 >> 16 & 255;
};
var green = (c2) => {
  return c2 >> 8 & 255;
};
var blue = (c2) => {
  return c2 & 255;
};
var rgbaColor = (r, g, b2, alpha) => {
  return `rgba(${r}, ${g}, ${b2}, ${alpha})`;
};
function processColor(color) {
  const normalizedColor = normalizeColor(color);
  return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;
}
var interpolateColorsRGB = (value, inputRange, colors) => {
  const [r, g, b2, a2] = [red, green, blue, opacity].map((f) => {
    const unrounded = interpolate(value, inputRange, colors.map((c2) => f(c2)), {
      extrapolateLeft: "clamp",
      extrapolateRight: "clamp"
    });
    if (f === opacity) {
      return Number(unrounded.toFixed(3));
    }
    return Math.round(unrounded);
  });
  return rgbaColor(r, g, b2, a2);
};
var interpolateColors = (input, inputRange, outputRange) => {
  if (typeof input === "undefined") {
    throw new TypeError("input can not be undefined");
  }
  if (typeof inputRange === "undefined") {
    throw new TypeError("inputRange can not be undefined");
  }
  if (typeof outputRange === "undefined") {
    throw new TypeError("outputRange can not be undefined");
  }
  if (inputRange.length !== outputRange.length) {
    throw new TypeError("inputRange (" + inputRange.length + " values provided) and outputRange (" + outputRange.length + " values provided) must have the same length");
  }
  const processedOutputRange = outputRange.map((c2) => processColor(c2));
  return interpolateColorsRGB(input, inputRange, processedOutputRange);
};
// src/validate-frame.ts
var validateFrame = ({
  allowFloats,
  durationInFrames,
  frame
}) => {
  if (typeof frame === "undefined") {
    throw new TypeError(`Argument missing for parameter "frame"`);
  }
  if (typeof frame !== "number") {
    throw new TypeError(`Argument passed for "frame" is not a number: ${frame}`);
  }
  if (!Number.isFinite(frame)) {
    throw new RangeError(`Frame ${frame} is not finite`);
  }
  if (frame % 1 !== 0 && !allowFloats) {
    throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);
  }
  if (frame < 0 && frame < -durationInFrames) {
    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);
  }
  if (frame > durationInFrames - 1) {
    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);
  }
};
// src/series/index.tsx


// src/series/flatten-children.tsx

var flattenChildren = (children) => {
  const childrenArray = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children);
  return childrenArray.reduce((flatChildren, child) => {
    if (child.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
      return flatChildren.concat(flattenChildren(child.props.children));
    }
    flatChildren.push(child);
    return flatChildren;
  }, []);
};

// src/series/is-inside-series.tsx


var IsInsideSeriesContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);
var IsInsideSeriesContainer = ({ children }) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {
    value: true,
    children
  });
};
var IsNotInsideSeriesProvider = ({ children }) => {
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {
    value: false,
    children
  });
};
var useRequireToBeInsideSeries = () => {
  const isInsideSeries = react__WEBPACK_IMPORTED_MODULE_0__.useContext(IsInsideSeriesContext);
  if (!isInsideSeries) {
    throw new Error("This component must be inside a <Series /> component.");
  }
};

// src/series/index.tsx

var SeriesSequenceRefForwardingFunction = ({ children }, _ref) => {
  useRequireToBeInsideSeries();
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsNotInsideSeriesProvider, {
    children
  });
};
var SeriesSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SeriesSequenceRefForwardingFunction);
var Series = (props2) => {
  const childrenValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    let startFrame = 0;
    const flattenedChildren = flattenChildren(props2.children);
    return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(flattenedChildren, (child, i) => {
      const castedChild = child;
      if (typeof castedChild === "string") {
        if (castedChild.trim() === "") {
          return null;
        }
        throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but you passed a string "${castedChild}"`);
      }
      if (castedChild.type !== SeriesSequence) {
        throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but got ${castedChild} instead`);
      }
      const debugInfo = `index = ${i}, duration = ${castedChild.props.durationInFrames}`;
      if (!castedChild?.props.children) {
        throw new TypeError(`A <Series.Sequence /> component (${debugInfo}) was detected to not have any children. Delete it to fix this error.`);
      }
      const durationInFramesProp = castedChild.props.durationInFrames;
      const {
        durationInFrames,
        children: _children,
        from,
        name,
        ...passedProps
      } = castedChild.props;
      if (i !== flattenedChildren.length - 1 || durationInFramesProp !== Infinity) {
        validateDurationInFrames(durationInFramesProp, {
          component: `of a <Series.Sequence /> component`,
          allowFloats: true
        });
      }
      const offset = castedChild.props.offset ?? 0;
      if (Number.isNaN(offset)) {
        throw new TypeError(`The "offset" property of a <Series.Sequence /> must not be NaN, but got NaN (${debugInfo}).`);
      }
      if (!Number.isFinite(offset)) {
        throw new TypeError(`The "offset" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);
      }
      if (offset % 1 !== 0) {
        throw new TypeError(`The "offset" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);
      }
      const currentStartFrame = startFrame + offset;
      startFrame += durationInFramesProp + offset;
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {
        name: name || "<Series.Sequence>",
        from: currentStartFrame,
        durationInFrames: durationInFramesProp,
        ...passedProps,
        ref: castedChild.ref,
        children: child
      });
    });
  }, [props2.children]);
  if (ENABLE_V5_BREAKING_CHANGES) {
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {
        ...props2,
        children: childrenValue
      })
    });
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {
    children: childrenValue
  });
};
Series.Sequence = SeriesSequence;
addSequenceStackTraces(SeriesSequence);
// src/validation/validation-spring-duration.ts
var validateSpringDuration = (dur) => {
  if (typeof dur === "undefined") {
    return;
  }
  if (typeof dur !== "number") {
    throw new TypeError(`A "duration" of a spring must be a "number" but is "${typeof dur}"`);
  }
  if (Number.isNaN(dur)) {
    throw new TypeError('A "duration" of a spring is NaN, which it must not be');
  }
  if (!Number.isFinite(dur)) {
    throw new TypeError('A "duration" of a spring must be finite, but is ' + dur);
  }
  if (dur <= 0) {
    throw new TypeError('A "duration" of a spring must be positive, but is ' + dur);
  }
};

// src/spring/spring-utils.ts
var defaultSpringConfig = {
  damping: 10,
  mass: 1,
  stiffness: 100,
  overshootClamping: false
};
var advanceCache = {};
function advance({
  animation,
  now,
  config
}) {
  const { toValue, lastTimestamp, current, velocity } = animation;
  const deltaTime = Math.min(now - lastTimestamp, 64);
  if (config.damping <= 0) {
    throw new Error("Spring damping must be greater than 0, otherwise the spring() animation will never end, causing an infinite loop.");
  }
  const c2 = config.damping;
  const m = config.mass;
  const k = config.stiffness;
  const cacheKey = [
    toValue,
    lastTimestamp,
    current,
    velocity,
    c2,
    m,
    k,
    now
  ].join("-");
  if (advanceCache[cacheKey]) {
    return advanceCache[cacheKey];
  }
  const v0 = -velocity;
  const x0 = toValue - current;
  const zeta = c2 / (2 * Math.sqrt(k * m));
  const omega0 = Math.sqrt(k / m);
  const omega1 = omega0 * Math.sqrt(1 - zeta ** 2);
  const t = deltaTime / 1000;
  const sin1 = Math.sin(omega1 * t);
  const cos1 = Math.cos(omega1 * t);
  const underDampedEnvelope = Math.exp(-zeta * omega0 * t);
  const underDampedFrag1 = underDampedEnvelope * (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);
  const underDampedPosition = toValue - underDampedFrag1;
  const underDampedVelocity = zeta * omega0 * underDampedFrag1 - underDampedEnvelope * (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);
  const criticallyDampedEnvelope = Math.exp(-omega0 * t);
  const criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);
  const criticallyDampedVelocity = criticallyDampedEnvelope * (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);
  const animationNode = {
    toValue,
    prevPosition: current,
    lastTimestamp: now,
    current: zeta < 1 ? underDampedPosition : criticallyDampedPosition,
    velocity: zeta < 1 ? underDampedVelocity : criticallyDampedVelocity
  };
  advanceCache[cacheKey] = animationNode;
  return animationNode;
}
var calculationCache = {};
function springCalculation({
  frame,
  fps,
  config = {}
}) {
  const from = 0;
  const to = 1;
  const cacheKey = [
    frame,
    fps,
    config.damping,
    config.mass,
    config.overshootClamping,
    config.stiffness
  ].join("-");
  if (calculationCache[cacheKey]) {
    return calculationCache[cacheKey];
  }
  let animation = {
    lastTimestamp: 0,
    current: from,
    toValue: to,
    velocity: 0,
    prevPosition: 0
  };
  const frameClamped = Math.max(0, frame);
  const unevenRest = frameClamped % 1;
  for (let f = 0;f <= Math.floor(frameClamped); f++) {
    if (f === Math.floor(frameClamped)) {
      f += unevenRest;
    }
    const time = f / fps * 1000;
    animation = advance({
      animation,
      now: time,
      config: {
        ...defaultSpringConfig,
        ...config
      }
    });
  }
  calculationCache[cacheKey] = animation;
  return animation;
}

// src/spring/measure-spring.ts
var cache = new Map;
function measureSpring({
  fps,
  config = {},
  threshold = 0.005
}) {
  if (typeof threshold !== "number") {
    throw new TypeError(`threshold must be a number, got ${threshold} of type ${typeof threshold}`);
  }
  if (threshold === 0) {
    return Infinity;
  }
  if (threshold === 1) {
    return 0;
  }
  if (isNaN(threshold)) {
    throw new TypeError("Threshold is NaN");
  }
  if (!Number.isFinite(threshold)) {
    throw new TypeError("Threshold is not finite");
  }
  if (threshold < 0) {
    throw new TypeError("Threshold is below 0");
  }
  const cacheKey = [
    fps,
    config.damping,
    config.mass,
    config.overshootClamping,
    config.stiffness,
    threshold
  ].join("-");
  if (cache.has(cacheKey)) {
    return cache.get(cacheKey);
  }
  validateFps(fps, "to the measureSpring() function", false);
  let frame = 0;
  let finishedFrame = 0;
  const calc = () => {
    return springCalculation({
      fps,
      frame,
      config
    });
  };
  let animation = calc();
  const calcDifference = () => {
    return Math.abs(animation.current - animation.toValue);
  };
  let difference = calcDifference();
  while (difference >= threshold) {
    frame++;
    animation = calc();
    difference = calcDifference();
  }
  finishedFrame = frame;
  for (let i = 0;i < 20; i++) {
    frame++;
    animation = calc();
    difference = calcDifference();
    if (difference >= threshold) {
      i = 0;
      finishedFrame = frame + 1;
    }
  }
  cache.set(cacheKey, finishedFrame);
  return finishedFrame;
}

// src/spring/index.ts
function spring({
  frame: passedFrame,
  fps,
  config = {},
  from = 0,
  to = 1,
  durationInFrames: passedDurationInFrames,
  durationRestThreshold,
  delay = 0,
  reverse = false
}) {
  validateSpringDuration(passedDurationInFrames);
  validateFrame({
    frame: passedFrame,
    durationInFrames: Infinity,
    allowFloats: true
  });
  validateFps(fps, "to spring()", false);
  const needsToCalculateNaturalDuration = reverse || typeof passedDurationInFrames !== "undefined";
  const naturalDuration = needsToCalculateNaturalDuration ? measureSpring({
    fps,
    config,
    threshold: durationRestThreshold
  }) : undefined;
  const naturalDurationGetter = needsToCalculateNaturalDuration ? {
    get: () => naturalDuration
  } : {
    get: () => {
      throw new Error("did not calculate natural duration, this is an error with Remotion. Please report");
    }
  };
  const reverseProcessed = reverse ? (passedDurationInFrames ?? naturalDurationGetter.get()) - passedFrame : passedFrame;
  const delayProcessed = reverseProcessed + (reverse ? delay : -delay);
  const durationProcessed = passedDurationInFrames === undefined ? delayProcessed : delayProcessed / (passedDurationInFrames / naturalDurationGetter.get());
  if (passedDurationInFrames && delayProcessed > passedDurationInFrames) {
    return to;
  }
  const spr = springCalculation({
    fps,
    frame: durationProcessed,
    config
  });
  const inner = config.overshootClamping ? to >= from ? Math.min(spr.current, to) : Math.max(spr.current, to) : spr.current;
  const interpolated = from === 0 && to === 1 ? inner : interpolate(inner, [0, 1], [from, to]);
  return interpolated;
}
// src/static-file.ts
var problematicCharacters = {
  "%3A": ":",
  "%2F": "/",
  "%3F": "?",
  "%23": "#",
  "%5B": "[",
  "%5D": "]",
  "%40": "@",
  "%21": "!",
  "%24": "$",
  "%26": "&",
  "%27": "'",
  "%28": "(",
  "%29": ")",
  "%2A": "*",
  "%2B": "+",
  "%2C": ",",
  "%3B": ";"
};
var didWarn2 = {};
var warnOnce3 = (message) => {
  if (didWarn2[message]) {
    return;
  }
  console.warn(message);
  didWarn2[message] = true;
};
var includesHexOfUnsafeChar = (path) => {
  for (const key of Object.keys(problematicCharacters)) {
    if (path.includes(key)) {
      return { containsHex: true, hexCode: key };
    }
  }
  return { containsHex: false };
};
var trimLeadingSlash = (path) => {
  if (path.startsWith("/")) {
    return trimLeadingSlash(path.substring(1));
  }
  return path;
};
var inner = (path) => {
  if (typeof window !== "undefined" && window.remotion_staticBase) {
    if (path.startsWith(window.remotion_staticBase)) {
      throw new Error(`The value "${path}" is already prefixed with the static base ${window.remotion_staticBase}. You don't need to call staticFile() on it.`);
    }
    return `${window.remotion_staticBase}/${trimLeadingSlash(path)}`;
  }
  return `/${trimLeadingSlash(path)}`;
};
var encodeBySplitting = (path) => {
  const splitBySlash = path.split("/");
  const encodedArray = splitBySlash.map((element) => {
    return encodeURIComponent(element);
  });
  const merged = encodedArray.join("/");
  return merged;
};
var staticFile = (path) => {
  if (path === null) {
    throw new TypeError("null was passed to staticFile()");
  }
  if (typeof path === "undefined") {
    throw new TypeError("undefined was passed to staticFile()");
  }
  if (path.startsWith("http://") || path.startsWith("https://")) {
    throw new TypeError(`staticFile() does not support remote URLs - got "${path}". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);
  }
  if (path.startsWith("..") || path.startsWith("./")) {
    throw new TypeError(`staticFile() does not support relative paths - got "${path}". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);
  }
  if (path.startsWith("/Users") || path.startsWith("/home") || path.startsWith("/tmp") || path.startsWith("/etc") || path.startsWith("/opt") || path.startsWith("/var") || path.startsWith("C:") || path.startsWith("D:") || path.startsWith("E:")) {
    throw new TypeError(`staticFile() does not support absolute paths - got "${path}". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);
  }
  if (path.startsWith("public/")) {
    throw new TypeError(`Do not include the public/ prefix when using staticFile() - got "${path}". See: https://remotion.dev/docs/staticfile-relative-paths`);
  }
  const includesHex = includesHexOfUnsafeChar(path);
  if (includesHex.containsHex) {
    warnOnce3(`WARNING: You seem to pass an already encoded path (path contains ${includesHex.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);
  }
  const preprocessed = encodeBySplitting(path);
  const preparsed = inner(preprocessed);
  if (!preparsed.startsWith("/")) {
    return `/${preparsed}`;
  }
  return preparsed;
};
// src/Still.tsx

var Still = (props2) => {
  const newProps = {
    ...props2,
    durationInFrames: 1,
    fps: 1
  };
  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Composition, newProps);
};
// src/video/Video.tsx


// src/video/VideoForRendering.tsx


// src/video/seek-until-right.ts
var roundTo6Commas = (num) => {
  return Math.round(num * 1e5) / 1e5;
};
var seekToTime = ({
  element,
  desiredTime,
  logLevel,
  mountTime
}) => {
  if (isApproximatelyTheSame(element.currentTime, desiredTime)) {
    return {
      wait: Promise.resolve(desiredTime),
      cancel: () => {}
    };
  }
  seek({
    logLevel,
    mediaRef: element,
    time: desiredTime,
    why: "Seeking during rendering",
    mountTime
  });
  let cancel;
  let cancelSeeked = null;
  const prom = new Promise((resolve) => {
    cancel = element.requestVideoFrameCallback((now, metadata) => {
      const displayIn = metadata.expectedDisplayTime - now;
      if (displayIn <= 0) {
        resolve(metadata.mediaTime);
        return;
      }
      setTimeout(() => {
        resolve(metadata.mediaTime);
      }, displayIn + 150);
    });
  });
  const waitForSeekedEvent = new Promise((resolve) => {
    const onDone = () => {
      resolve();
    };
    element.addEventListener("seeked", onDone, {
      once: true
    });
    cancelSeeked = () => {
      element.removeEventListener("seeked", onDone);
    };
  });
  return {
    wait: Promise.all([prom, waitForSeekedEvent]).then(([time]) => time),
    cancel: () => {
      cancelSeeked?.();
      element.cancelVideoFrameCallback(cancel);
    }
  };
};
var seekToTimeMultipleUntilRight = ({
  element,
  desiredTime,
  fps,
  logLevel,
  mountTime
}) => {
  const threshold = 1 / fps / 2;
  let currentCancel = () => {
    return;
  };
  if (Number.isFinite(element.duration) && element.currentTime >= element.duration && desiredTime >= element.duration) {
    return {
      prom: Promise.resolve(),
      cancel: () => {}
    };
  }
  const prom = new Promise((resolve, reject) => {
    const firstSeek = seekToTime({
      element,
      desiredTime: desiredTime + threshold,
      logLevel,
      mountTime
    });
    firstSeek.wait.then((seekedTo) => {
      const difference = Math.abs(desiredTime - seekedTo);
      if (difference <= threshold) {
        return resolve();
      }
      const sign = desiredTime > seekedTo ? 1 : -1;
      const newSeek = seekToTime({
        element,
        desiredTime: seekedTo + threshold * sign,
        logLevel,
        mountTime
      });
      currentCancel = newSeek.cancel;
      newSeek.wait.then((newTime) => {
        const newDifference = Math.abs(desiredTime - newTime);
        if (roundTo6Commas(newDifference) <= roundTo6Commas(threshold)) {
          return resolve();
        }
        const thirdSeek = seekToTime({
          element,
          desiredTime: desiredTime + threshold,
          logLevel,
          mountTime
        });
        currentCancel = thirdSeek.cancel;
        return thirdSeek.wait.then(() => {
          resolve();
        }).catch((err) => {
          reject(err);
        });
      }).catch((err) => {
        reject(err);
      });
    });
    currentCancel = firstSeek.cancel;
  });
  return {
    prom,
    cancel: () => {
      currentCancel();
    }
  };
};

// src/video/VideoForRendering.tsx

var VideoForRenderingForwardFunction = ({
  onError,
  volume: volumeProp,
  allowAmplificationDuringRender,
  playbackRate,
  onDuration,
  toneFrequency,
  name,
  acceptableTimeShiftInSeconds,
  delayRenderRetries,
  delayRenderTimeoutInMilliseconds,
  loopVolumeCurveBehavior,
  audioStreamIndex,
  onVideoFrame,
  ...props2
}, ref) => {
  const absoluteFrame = useTimelinePosition();
  const frame = useCurrentFrame();
  const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? "repeat");
  const videoConfig = useUnsafeVideoConfig();
  const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);
  const mediaStartsAt = useMediaStartsAt();
  const environment = useRemotionEnvironment();
  const logLevel = useLogLevel();
  const mountTime = useMountTime();
  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();
  const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);
  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `video-${random(props2.src ?? "")}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`, [
    props2.src,
    sequenceContext?.cumulatedFrom,
    sequenceContext?.relativeFrom,
    sequenceContext?.durationInFrames
  ]);
  if (!videoConfig) {
    throw new Error("No video config found");
  }
  const volume = evaluateVolume({
    volume: volumeProp,
    frame: volumePropsFrame,
    mediaVolume: 1
  });
  warnAboutTooHighVolume(volume);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!props2.src) {
      throw new Error("No src passed");
    }
    if (props2.muted) {
      return;
    }
    if (volume <= 0) {
      return;
    }
    if (!window.remotion_audioEnabled) {
      return;
    }
    registerRenderAsset({
      type: "video",
      src: getAbsoluteSrc(props2.src),
      id,
      frame: absoluteFrame,
      volume,
      mediaFrame: frame,
      playbackRate: playbackRate ?? 1,
      toneFrequency: toneFrequency ?? 1,
      audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0)),
      audioStreamIndex: audioStreamIndex ?? 0
    });
    return () => unregisterRenderAsset(id);
  }, [
    props2.muted,
    props2.src,
    registerRenderAsset,
    id,
    unregisterRenderAsset,
    volume,
    frame,
    absoluteFrame,
    playbackRate,
    toneFrequency,
    sequenceContext?.relativeFrom,
    audioStreamIndex
  ]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {
    return videoRef.current;
  }, []);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!window.remotion_videoEnabled) {
      return;
    }
    const { current } = videoRef;
    if (!current) {
      return;
    }
    const currentTime = getMediaTime({
      frame,
      playbackRate: playbackRate || 1,
      startFrom: -mediaStartsAt,
      fps: videoConfig.fps
    });
    const handle = delayRender2(`Rendering <Html5Video /> with src="${props2.src}" at time ${currentTime}`, {
      retries: delayRenderRetries ?? undefined,
      timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined
    });
    if (window.process?.env?.NODE_ENV === "test") {
      continueRender2(handle);
      return;
    }
    if (isApproximatelyTheSame(current.currentTime, currentTime)) {
      if (current.readyState >= 2) {
        continueRender2(handle);
        return;
      }
      const loadedDataHandler = () => {
        continueRender2(handle);
      };
      current.addEventListener("loadeddata", loadedDataHandler, { once: true });
      return () => {
        current.removeEventListener("loadeddata", loadedDataHandler);
      };
    }
    const endedHandler = () => {
      continueRender2(handle);
    };
    const seek2 = seekToTimeMultipleUntilRight({
      element: current,
      desiredTime: currentTime,
      fps: videoConfig.fps,
      logLevel,
      mountTime
    });
    seek2.prom.then(() => {
      continueRender2(handle);
    });
    current.addEventListener("ended", endedHandler, { once: true });
    const errorHandler = () => {
      if (current?.error) {
        console.error("Error occurred in video", current?.error);
        if (onError) {
          return;
        }
        throw new Error(`The browser threw an error while playing the video ${props2.src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);
      } else {
        throw new Error("The browser threw an error");
      }
    };
    current.addEventListener("error", errorHandler, { once: true });
    return () => {
      seek2.cancel();
      current.removeEventListener("ended", endedHandler);
      current.removeEventListener("error", errorHandler);
      continueRender2(handle);
    };
  }, [
    volumePropsFrame,
    props2.src,
    playbackRate,
    videoConfig.fps,
    frame,
    mediaStartsAt,
    onError,
    delayRenderRetries,
    delayRenderTimeoutInMilliseconds,
    logLevel,
    mountTime,
    continueRender2,
    delayRender2
  ]);
  const { src } = props2;
  if (environment.isRendering) {
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {
      if (window.process?.env?.NODE_ENV === "test") {
        return;
      }
      const newHandle = delayRender2("Loading <Html5Video> duration with src=" + src, {
        retries: delayRenderRetries ?? undefined,
        timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined
      });
      const { current } = videoRef;
      const didLoad = () => {
        if (current?.duration) {
          onDuration(src, current.duration);
        }
        continueRender2(newHandle);
      };
      if (current?.duration) {
        onDuration(src, current.duration);
        continueRender2(newHandle);
      } else {
        current?.addEventListener("loadedmetadata", didLoad, { once: true });
      }
      return () => {
        current?.removeEventListener("loadedmetadata", didLoad);
        continueRender2(newHandle);
      };
    }, [
      src,
      onDuration,
      delayRenderRetries,
      delayRenderTimeoutInMilliseconds,
      continueRender2,
      delayRender2
    ]);
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("video", {
    ref: videoRef,
    disableRemotePlayback: true,
    ...props2
  });
};
var VideoForRendering = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForRenderingForwardFunction);

// src/video/Video.tsx

var VideoForwardingFunction = (props2, ref) => {
  const {
    startFrom,
    endAt,
    trimBefore,
    trimAfter,
    name,
    pauseWhenBuffering,
    stack,
    _remotionInternalNativeLoopPassed,
    showInTimeline,
    onAutoPlayError,
    ...otherProps
  } = props2;
  const { loop, ...propsOtherThanLoop } = props2;
  const { fps } = useVideoConfig();
  const environment = useRemotionEnvironment();
  if (environment.isClientSideRendering) {
    throw new Error("<Html5Video> is not supported in @remotion/web-renderer. Use <Video> from @remotion/media instead. See https://remotion.dev/docs/client-side-rendering/limitations");
  }
  const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);
  if (typeof ref === "string") {
    throw new Error("string refs are not supported");
  }
  if (typeof props2.src !== "string") {
    throw new TypeError(`The \`<Html5Video>\` tag requires a string for \`src\`, but got ${JSON.stringify(props2.src)} instead.`);
  }
  const preloadedSrc = usePreload(props2.src);
  const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds) => {
    setDurations({ type: "got-duration", durationInSeconds, src });
  }, [setDurations]);
  const onVideoFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {}, []);
  const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props2.src)];
  validateMediaTrimProps({ startFrom, endAt, trimBefore, trimAfter });
  const { trimBeforeValue, trimAfterValue } = resolveTrimProps({
    startFrom,
    endAt,
    trimBefore,
    trimAfter
  });
  if (loop && durationFetched !== undefined) {
    if (!Number.isFinite(durationFetched)) {
      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Video, {
        ...propsOtherThanLoop,
        ref,
        stack,
        _remotionInternalNativeLoopPassed: true
      });
    }
    const mediaDuration = durationFetched * fps;
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {
      durationInFrames: calculateMediaDuration({
        trimAfter: trimAfterValue,
        mediaDurationInFrames: mediaDuration,
        playbackRate: props2.playbackRate ?? 1,
        trimBefore: trimBeforeValue
      }),
      layout: "none",
      name,
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Video, {
        ...propsOtherThanLoop,
        ref,
        stack,
        _remotionInternalNativeLoopPassed: true
      })
    });
  }
  if (typeof trimBeforeValue !== "undefined" || typeof trimAfterValue !== "undefined") {
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {
      layout: "none",
      from: 0 - (trimBeforeValue ?? 0),
      showInTimeline: false,
      durationInFrames: trimAfterValue === undefined ? undefined : trimAfterValue / (props2.playbackRate ?? 1),
      name,
      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Video, {
        pauseWhenBuffering: pauseWhenBuffering ?? false,
        ...otherProps,
        ref,
        stack
      })
    });
  }
  validateMediaProps({ playbackRate: props2.playbackRate, volume: props2.volume }, "Html5Video");
  if (environment.isRendering) {
    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForRendering, {
      onDuration,
      onVideoFrame: onVideoFrame ?? null,
      ...otherProps,
      ref
    });
  }
  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {
    onlyWarnForMediaSeekingError: false,
    ...otherProps,
    ref,
    onVideoFrame: null,
    pauseWhenBuffering: pauseWhenBuffering ?? false,
    onDuration,
    _remotionInternalStack: stack ?? null,
    _remotionInternalNativeLoopPassed: _remotionInternalNativeLoopPassed ?? false,
    showInTimeline: showInTimeline ?? true,
    onAutoPlayError: onAutoPlayError ?? undefined
  });
};
var Html5Video = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForwardingFunction);
addSequenceStackTraces(Html5Video);
var Video = Html5Video;
// src/index.ts
checkMultipleRemotionVersions();
var Experimental = {
  Clipper,
  Null,
  useIsPlayer
};
var proxyObj = {};
var Config = new Proxy(proxyObj, {
  get(_, prop) {
    if (prop === "Bundling" || prop === "Rendering" || prop === "Log" || prop === "Puppeteer" || prop === "Output") {
      return Config;
    }
    return () => {
      console.warn("  The CLI configuration has been extracted from Remotion Core.");
      console.warn("Update the import from the config file:");
      console.warn();
      console.warn("- Delete:");
      console.warn('import {Config} from "remotion";');
      console.warn("+ Replace:");
      console.warn('import {Config} from "@remotion/cli/config";');
      console.warn();
      console.warn("For more information, see https://www.remotion.dev/docs/4-0-migration.");
      process.exit(1);
    };
  }
});
addSequenceStackTraces(Sequence);



/***/ },

/***/ 9382
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NoReactInternals: () => (/* binding */ NoReactInternals),
/* harmony export */   interpolate: () => (/* binding */ interpolate),
/* harmony export */   random: () => (/* binding */ random)
/* harmony export */ });
// src/interpolate.ts
function interpolateFunction(input, inputRange, outputRange, options) {
  const { extrapolateLeft, extrapolateRight, easing } = options;
  let result = input;
  const [inputMin, inputMax] = inputRange;
  const [outputMin, outputMax] = outputRange;
  if (result < inputMin) {
    if (extrapolateLeft === "identity") {
      return result;
    }
    if (extrapolateLeft === "clamp") {
      result = inputMin;
    } else if (extrapolateLeft === "wrap") {
      const range = inputMax - inputMin;
      result = ((result - inputMin) % range + range) % range + inputMin;
    } else if (extrapolateLeft === "extend") {}
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity") {
      return result;
    }
    if (extrapolateRight === "clamp") {
      result = inputMax;
    } else if (extrapolateRight === "wrap") {
      const range = inputMax - inputMin;
      result = ((result - inputMin) % range + range) % range + inputMin;
    } else if (extrapolateRight === "extend") {}
  }
  if (outputMin === outputMax) {
    return outputMin;
  }
  result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  let i;
  for (i = 1;i < inputRange.length - 1; ++i) {
    if (inputRange[i] >= input) {
      break;
    }
  }
  return i - 1;
}
function checkValidInputRange(arr) {
  for (let i = 1;i < arr.length; ++i) {
    if (!(arr[i] > arr[i - 1])) {
      throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(",")}]`);
    }
  }
}
function checkInfiniteRange(name, arr) {
  if (arr.length < 2) {
    throw new Error(name + " must have at least 2 elements");
  }
  for (const element of arr) {
    if (typeof element !== "number") {
      throw new Error(`${name} must contain only numbers`);
    }
    if (!Number.isFinite(element)) {
      throw new Error(`${name} must contain only finite numbers, but got [${arr.join(",")}]`);
    }
  }
}
function interpolate(input, inputRange, outputRange, options) {
  if (typeof input === "undefined") {
    throw new Error("input can not be undefined");
  }
  if (typeof inputRange === "undefined") {
    throw new Error("inputRange can not be undefined");
  }
  if (typeof outputRange === "undefined") {
    throw new Error("outputRange can not be undefined");
  }
  if (inputRange.length !== outputRange.length) {
    throw new Error("inputRange (" + inputRange.length + ") and outputRange (" + outputRange.length + ") must have the same length");
  }
  checkInfiniteRange("inputRange", inputRange);
  checkInfiniteRange("outputRange", outputRange);
  checkValidInputRange(inputRange);
  const easing = options?.easing ?? ((num) => num);
  let extrapolateLeft = "extend";
  if (options?.extrapolateLeft !== undefined) {
    extrapolateLeft = options.extrapolateLeft;
  }
  let extrapolateRight = "extend";
  if (options?.extrapolateRight !== undefined) {
    extrapolateRight = options.extrapolateRight;
  }
  if (typeof input !== "number") {
    throw new TypeError("Cannot interpolate an input which is not a number");
  }
  const range = findRange(input, inputRange);
  return interpolateFunction(input, [inputRange[range], inputRange[range + 1]], [outputRange[range], outputRange[range + 1]], {
    easing,
    extrapolateLeft,
    extrapolateRight
  });
}
// src/random.ts
function mulberry32(a) {
  let t = a + 1831565813;
  t = Math.imul(t ^ t >>> 15, t | 1);
  t ^= t + Math.imul(t ^ t >>> 7, t | 61);
  return ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function hashCode(str) {
  let i = 0;
  let chr = 0;
  let hash = 0;
  for (i = 0;i < str.length; i++) {
    chr = str.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  return hash;
}
var random = (seed, dummy) => {
  if (dummy !== undefined) {
    throw new TypeError("random() takes only one argument");
  }
  if (seed === null) {
    return Math.random();
  }
  if (typeof seed === "string") {
    return mulberry32(hashCode(seed));
  }
  if (typeof seed === "number") {
    return mulberry32(seed * 10000000000);
  }
  throw new Error("random() argument must be a number or a string");
};
// src/truthy.ts
function truthy(value) {
  return Boolean(value);
}

// src/delay-render.ts
if (typeof window !== "undefined") {
  window.remotion_renderReady = false;
  if (!window.remotion_delayRenderTimeouts) {
    window.remotion_delayRenderTimeouts = {};
  }
  window.remotion_delayRenderHandles = [];
}
var DELAY_RENDER_CALLSTACK_TOKEN = "The delayRender was called:";
var DELAY_RENDER_RETRIES_LEFT = "Retries left: ";
var DELAY_RENDER_RETRY_TOKEN = "- Rendering the frame will be retried.";
var DELAY_RENDER_CLEAR_TOKEN = "handle was cleared after";

// src/input-props-serialization.ts
var DATE_TOKEN = "remotion-date:";
var FILE_TOKEN = "remotion-file:";
var serializeJSONWithSpecialTypes = ({
  data,
  indent,
  staticBase
}) => {
  let customDateUsed = false;
  let customFileUsed = false;
  let mapUsed = false;
  let setUsed = false;
  try {
    const serializedString = JSON.stringify(data, function(key, value) {
      const item = this[key];
      if (item instanceof Date) {
        customDateUsed = true;
        return `${DATE_TOKEN}${item.toISOString()}`;
      }
      if (item instanceof Map) {
        mapUsed = true;
        return value;
      }
      if (item instanceof Set) {
        setUsed = true;
        return value;
      }
      if (typeof item === "string" && staticBase !== null && item.startsWith(staticBase)) {
        customFileUsed = true;
        return `${FILE_TOKEN}${item.replace(staticBase + "/", "")}`;
      }
      return value;
    }, indent);
    return { serializedString, customDateUsed, customFileUsed, mapUsed, setUsed };
  } catch (err) {
    throw new Error("Could not serialize the passed input props to JSON: " + err.message);
  }
};
var deserializeJSONWithSpecialTypes = (data) => {
  return JSON.parse(data, (_, value) => {
    if (typeof value === "string" && value.startsWith(DATE_TOKEN)) {
      return new Date(value.replace(DATE_TOKEN, ""));
    }
    if (typeof value === "string" && value.startsWith(FILE_TOKEN)) {
      return `${window.remotion_staticBase}/${value.replace(FILE_TOKEN, "")}`;
    }
    return value;
  });
};

// src/interpolate-colors.ts
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...args) {
  return "\\(\\s*(" + args.join(")\\s*,\\s*(") + ")\\s*\\)";
}
function getMatchers() {
  const cachedMatchers = {
    rgb: undefined,
    rgba: undefined,
    hsl: undefined,
    hsla: undefined,
    hex3: undefined,
    hex4: undefined,
    hex5: undefined,
    hex6: undefined,
    hex8: undefined
  };
  if (cachedMatchers.rgb === undefined) {
    cachedMatchers.rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
    cachedMatchers.rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
    cachedMatchers.hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
    cachedMatchers.hsla = new RegExp("hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
    cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;
    cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;
  }
  return cachedMatchers;
}
function hue2rgb(p, q, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function hslToRgb(h, s, l) {
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
function parse255(str) {
  const int = Number.parseInt(str, 10);
  if (int < 0) {
    return 0;
  }
  if (int > 255) {
    return 255;
  }
  return int;
}
function parse360(str) {
  const int = Number.parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = Number.parseFloat(str);
  if (num < 0) {
    return 0;
  }
  if (num > 1) {
    return 255;
  }
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = Number.parseFloat(str);
  if (int < 0) {
    return 0;
  }
  if (int > 100) {
    return 1;
  }
  return int / 100;
}
var colorNames = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
function normalizeColor(color) {
  const matchers = getMatchers();
  let match;
  if (matchers.hex6) {
    if (match = matchers.hex6.exec(color)) {
      return Number.parseInt(match[1] + "ff", 16) >>> 0;
    }
  }
  if (colorNames[color] !== undefined) {
    return colorNames[color];
  }
  if (matchers.rgb) {
    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;
    }
  }
  if (matchers.rgba) {
    if (match = matchers.rgba.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
    }
  }
  if (matchers.hex3) {
    if (match = matchers.hex3.exec(color)) {
      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + "ff", 16) >>> 0;
    }
  }
  if (matchers.hex8) {
    if (match = matchers.hex8.exec(color)) {
      return Number.parseInt(match[1], 16) >>> 0;
    }
  }
  if (matchers.hex4) {
    if (match = matchers.hex4.exec(color)) {
      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
    }
  }
  if (matchers.hsl) {
    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;
    }
  }
  if (matchers.hsla) {
    if (match = matchers.hsla.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
    }
  }
  throw new Error(`invalid color string ${color} provided`);
}
function processColor(color) {
  const normalizedColor = normalizeColor(color);
  return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;
}

// src/prores-profile.ts
var proResProfileOptions = [
  "4444-xq",
  "4444",
  "hq",
  "standard",
  "light",
  "proxy"
];

// src/v5-flag.ts
var ENABLE_V5_BREAKING_CHANGES = false;

// src/validate-frame.ts
var validateFrame = ({
  allowFloats,
  durationInFrames,
  frame
}) => {
  if (typeof frame === "undefined") {
    throw new TypeError(`Argument missing for parameter "frame"`);
  }
  if (typeof frame !== "number") {
    throw new TypeError(`Argument passed for "frame" is not a number: ${frame}`);
  }
  if (!Number.isFinite(frame)) {
    throw new RangeError(`Frame ${frame} is not finite`);
  }
  if (frame % 1 !== 0 && !allowFloats) {
    throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);
  }
  if (frame < 0 && frame < -durationInFrames) {
    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);
  }
  if (frame > durationInFrames - 1) {
    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);
  }
};

// src/codec.ts
var validCodecs = [
  "h264",
  "h265",
  "vp8",
  "vp9",
  "mp3",
  "aac",
  "wav",
  "prores",
  "h264-mkv",
  "h264-ts",
  "gif"
];

// src/validation/validate-default-codec.ts
function validateCodec(defaultCodec, location, name) {
  if (typeof defaultCodec === "undefined") {
    return;
  }
  if (typeof defaultCodec !== "string") {
    throw new TypeError(`The "${name}" prop ${location} must be a string, but you passed a value of type ${typeof defaultCodec}.`);
  }
  if (!validCodecs.includes(defaultCodec)) {
    throw new Error(`The "${name}" prop ${location} must be one of ${validCodecs.join(", ")}, but you passed ${defaultCodec}.`);
  }
}

// src/validation/validate-default-props.ts
var validateDefaultAndInputProps = (defaultProps, name, compositionId) => {
  if (!defaultProps) {
    return;
  }
  if (typeof defaultProps !== "object") {
    throw new Error(`"${name}" must be an object, but you passed a value of type ${typeof defaultProps}`);
  }
  if (Array.isArray(defaultProps)) {
    throw new Error(`"${name}" must be an object, an array was passed ${compositionId ? `for composition "${compositionId}"` : ""}`);
  }
};

// src/validation/validate-dimensions.ts
function validateDimension(amount, nameOfProp, location) {
  if (typeof amount !== "number") {
    throw new Error(`The "${nameOfProp}" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);
  }
  if (isNaN(amount)) {
    throw new TypeError(`The "${nameOfProp}" prop ${location} must not be NaN, but is NaN.`);
  }
  if (!Number.isFinite(amount)) {
    throw new TypeError(`The "${nameOfProp}" prop ${location} must be finite, but is ${amount}.`);
  }
  if (amount % 1 !== 0) {
    throw new TypeError(`The "${nameOfProp}" prop ${location} must be an integer, but is ${amount}.`);
  }
  if (amount <= 0) {
    throw new TypeError(`The "${nameOfProp}" prop ${location} must be positive, but got ${amount}.`);
  }
}

// src/validation/validate-duration-in-frames.ts
function validateDurationInFrames(durationInFrames, options) {
  const { allowFloats, component } = options;
  if (typeof durationInFrames === "undefined") {
    throw new Error(`The "durationInFrames" prop ${component} is missing.`);
  }
  if (typeof durationInFrames !== "number") {
    throw new Error(`The "durationInFrames" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);
  }
  if (durationInFrames <= 0) {
    throw new TypeError(`The "durationInFrames" prop ${component} must be positive, but got ${durationInFrames}.`);
  }
  if (!allowFloats && durationInFrames % 1 !== 0) {
    throw new TypeError(`The "durationInFrames" prop ${component} must be an integer, but got ${durationInFrames}.`);
  }
  if (!Number.isFinite(durationInFrames)) {
    throw new TypeError(`The "durationInFrames" prop ${component} must be finite, but got ${durationInFrames}.`);
  }
}

// src/validation/validate-fps.ts
function validateFps(fps, location, isGif) {
  if (typeof fps !== "number") {
    throw new Error(`"fps" must be a number, but you passed a value of type ${typeof fps} ${location}`);
  }
  if (!Number.isFinite(fps)) {
    throw new Error(`"fps" must be a finite, but you passed ${fps} ${location}`);
  }
  if (isNaN(fps)) {
    throw new Error(`"fps" must not be NaN, but got ${fps} ${location}`);
  }
  if (fps <= 0) {
    throw new TypeError(`"fps" must be positive, but got ${fps} ${location}`);
  }
  if (isGif && fps > 50) {
    throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);
  }
}

// src/video/get-current-time.ts
var getExpectedMediaFrameUncorrected = ({
  frame,
  playbackRate,
  startFrom
}) => {
  return interpolate(frame, [-1, startFrom, startFrom + 1], [-1, startFrom, startFrom + playbackRate]);
};

// src/absolute-src.ts
var getAbsoluteSrc = (relativeSrc) => {
  if (typeof window === "undefined") {
    return relativeSrc;
  }
  if (relativeSrc.startsWith("http://") || relativeSrc.startsWith("https://") || relativeSrc.startsWith("file://") || relativeSrc.startsWith("blob:") || relativeSrc.startsWith("data:")) {
    return relativeSrc;
  }
  return new URL(relativeSrc, window.origin).href;
};

// src/video/offthread-video-source.ts
var getOffthreadVideoSource = ({
  src,
  transparent,
  currentTime,
  toneMapped
}) => {
  return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(Math.max(0, currentTime))}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;
};

// src/no-react.ts
var NoReactInternals = {
  processColor,
  truthy,
  validateFps,
  validateDimension,
  validateDurationInFrames,
  validateDefaultAndInputProps,
  validateFrame,
  serializeJSONWithSpecialTypes,
  bundleName: "bundle.js",
  bundleMapName: "bundle.js.map",
  deserializeJSONWithSpecialTypes,
  DELAY_RENDER_CALLSTACK_TOKEN,
  DELAY_RENDER_RETRY_TOKEN,
  DELAY_RENDER_CLEAR_TOKEN,
  DELAY_RENDER_ATTEMPT_TOKEN: DELAY_RENDER_RETRIES_LEFT,
  getOffthreadVideoSource,
  getExpectedMediaFrameUncorrected,
  ENABLE_V5_BREAKING_CHANGES,
  MIN_NODE_VERSION: ENABLE_V5_BREAKING_CHANGES ? 18 : 16,
  MIN_BUN_VERSION: ENABLE_V5_BREAKING_CHANGES ? "1.1.3" : "1.0.3",
  colorNames,
  DATE_TOKEN,
  FILE_TOKEN,
  validateCodec,
  proResProfileOptions
};



/***/ },

/***/ 4476
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BRAND: () => (/* binding */ BRAND),
/* harmony export */   DIRTY: () => (/* binding */ DIRTY),
/* harmony export */   EMPTY_PATH: () => (/* binding */ EMPTY_PATH),
/* harmony export */   INVALID: () => (/* binding */ INVALID),
/* harmony export */   NEVER: () => (/* binding */ NEVER),
/* harmony export */   OK: () => (/* binding */ OK),
/* harmony export */   ParseStatus: () => (/* binding */ ParseStatus),
/* harmony export */   Schema: () => (/* binding */ ZodType),
/* harmony export */   ZodAny: () => (/* binding */ ZodAny),
/* harmony export */   ZodArray: () => (/* binding */ ZodArray),
/* harmony export */   ZodBigInt: () => (/* binding */ ZodBigInt),
/* harmony export */   ZodBoolean: () => (/* binding */ ZodBoolean),
/* harmony export */   ZodBranded: () => (/* binding */ ZodBranded),
/* harmony export */   ZodCatch: () => (/* binding */ ZodCatch),
/* harmony export */   ZodDate: () => (/* binding */ ZodDate),
/* harmony export */   ZodDefault: () => (/* binding */ ZodDefault),
/* harmony export */   ZodDiscriminatedUnion: () => (/* binding */ ZodDiscriminatedUnion),
/* harmony export */   ZodEffects: () => (/* binding */ ZodEffects),
/* harmony export */   ZodEnum: () => (/* binding */ ZodEnum),
/* harmony export */   ZodError: () => (/* binding */ ZodError),
/* harmony export */   ZodFirstPartyTypeKind: () => (/* binding */ ZodFirstPartyTypeKind),
/* harmony export */   ZodFunction: () => (/* binding */ ZodFunction),
/* harmony export */   ZodIntersection: () => (/* binding */ ZodIntersection),
/* harmony export */   ZodIssueCode: () => (/* binding */ ZodIssueCode),
/* harmony export */   ZodLazy: () => (/* binding */ ZodLazy),
/* harmony export */   ZodLiteral: () => (/* binding */ ZodLiteral),
/* harmony export */   ZodMap: () => (/* binding */ ZodMap),
/* harmony export */   ZodNaN: () => (/* binding */ ZodNaN),
/* harmony export */   ZodNativeEnum: () => (/* binding */ ZodNativeEnum),
/* harmony export */   ZodNever: () => (/* binding */ ZodNever),
/* harmony export */   ZodNull: () => (/* binding */ ZodNull),
/* harmony export */   ZodNullable: () => (/* binding */ ZodNullable),
/* harmony export */   ZodNumber: () => (/* binding */ ZodNumber),
/* harmony export */   ZodObject: () => (/* binding */ ZodObject),
/* harmony export */   ZodOptional: () => (/* binding */ ZodOptional),
/* harmony export */   ZodParsedType: () => (/* binding */ ZodParsedType),
/* harmony export */   ZodPipeline: () => (/* binding */ ZodPipeline),
/* harmony export */   ZodPromise: () => (/* binding */ ZodPromise),
/* harmony export */   ZodReadonly: () => (/* binding */ ZodReadonly),
/* harmony export */   ZodRecord: () => (/* binding */ ZodRecord),
/* harmony export */   ZodSchema: () => (/* binding */ ZodType),
/* harmony export */   ZodSet: () => (/* binding */ ZodSet),
/* harmony export */   ZodString: () => (/* binding */ ZodString),
/* harmony export */   ZodSymbol: () => (/* binding */ ZodSymbol),
/* harmony export */   ZodTransformer: () => (/* binding */ ZodEffects),
/* harmony export */   ZodTuple: () => (/* binding */ ZodTuple),
/* harmony export */   ZodType: () => (/* binding */ ZodType),
/* harmony export */   ZodUndefined: () => (/* binding */ ZodUndefined),
/* harmony export */   ZodUnion: () => (/* binding */ ZodUnion),
/* harmony export */   ZodUnknown: () => (/* binding */ ZodUnknown),
/* harmony export */   ZodVoid: () => (/* binding */ ZodVoid),
/* harmony export */   addIssueToContext: () => (/* binding */ addIssueToContext),
/* harmony export */   any: () => (/* binding */ anyType),
/* harmony export */   array: () => (/* binding */ arrayType),
/* harmony export */   bigint: () => (/* binding */ bigIntType),
/* harmony export */   boolean: () => (/* binding */ booleanType),
/* harmony export */   coerce: () => (/* binding */ coerce),
/* harmony export */   custom: () => (/* binding */ custom),
/* harmony export */   date: () => (/* binding */ dateType),
/* harmony export */   "default": () => (/* binding */ z),
/* harmony export */   defaultErrorMap: () => (/* binding */ errorMap),
/* harmony export */   discriminatedUnion: () => (/* binding */ discriminatedUnionType),
/* harmony export */   effect: () => (/* binding */ effectsType),
/* harmony export */   "enum": () => (/* binding */ enumType),
/* harmony export */   "function": () => (/* binding */ functionType),
/* harmony export */   getErrorMap: () => (/* binding */ getErrorMap),
/* harmony export */   getParsedType: () => (/* binding */ getParsedType),
/* harmony export */   "instanceof": () => (/* binding */ instanceOfType),
/* harmony export */   intersection: () => (/* binding */ intersectionType),
/* harmony export */   isAborted: () => (/* binding */ isAborted),
/* harmony export */   isAsync: () => (/* binding */ isAsync),
/* harmony export */   isDirty: () => (/* binding */ isDirty),
/* harmony export */   isValid: () => (/* binding */ isValid),
/* harmony export */   late: () => (/* binding */ late),
/* harmony export */   lazy: () => (/* binding */ lazyType),
/* harmony export */   literal: () => (/* binding */ literalType),
/* harmony export */   makeIssue: () => (/* binding */ makeIssue),
/* harmony export */   map: () => (/* binding */ mapType),
/* harmony export */   nan: () => (/* binding */ nanType),
/* harmony export */   nativeEnum: () => (/* binding */ nativeEnumType),
/* harmony export */   never: () => (/* binding */ neverType),
/* harmony export */   "null": () => (/* binding */ nullType),
/* harmony export */   nullable: () => (/* binding */ nullableType),
/* harmony export */   number: () => (/* binding */ numberType),
/* harmony export */   object: () => (/* binding */ objectType),
/* harmony export */   objectUtil: () => (/* binding */ objectUtil),
/* harmony export */   oboolean: () => (/* binding */ oboolean),
/* harmony export */   onumber: () => (/* binding */ onumber),
/* harmony export */   optional: () => (/* binding */ optionalType),
/* harmony export */   ostring: () => (/* binding */ ostring),
/* harmony export */   pipeline: () => (/* binding */ pipelineType),
/* harmony export */   preprocess: () => (/* binding */ preprocessType),
/* harmony export */   promise: () => (/* binding */ promiseType),
/* harmony export */   quotelessJson: () => (/* binding */ quotelessJson),
/* harmony export */   record: () => (/* binding */ recordType),
/* harmony export */   set: () => (/* binding */ setType),
/* harmony export */   setErrorMap: () => (/* binding */ setErrorMap),
/* harmony export */   strictObject: () => (/* binding */ strictObjectType),
/* harmony export */   string: () => (/* binding */ stringType),
/* harmony export */   symbol: () => (/* binding */ symbolType),
/* harmony export */   transformer: () => (/* binding */ effectsType),
/* harmony export */   tuple: () => (/* binding */ tupleType),
/* harmony export */   undefined: () => (/* binding */ undefinedType),
/* harmony export */   union: () => (/* binding */ unionType),
/* harmony export */   unknown: () => (/* binding */ unknownType),
/* harmony export */   util: () => (/* binding */ util),
/* harmony export */   "void": () => (/* binding */ voidType),
/* harmony export */   z: () => (/* binding */ z)
/* harmony export */ });
var util;
(function (util) {
    util.assertEqual = (val) => val;
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util || (util = {}));
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second, // second overwrites first
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    get errors() {
        return this.issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    util.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            util.assertNever(issue);
    }
    return { message };
};

let overrideErrorMap = errorMap;
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage,
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap, // then global default map
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            syncPairs.push({
                key: await pair.key,
                value: await pair.value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (key.value !== "__proto__" &&
                (typeof value.value !== "undefined" || pair.alwaysSet)) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        if (typeof ctx.data === "undefined") {
            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
        }
        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
    }
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this, this._def);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
// Adapted from https://stackoverflow.com/a/3143231
const datetimeRegex = (args) => {
    if (args.precision) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
    }
    else if (args.precision === 0) {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
    }
    else {
        if (args.offset) {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
        }
        else {
            return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
    }
};
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...errorUtil.errToObj(message),
        });
        /**
         * @deprecated Use z.string().min(1) instead.
         * @see {@link ZodString.min}
         */
        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
        this.trim = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
        this.toLowerCase = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
        this.toUpperCase = () => new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            }
            //
            );
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
        var _a;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...errorUtil.errToObj(message),
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params) => {
    var _a;
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" ||
            (ch.kind === "multipleOf" && util.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" ||
                ch.kind === "int" ||
                ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.bigint,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                addIssueToContext(ctx, {
                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever &&
            this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    syncPairs.push({
                        key,
                        value: await pair.value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    /**
     * @deprecated
     */
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(util.objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return Object.keys(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else {
        return null;
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = util.objectKeys(b);
        const sharedKeys = util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date &&
        bType === ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(async function (...args) {
                const error = new ZodError([]);
                const parsedArgs = await me._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(function (...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args
                ? args
                : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values) {
        return ZodEnum.create(values);
    }
    exclude(values) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string &&
            ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
            const expectedValues = util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise &&
            ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.issues.length) {
                return {
                    status: "dirty",
                    value: ctx.data,
                };
            }
            if (ctx.common.async) {
                return Promise.resolve(processed).then((processed) => {
                    return this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                });
            }
            else {
                return this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc
            // effect: RefinementEffect<any>
            ) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!isValid(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!isValid(base))
                        return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        util.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function"
            ? params.default
            : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if (isAsync(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return DIRTY(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        if (isValid(result)) {
            result.value = Object.freeze(result.value);
        }
        return result;
    }
}
ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params),
    });
};
const custom = (check, params = {}, 
/*
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal) => {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            if (!check(data)) {
                const p = typeof params === "function"
                    ? params(data)
                    : typeof params === "string"
                        ? { message: params }
                        : params;
                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                const p2 = typeof p === "string" ? { message: p } : p;
                ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
            }
        });
    return ZodAny.create();
};
const late = {
    object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (
// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
};
const NEVER = INVALID;

var z = /*#__PURE__*/Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap: setErrorMap,
    getErrorMap: getErrorMap,
    makeIssue: makeIssue,
    EMPTY_PATH: EMPTY_PATH,
    addIssueToContext: addIssueToContext,
    ParseStatus: ParseStatus,
    INVALID: INVALID,
    DIRTY: DIRTY,
    OK: OK,
    isAborted: isAborted,
    isDirty: isDirty,
    isValid: isValid,
    isAsync: isAsync,
    get util () { return util; },
    get objectUtil () { return objectUtil; },
    ZodParsedType: ZodParsedType,
    getParsedType: getParsedType,
    ZodType: ZodType,
    ZodString: ZodString,
    ZodNumber: ZodNumber,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodDate: ZodDate,
    ZodSymbol: ZodSymbol,
    ZodUndefined: ZodUndefined,
    ZodNull: ZodNull,
    ZodAny: ZodAny,
    ZodUnknown: ZodUnknown,
    ZodNever: ZodNever,
    ZodVoid: ZodVoid,
    ZodArray: ZodArray,
    ZodObject: ZodObject,
    ZodUnion: ZodUnion,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodIntersection: ZodIntersection,
    ZodTuple: ZodTuple,
    ZodRecord: ZodRecord,
    ZodMap: ZodMap,
    ZodSet: ZodSet,
    ZodFunction: ZodFunction,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodEnum: ZodEnum,
    ZodNativeEnum: ZodNativeEnum,
    ZodPromise: ZodPromise,
    ZodEffects: ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional: ZodOptional,
    ZodNullable: ZodNullable,
    ZodDefault: ZodDefault,
    ZodCatch: ZodCatch,
    ZodNaN: ZodNaN,
    BRAND: BRAND,
    ZodBranded: ZodBranded,
    ZodPipeline: ZodPipeline,
    ZodReadonly: ZodReadonly,
    custom: custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late: late,
    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },
    coerce: coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    'enum': enumType,
    'function': functionType,
    'instanceof': instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    'null': nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    'undefined': undefinedType,
    union: unionType,
    unknown: unknownType,
    'void': voidType,
    NEVER: NEVER,
    ZodIssueCode: ZodIssueCode,
    quotelessJson: quotelessJson,
    ZodError: ZodError
});




/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; (typeof current == 'object' || typeof current == 'function') && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "lapaas-ai-editor:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			792: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunklapaas_ai_editor"] = self["webpackChunklapaas_ai_editor"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__(6507);
/******/ 	__webpack_require__(9545);
/******/ 	__webpack_require__(3610);
/******/ 	var __webpack_exports__ = __webpack_require__(3482);
/******/ 	
/******/ })()
;
//# sourceMappingURL=bundle.js.map